{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"JSL - JSON Serializable Language","text":""},{"location":"#a-network-native-functional-programming-language","title":"A Network-Native Functional Programming Language","text":"<p>JSL is a Lisp-like functional programming language designed from the ground up for network transmission and distributed computing. Unlike traditional languages that treat serialization as an afterthought, JSL makes wire-format compatibility a first-class design principle.</p> <p>In an era of distributed systems and microservices, JSL addresses common challenges in code mobility, runtime dependencies, and cross-platform interoperability by treating JSON as the canonical representation for both data and code.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83d\udd04 Network-Native: Every JSL program is valid JSON that can be transmitted over networks</li> <li>\ud83d\udd12 Secure by Design: Host environment controls all capabilities and side effects</li> <li>\ud83d\udce6 Closure Serializability: Functions with captured environments can be serialized and reconstructed</li> <li>\ud83c\udfaf Homoiconic: Code and data share the same JSON representation</li> <li>\u26a1 Deterministic: Core language evaluation is predictable and reproducible</li> <li>\ud83d\udd27 Extensible: Built-in prelude provides practical functionality</li> <li>\ud83c\udfd7\ufe0f First-Class Objects: JSON objects are native data structures with dynamic construction support</li> </ul>"},{"location":"#core-design-principles","title":"Core Design Principles","text":"<p>JSL is built upon fundamental principles that guide every aspect of its design:</p> <ul> <li>JSON as Code and Data: All JSL programs and data structures are representable as standard JSON. This ensures universal parsing, generation, and compatibility with a vast ecosystem of tools and platforms.</li> <li>Network-Native: The language is designed for seamless transmission over networks. Its serialization format is inherently web-friendly and requires no complex marshalling/unmarshalling beyond standard JSON processing.</li> <li>Serializable Closures: JSL provides a mechanism for serializing closures, including their lexical environments (user-defined bindings), allowing functions to be truly mobile.</li> <li>Effect Reification: Side-effects are not executed directly within the core language evaluation but are described as data structures, allowing host environments to control, audit, or modify them.</li> <li>Deterministic Evaluation: The core JSL evaluation (excluding host interactions) is deterministic, facilitating testing, debugging, and predictable behavior.</li> <li>Security through Capability Restriction: The host environment governs the capabilities available to JSL programs, particularly for side-effecting operations.</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>// Define and call a factorial function using a local binding\n[\"let\", [\n  [\"factorial\", \n    [\"lambda\", [\"n\"], \n      [\"if\", [\"&lt;=\", \"n\", 1], \n        1, \n        [\"*\", \"n\", [\"factorial\", [\"-\", \"n\", 1]]]\n      ]\n    ]\n  ]\n],\n  [\"factorial\", 5]\n]\n// \u2192 120\n</code></pre> <p>This JSL program:</p> <ol> <li>Is valid JSON - can be stored, transmitted, and parsed by any JSON-compliant system</li> <li>Defines a function - creates a recursive factorial function</li> <li>Captures closures - the function can be serialized with its environment</li> <li>Produces a result - evaluates to 120</li> </ol>"},{"location":"#theoretical-foundations","title":"Theoretical Foundations","text":"<p>JSL draws inspiration from several key concepts in computer science and programming language theory:</p> <ul> <li>Homoiconicity: Like Lisp, JSL code and data share the same structural representation. However, JSL uses JSON arrays and objects instead of S-expressions, leveraging JSON's widespread adoption and strict schema.</li> <li>Lexical Scoping and Closures: JSL employs lexical scoping. Functions (<code>lambda</code> forms) can capture variables from their surrounding lexical environments, forming closures. The serialization mechanism is designed to preserve these captured environments.</li> <li>Functional Programming: JSL encourages a functional programming style, emphasizing immutability, first-class functions, and expressions over statements.</li> <li>Separation of Pure Computation and Effects: The core JSL interpreter deals with pure computation. Interactions with the external world (I/O, system calls) are managed via the JSL Host Interaction Protocol (JHIP), where effects are requested as data.</li> </ul>"},{"location":"#why-jsl","title":"Why JSL?","text":""},{"location":"#the-problem-with-traditional-code-mobility","title":"The Problem with Traditional Code Mobility","text":"<p>Modern distributed systems need to move code between services, store executable logic in databases, and update running systems dynamically. Traditional approaches face fundamental limitations:</p> <ul> <li>Serialization brittleness - Complex frameworks that break across versions</li> <li>Runtime dependencies - Code tied to specific environments and libraries  </li> <li>Security vulnerabilities - Deserializing arbitrary code creates attack vectors</li> <li>Platform lock-in - Language-specific formats prevent interoperability</li> </ul>"},{"location":"#the-jsl-solution","title":"The JSL Solution","text":"<p>JSL solves these problems by making JSON the native representation for both code and data:</p> <ul> <li>Universal compatibility - Works with any system that supports JSON</li> <li>Intrinsic safety - Transmitted code contains no executable primitives</li> <li>Runtime independence - Compatible prelude provides computational foundation</li> <li>Cross-platform - Language-agnostic JSON representation</li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":"<p>JSL's design makes it suitable for a variety of applications:</p> <ul> <li>Distributed Computing: Send computations to where data resides, reducing network overhead and improving performance</li> <li>Edge Computing: Deploy and update logic on edge devices dynamically without full redeployment</li> <li>Serverless Functions / FaaS: Represent functions as JSON, simplifying deployment and management</li> <li>Database Functions: Store and execute business logic directly in databases in a portable format  </li> <li>Microservice Communication: Share functional components across service boundaries with guaranteed compatibility</li> <li>Code as Configuration: Express complex configurations as executable programs that can be validated and tested</li> <li>Workflow Automation: Define complex workflows as JSL programs that can be stored, versioned, and executed anywhere</li> <li>Plugin Systems: Allow users to extend applications with sandboxed, serializable plugins</li> <li>Live Programming: Update running systems by transmitting new code without service interruption</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Getting Started - Set up JSL in your environment and learn the basics.</li> <li>Language Guide - Learn the syntax and semantics</li> <li>Tutorials - Step-by-step examples</li> </ol>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<p>JSL consists of three layers:</p> <ol> <li>Prelude Layer - Non-serializable built-in functions that form the computational foundation</li> <li>User Layer - Serializable functions and data defined by user programs  </li> <li>Wire Layer - JSON representation for transmission and storage</li> </ol> <p>This separation ensures transmitted code is always safe while remaining fully functional when reconstructed with a compatible prelude.</p>"},{"location":"#learn-more","title":"Learn More","text":"<ul> <li>Design Philosophy - Theoretical foundations and principles</li> <li>AST Specification - Formal language syntax definition</li> <li>JHIP Protocol - Host interaction for side effects</li> <li>API Reference - Complete function documentation</li> </ul>"},{"location":"getting-started/","title":"Getting Started with JSL","text":"<p>This guide provides a concise introduction to JSL to get you up and running in minutes. JSL is a lightweight, functional programming language that uses JSON for its syntax, making it ideal for data manipulation, configuration, and network-native applications.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>JSL requires Python 3.8 or later.</p>"},{"location":"getting-started/#from-source","title":"From Source","text":"<p>Clone the repository and install JSL using pip:</p> <pre><code>git clone https://github.com/queelius/jsl.git\ncd jsl\npip install -e .\n</code></pre>"},{"location":"getting-started/#verify-installation","title":"Verify Installation","text":"<p>You can verify the installation by running a simple program or by starting the interactive REPL:</p> <pre><code># Run a simple JSL program from the command line\necho '[\"print\", \"@Hello, JSL!\"]' | jsl\n\n# Start the interactive REPL\njsl --repl\n</code></pre>"},{"location":"getting-started/#your-first-jsl-program","title":"Your First JSL Program","text":"<p>JSL programs are simply JSON data structures. Create a file named <code>hello.jsl</code> with the following content:</p> <pre><code>[\"print\", \"@Hello, World!\"]\n</code></pre> <p>Execute it from your terminal:</p> <pre><code>jsl hello.jsl\n</code></pre> <p>You should see the output: <code>Hello, World!</code></p> <p>Note on File Extensions We recommend using the <code>.jsl</code> extension for your JSL program files. This helps distinguish them from regular JSON data files and allows for better editor integration. However, the <code>jsl</code> interpreter will happily run files with a <code>.json</code> extension, preserving the principle that all JSL code is valid JSON.</p>"},{"location":"getting-started/#core-concepts","title":"Core Concepts","text":""},{"location":"getting-started/#literals-and-variables","title":"Literals and Variables","text":"<p>Standard JSON literals like numbers, booleans, and <code>null</code> evaluate to themselves. Strings are used for both literal text and variable references. A string with an <code>@</code> prefix is a literal, while a string without it is treated as a variable.</p> <pre><code>42          // A number\n\"@hello\"    // A string literal\n\"my_variable\" // A reference to a variable\n</code></pre>"},{"location":"getting-started/#basic-operations","title":"Basic Operations","text":"<p>JSL uses prefix notation (like Lisp) for function calls. The first element of an array is the function to be called, and the rest are its arguments.</p> <pre><code>[\"+\", 1, 2, 3]\n</code></pre> <p>This expression evaluates to <code>6</code>.</p>"},{"location":"getting-started/#defining-variables-and-functions","title":"Defining Variables and Functions","text":"<p>You can define variables with <code>def</code> and functions with <code>lambda</code>. The <code>do</code> special form lets you execute a sequence of expressions.</p> <pre><code>[\n  \"do\",\n  [\"def\", \"x\", 10],\n  [\"def\", \"square\", [\"lambda\", [\"n\"], [\"*\", \"n\", \"n\"]]],\n  [\"square\", \"x\"]\n]\n</code></pre> <p>This evaluates to <code>100</code>.</p>"},{"location":"getting-started/#conditional-logic","title":"Conditional Logic","text":"<p>The <code>if</code> special form provides conditional evaluation:</p> <pre><code>[\"if\", [\"&gt;\", 5, 3], \"@Greater\", \"@Less\"]\n</code></pre> <p>This evaluates to <code>\"Greater\"</code>.</p>"},{"location":"getting-started/#a-quick-example-fibonacci","title":"A Quick Example: Fibonacci","text":"<p>Here is a more complete example that defines a recursive function to compute Fibonacci numbers and then applies it to a list of numbers:</p> <pre><code>[\n  \"do\",\n  [\"def\", \"fib\",\n   [\"lambda\", [\"n\"],\n    [\"if\", [\"&lt;=\", \"n\", 1],\n     \"n\",\n     [\"+\", [\"fib\", [\"-\", \"n\", 1]], [\"fib\", [\"-\", \"n\", 2]]]]]],\n  [\"map\", \"fib\", [\"list\", 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]\n]\n</code></pre>"},{"location":"getting-started/#running-jsl-code","title":"Running JSL Code","text":"<p>You can run JSL programs in several ways:</p> <ul> <li>From a file: <code>jsl your_program.jsl</code></li> <li>From standard input: <code>echo '[\"+\", 1, 2]' | jsl</code></li> <li>Using the REPL: <code>jsl --repl</code></li> <li>As a web service: <code>jsl --service</code></li> </ul>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you have a basic understanding of JSL, you can explore the following sections for more in-depth information:</p> <ul> <li>Language Guide: For a comprehensive overview of JSL's syntax and semantics.</li> <li>Tutorials: For guided, step-by-step lessons.</li> <li>Examples: For a collection of practical, real-world examples.</li> </ul>"},{"location":"api/compiler/","title":"Compiler API Reference","text":"<p>The compiler module (<code>jsl.compiler</code>) transforms JSL S-expressions into JPN (JSL Postfix Notation) for execution by the stack evaluator.</p>"},{"location":"api/compiler/#overview","title":"Overview","text":"<p>The compiler performs several transformations: - Infix to postfix conversion for operators - Special form compilation with control flow - Arity tracking for n-ary operations - Optimization of common patterns</p>"},{"location":"api/compiler/#functions","title":"Functions","text":""},{"location":"api/compiler/#compile_to_postfix","title":"<code>compile_to_postfix</code>","text":"<p>The main compilation function:</p>"},{"location":"api/compiler/#jsl.compiler.compile_to_postfix","title":"<code>jsl.compiler.compile_to_postfix(expr)</code>","text":"<p>Compile a JSL S-expression to JPN (JSL Postfix Notation).</p> <p>Examples:</p> <p>['+', 2, 3]           \u2192 [2, 3, '+']        # Binary (no arity needed) ['', 2, ['+', 1, 2]] \u2192 [2, 1, 2, '+', ''] # Nested binary ops ['+', 1, 2, 3, 4]     \u2192 [1, 2, 3, 4, 4, '+'] # N-ary (arity before op) ['+']                 \u2192 [0, '+']           # 0-arity ['list', 'a', 'b']    \u2192 ['a', 'b', 2, 'list'] # List creation</p> <p>Parameters:</p> Name Type Description Default <code>expr</code> <code>Any</code> <p>S-expression in JSL format</p> required <p>Returns:</p> Type Description <code>List[Any]</code> <p>JPN - list of instructions in postfix order (JSON-compatible)</p> Source code in <code>jsl/compiler.py</code> <pre><code>def compile_to_postfix(expr: Any) -&gt; List[Any]:\n    \"\"\"\n    Compile a JSL S-expression to JPN (JSL Postfix Notation).\n\n    Examples:\n        ['+', 2, 3]           \u2192 [2, 3, '+']        # Binary (no arity needed)\n        ['*', 2, ['+', 1, 2]] \u2192 [2, 1, 2, '+', '*'] # Nested binary ops\n        ['+', 1, 2, 3, 4]     \u2192 [1, 2, 3, 4, 4, '+'] # N-ary (arity before op)\n        ['+']                 \u2192 [0, '+']           # 0-arity\n        ['list', 'a', 'b']    \u2192 ['a', 'b', 2, 'list'] # List creation\n\n    Args:\n        expr: S-expression in JSL format\n\n    Returns:\n        JPN - list of instructions in postfix order (JSON-compatible)\n    \"\"\"\n    result = []\n\n    def compile_expr(e):\n        \"\"\"Recursively compile expression, appending to result.\"\"\"\n        if isinstance(e, (int, float, bool, type(None))):\n            # Literals are pushed directly\n            result.append(e)\n        elif isinstance(e, str):\n            # Strings could be variables or operators\n            # For now, just push them\n            result.append(e)\n        elif isinstance(e, list) and len(e) &gt; 0:\n            # Check if this is a special form that needs special handling\n            if detect_special_form(e):\n                # Special forms can't be compiled to regular postfix\n                # because they have special evaluation rules\n                result.append(Opcode.SPECIAL_FORM)\n                result.append(e)\n            else:\n                # Regular S-expression: [operator, arg1, arg2, ...]\n                op = e[0]\n                args = e[1:]\n\n                # If operator is itself a list (like [[\"lambda\", ...], arg]), compile it too\n                if isinstance(op, list):\n                    # Compile the operator expression\n                    compile_expr(op)\n                    # Compile all arguments\n                    for arg in args:\n                        compile_expr(arg)\n                    # Use special APPLY marker\n                    result.append(len(args))\n                    result.append('__apply__')\n                else:\n                    # Regular operator - compile arguments first\n                    for arg in args:\n                        compile_expr(arg)\n\n                    # Always append arity before operator for consistency\n                    result.append(len(args))\n                    result.append(op)\n        elif isinstance(e, list) and len(e) == 0:\n            # Empty list - use special marker with arity format\n            result.append(0)\n            result.append('__empty_list__')\n        elif isinstance(e, dict):\n            # Dictionary literal - compile keys and values\n            # Push each key-value pair, then use __dict__ operator\n            for key, value in e.items():\n                compile_expr(key)  # Compile key expression\n                compile_expr(value)  # Compile value expression\n            result.append(len(e) * 2)  # Total number of items (keys + values)\n            result.append('__dict__')  # Dictionary creation operator\n        else:\n            # Other types - push as-is\n            result.append(e)\n\n    compile_expr(expr)\n    return result\n</code></pre>"},{"location":"api/compiler/#decompile_from_postfix","title":"<code>decompile_from_postfix</code>","text":"<p>Reconstructs S-expressions from JPN (for debugging):</p>"},{"location":"api/compiler/#jsl.compiler.decompile_from_postfix","title":"<code>jsl.compiler.decompile_from_postfix(postfix)</code>","text":"<p>Convert JPN back to S-expression (for debugging/display).</p> <p>This is the inverse of compile_to_postfix: compile_to_postfix(decompile_from_postfix(jpn)) == jpn</p> <p>Parameters:</p> Name Type Description Default <code>postfix</code> <code>List[Any]</code> <p>List of JPN instructions</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Equivalent S-expression</p> <p>Examples:</p> <p>[2, 3, 2, '+'] \u2192 ['+', 2, 3][1, 2, 3, 3, '+'] \u2192 ['+', 1, 2, 3]['x', 'y', 2, '+'] \u2192 ['+', 'x', 'y'][0, '+'] \u2192 ['+']  # 0-arity addition</p> Source code in <code>jsl/compiler.py</code> <pre><code>def decompile_from_postfix(postfix: List[Any]) -&gt; Any:\n    \"\"\"\n    Convert JPN back to S-expression (for debugging/display).\n\n    This is the inverse of compile_to_postfix:\n    compile_to_postfix(decompile_from_postfix(jpn)) == jpn\n\n    Args:\n        postfix: List of JPN instructions\n\n    Returns:\n        Equivalent S-expression\n\n    Examples:\n        [2, 3, 2, '+'] \u2192 ['+', 2, 3]\n        [1, 2, 3, 3, '+'] \u2192 ['+', 1, 2, 3]\n        ['x', 'y', 2, '+'] \u2192 ['+', 'x', 'y']\n        [0, '+'] \u2192 ['+']  # 0-arity addition\n    \"\"\"\n    stack = []\n    i = 0\n\n    # Set of known operators (anything that can be an operator)\n    operators = {'+', '-', '*', '/', '%', '=', '!=', '&lt;', '&gt;', '&lt;=', '&gt;=',\n                 'and', 'or', 'not', 'cons', 'append', 'first', 'rest', \n                 'length', 'str-length', 'list', 'if', 'lambda', 'let', \n                 'def', 'quote', '@', 'do', '__empty_list__'}\n\n    while i &lt; len(postfix):\n        item = postfix[i]\n\n        # Check if this could be an arity (number followed by operator)\n        if isinstance(item, int) and i + 1 &lt; len(postfix) and postfix[i + 1] in operators:\n            # This is an arity-operator pair\n            arity = item\n            operator = postfix[i + 1]\n            i += 2  # Skip both arity and operator\n\n            # Pop arguments from stack\n            if len(stack) &lt; arity:\n                raise ValueError(f\"Stack underflow: {operator} needs {arity} args, have {len(stack)}\")\n\n            args = []\n            for _ in range(arity):\n                args.insert(0, stack.pop())\n\n            # Create S-expression or handle special cases\n            if operator == '__empty_list__' and arity == 0:\n                # Special case: empty list\n                stack.append([])\n            elif arity == 0:\n                stack.append([operator])\n            else:\n                stack.append([operator] + args)\n        else:\n            # It's a literal or variable - push to stack\n            stack.append(item)\n            i += 1\n\n    if len(stack) != 1:\n        raise ValueError(f\"Invalid JPN: expected 1 item on stack, have {len(stack)}: {stack}\")\n\n    return stack[0]\n</code></pre>"},{"location":"api/compiler/#compilation-examples","title":"Compilation Examples","text":""},{"location":"api/compiler/#simple-expressions","title":"Simple Expressions","text":"<pre><code>from jsl.compiler import compile_to_postfix\n\n# Arithmetic\nexpr = [\"+\", 1, 2, 3]\njpn = compile_to_postfix(expr)\nprint(jpn)  # [1, 2, 3, 3, \"+\"]\n\n# Nested expressions\nexpr = [\"*\", [\"+\", 2, 3], 4]\njpn = compile_to_postfix(expr)\nprint(jpn)  # [2, 3, 2, \"+\", 4, 2, \"*\"]\n</code></pre>"},{"location":"api/compiler/#special-forms","title":"Special Forms","text":"<pre><code>from jsl.compiler import compile_to_postfix\nfrom jsl.stack_special_forms import Opcode\n\n# If expression\nexpr = [\"if\", [\"=\", \"x\", 5], \"yes\", \"no\"]\njpn = compile_to_postfix(expr)\n# Result includes jump instructions for control flow\n\n# Lambda expression\nexpr = [\"lambda\", [\"x\", \"y\"], [\"+\", \"x\", \"y\"]]\njpn = compile_to_postfix(expr)\n# Result: [[\"x\", \"y\"], [\"+\", \"x\", \"y\"], Opcode.SPECIAL_FORM, \"lambda\"]\n</code></pre>"},{"location":"api/compiler/#function-calls","title":"Function Calls","text":"<pre><code>from jsl.compiler import compile_to_postfix\n\n# Simple function call\nexpr = [\"square\", 5]\njpn = compile_to_postfix(expr)\nprint(jpn)  # [5, 1, \"square\"]\n\n# Multiple arguments\nexpr = [\"add\", 1, 2, 3]\njpn = compile_to_postfix(expr)\nprint(jpn)  # [1, 2, 3, 3, \"add\"]\n</code></pre>"},{"location":"api/compiler/#jpn-format","title":"JPN Format","text":""},{"location":"api/compiler/#instruction-types","title":"Instruction Types","text":"<ol> <li> <p>Literals: Push themselves onto stack    <pre><code>42           # Push number\n\"hello\"      # Push string\nTrue         # Push boolean\nNone         # Push null\n</code></pre></p> </li> <li> <p>Operators with Arity: Arity precedes operator    <pre><code>[1, 2, 3, 3, \"+\"]     # Add 3 numbers\n[5, 1, \"square\"]      # Call square with 1 argument\n</code></pre></p> </li> <li> <p>Special Forms: Use <code>Opcode.SPECIAL_FORM</code> marker    <pre><code>[condition, Opcode.SPECIAL_FORM, \"if\", ...]\n[params, body, Opcode.SPECIAL_FORM, \"lambda\"]\n</code></pre></p> </li> <li> <p>Control Flow: Jump instructions    <pre><code>[Opcode.JUMP_IF_FALSE, offset]  # Conditional jump\n[Opcode.JUMP, offset]           # Unconditional jump\n</code></pre></p> </li> </ol>"},{"location":"api/compiler/#compilation-rules","title":"Compilation Rules","text":"S-Expression JPN Output Notes <code>42</code> <code>[42]</code> Literals compile to themselves <code>\"x\"</code> <code>[\"x\"]</code> Variables compile to strings <code>[\"+\", 1, 2]</code> <code>[1, 2, 2, \"+\"]</code> Args, arity, operator <code>[\"if\", c, t, f]</code> Complex with jumps Control flow compilation <code>[\"lambda\", params, body]</code> <code>[params, body, Opcode.SPECIAL_FORM, \"lambda\"]</code> Closure creation"},{"location":"api/compiler/#decompilation","title":"Decompilation","text":"<p>For debugging, JPN can be decompiled back to S-expressions:</p> <pre><code>from jsl.compiler import compile_to_postfix, decompile_from_postfix\n\n# Original expression\noriginal = [\"*\", [\"+\", 1, 2], 3]\n\n# Compile to JPN\njpn = compile_to_postfix(original)\nprint(jpn)  # [1, 2, 2, \"+\", 3, 2, \"*\"]\n\n# Decompile back\nreconstructed = decompile_from_postfix(jpn)\nprint(reconstructed)  # [\"*\", [\"+\", 1, 2], 3]\n\nassert original == reconstructed  # True (for most expressions)\n</code></pre>"},{"location":"api/compiler/#advanced-topics","title":"Advanced Topics","text":""},{"location":"api/compiler/#optimization-opportunities","title":"Optimization Opportunities","text":"<p>The compiler could optimize common patterns: - Constant folding: Evaluate constant expressions at compile time - Dead code elimination: Remove unreachable code after <code>if</code> - Tail call optimization: Convert tail calls to jumps</p>"},{"location":"api/compiler/#custom-operators","title":"Custom Operators","text":"<p>Adding new operators requires: 1. Add to prelude with known arity 2. Compiler automatically handles them 3. No special compilation logic needed</p> <pre><code># In prelude\ndef custom_op(a, b, c):\n    return a + b * c\n\n# Register in prelude\nprelude[\"my-op\"] = custom_op\n\n# Automatically compiles correctly\nexpr = [\"my-op\", 1, 2, 3]\njpn = compile_to_postfix(expr)  # [1, 2, 3, 3, \"my-op\"]\n</code></pre>"},{"location":"api/compiler/#integration-with-stack-evaluator","title":"Integration with Stack Evaluator","text":"<pre><code>from jsl.compiler import compile_to_postfix\nfrom jsl.stack_evaluator import StackEvaluator\n\n# Compile and execute\nexpr = [\"do\",\n    [\"def\", \"x\", 10],\n    [\"*\", \"x\", 2]\n]\n\njpn = compile_to_postfix(expr)\nevaluator = StackEvaluator()\nresult = evaluator.eval(jpn)\nprint(result)  # 20\n</code></pre>"},{"location":"api/core/","title":"Core Module API Reference","text":"<p>The core module (<code>jsl.core</code>) provides the fundamental data structures, evaluator, and environment management for JSL.</p>"},{"location":"api/core/#overview","title":"Overview","text":"<p>The <code>jsl.core</code> module provides the fundamental data structures that represent the state of a JSL program: <code>Env</code> for environments and <code>Closure</code> for functions. These are the building blocks used by the Evaluator and managed by the JSLRunner.</p>"},{"location":"api/core/#classes","title":"Classes","text":""},{"location":"api/core/#env","title":"<code>Env</code>","text":"<p>The environment class manages variable bindings and scope chains.</p>"},{"location":"api/core/#jsl.core.Env","title":"<code>jsl.core.Env(bindings=None, parent=None)</code>","text":"<p>Represents a JSL environment - a scope containing variable bindings.</p> <p>Environments form a chain: each environment has an optional parent. When looking up a variable, we search the current environment first, then its parent, and so on until we find it or reach the root.</p> Source code in <code>jsl/core.py</code> <pre><code>def __init__(self, bindings: Optional[Dict[str, Any]] = None, parent: Optional['Env'] = None):\n    self.bindings = bindings or {}\n    self.parent = parent\n    # Prelude metadata (set by make_prelude)\n    self._prelude_id = None\n    self._prelude_version = None\n    self._is_prelude = False\n</code></pre>"},{"location":"api/core/#jsl.core.Env.__contains__","title":"<code>__contains__(name)</code>","text":"<p>Check if a variable exists in this environment or its parents.</p> Source code in <code>jsl/core.py</code> <pre><code>def __contains__(self, name: str) -&gt; bool:\n    \"\"\"Check if a variable exists in this environment or its parents.\"\"\"\n    if name in self.bindings:\n        return True\n    elif self.parent:\n        return name in self.parent\n    else:\n        return False\n</code></pre>"},{"location":"api/core/#jsl.core.Env.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check if two environments are equal.</p> Source code in <code>jsl/core.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    \"\"\"Check if two environments are equal.\"\"\"\n    if not isinstance(other, Env):\n        return False\n\n    # Check prelude compatibility\n    if self._is_prelude and other._is_prelude:\n        # Both are preludes - compare by ID\n        return self._prelude_id == other._prelude_id\n    elif self._is_prelude or other._is_prelude:\n        # One is prelude, other isn't - not equal\n        return False\n\n    # Get all bindings from both environments (including parents)\n    self_bindings = self.to_dict()\n    other_bindings = other.to_dict()\n\n    # Check if they have the same keys\n    if set(self_bindings.keys()) != set(other_bindings.keys()):\n        return False\n\n    # Check if all values are equal\n    for key in self_bindings:\n        self_val = self_bindings[key]\n        other_val = other_bindings[key]\n\n        # Special handling for Closures - compare structure not identity\n        if isinstance(self_val, Closure) and isinstance(other_val, Closure):\n            if not self._closures_equal(self_val, other_val):\n                return False\n        elif callable(self_val) and callable(other_val):\n            # For callable functions (like prelude), just check they're both callable\n            # Can't really compare lambdas/functions for equality in Python\n            continue\n        elif self_val != other_val:\n            return False\n\n    return True\n</code></pre>"},{"location":"api/core/#jsl.core.Env.content_hash","title":"<code>content_hash()</code>","text":"<p>Generate a content-addressable hash with cycle detection.</p> Source code in <code>jsl/core.py</code> <pre><code>def content_hash(self) -&gt; str:\n    \"\"\"Generate a content-addressable hash with cycle detection.\"\"\"\n    # Thread-local cycle detection for rock-solid safety\n    import threading\n    if not hasattr(Env, '_cycle_detection'):\n        Env._cycle_detection = threading.local()\n\n    if not hasattr(Env._cycle_detection, 'computing'):\n        Env._cycle_detection.computing = set()\n\n    env_id = id(self)\n    if env_id in Env._cycle_detection.computing:\n        # Cycle detected - return deterministic placeholder\n        return f\"cycle_{env_id:016x}\"\n\n    # Add to cycle detection set\n    Env._cycle_detection.computing.add(env_id) \n\n    try:\n        canonical = {\n            \"bindings\": self._serialize_bindings(),\n            \"parent_hash\": self.parent.content_hash() if self.parent else None\n        }\n        # Convert to string - handle special cases\n        try:\n            content = json.dumps(canonical, sort_keys=True)\n        except (TypeError, ValueError):\n            # If we can't serialize (due to complex objects), use a fallback\n            # This can happen when bindings contain data structures with Closures\n            content = str(sorted(canonical.get(\"bindings\", {}).keys())) + str(canonical.get(\"parent_hash\"))\n        return hashlib.sha256(content.encode()).hexdigest()[:16]\n\n    finally:\n        # Always clean up, even on exceptions\n        Env._cycle_detection.computing.discard(env_id)\n\n        # Clean up thread-local storage when empty\n        if not Env._cycle_detection.computing:\n            delattr(Env._cycle_detection, 'computing')\n</code></pre>"},{"location":"api/core/#jsl.core.Env.deepcopy","title":"<code>deepcopy()</code>","text":"<p>Create a deep copy of this environment, including all parents.</p> Source code in <code>jsl/core.py</code> <pre><code>def deepcopy(self) -&gt; 'Env':\n    \"\"\"Create a deep copy of this environment, including all parents.\"\"\"\n    # First, gather all bindings from this env and parents\n    all_bindings = self.to_dict()\n\n    # Create a mapping of old closures to new closures to handle cycles\n    closure_map = {}\n\n    # Create new environment with copied bindings\n    new_env = Env()\n\n    # Copy prelude metadata if present\n    new_env._prelude_id = self._prelude_id\n    new_env._prelude_version = self._prelude_version\n    new_env._is_prelude = self._is_prelude\n\n    # First pass: copy non-closure values\n    for name, value in all_bindings.items():\n        if not isinstance(value, Closure):\n            # For non-closures, just copy the value\n            if isinstance(value, (list, dict)):\n                import copy\n                new_env.bindings[name] = copy.deepcopy(value)\n            else:\n                new_env.bindings[name] = value\n\n    # Second pass: copy closures with updated env references\n    for name, value in all_bindings.items():\n        if isinstance(value, Closure):\n            # Deep copy the closure with the new environment\n            new_closure = value.deepcopy(env=new_env)\n            new_env.bindings[name] = new_closure\n            closure_map[id(value)] = new_closure\n\n    return new_env\n</code></pre>"},{"location":"api/core/#jsl.core.Env.define","title":"<code>define(name, value)</code>","text":"<p>Define a variable in this environment.</p> Source code in <code>jsl/core.py</code> <pre><code>def define(self, name: str, value: Any) -&gt; None:\n    \"\"\"Define a variable in this environment.\"\"\"\n    # Prevent modification of immutable preludes\n    if self._is_prelude:\n        raise JSLError(\"Cannot modify prelude environment. Use extend() to create a new environment.\")\n    self.bindings[name] = value\n</code></pre>"},{"location":"api/core/#jsl.core.Env.extend","title":"<code>extend(new_bindings)</code>","text":"<p>Create a new environment that extends this one with additional bindings.</p> Source code in <code>jsl/core.py</code> <pre><code>def extend(self, new_bindings: Dict[str, Any]) -&gt; 'Env':\n    \"\"\"Create a new environment that extends this one with additional bindings.\"\"\"\n    return Env(new_bindings, parent=self)\n</code></pre>"},{"location":"api/core/#jsl.core.Env.get","title":"<code>get(name)</code>","text":"<p>Look up a variable in this environment or its parents.</p> Source code in <code>jsl/core.py</code> <pre><code>def get(self, name: str) -&gt; Any:\n    \"\"\"Look up a variable in this environment or its parents.\"\"\"\n    if name in self.bindings:\n        return self.bindings[name]\n    elif self.parent:\n        return self.parent.get(name)\n    else:\n        raise SymbolNotFoundError(f\"Symbol '{name}' not found\")\n</code></pre>"},{"location":"api/core/#jsl.core.Env.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert environment bindings to a dictionary (for serialization).</p> Source code in <code>jsl/core.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert environment bindings to a dictionary (for serialization).\"\"\"\n    result = {}\n    if self.parent:\n        result.update(self.parent.to_dict())\n    result.update(self.bindings)\n    return result\n</code></pre>"},{"location":"api/core/#key-concepts","title":"Key Concepts","text":"<ul> <li>Scope Chain: When looking up a variable, if it's not found in the current <code>Env</code>, the search continues up to its parent, and so on, until the root <code>prelude</code> is reached.</li> <li>Immutability: Methods like <code>extend</code> create a new child environment rather than modifying the parent, preserving functional purity.</li> </ul> <pre><code>from jsl.core import Env\n\n# Create a new environment\nenv = Env({\"x\": 10, \"y\": 20})\n\n# Create a child environment that inherits from the parent\nchild_env = env.extend({\"z\": 30})\n\n# Variable resolution follows the chain\nprint(child_env.get(\"x\"))  # 10 (from parent)\nprint(child_env.get(\"z\"))  # 30 (from child)\n</code></pre>"},{"location":"api/core/#closure","title":"<code>Closure</code>","text":"<p>Represents a user-defined function with captured lexical environment.</p> <p>Closures capture their defining environment:</p> <pre><code>from jsl.core import Closure, Env\n\n# Create an environment that the closure will capture\nenv = Env({\"multiplier\": 3})\n\n# Create a closure that captures the 'multiplier' variable from its environment\nclosure = Closure(\n    params=[\"x\"],\n    body=[\"*\", \"multiplier\", \"x\"],\n    env=env\n)\n\n# The closure remembers the 'multiplier' value\n</code></pre>"},{"location":"api/core/#jsl.core.Closure","title":"<code>jsl.core.Closure(params, body, env)</code>  <code>dataclass</code>","text":"<p>Represents a JSL function (closure).</p> <p>A closure captures three things: 1. The parameter names it expects 2. The body expression to evaluate when called 3. The environment where it was defined (lexical scoping)</p>"},{"location":"api/core/#jsl.core.Closure.__call__","title":"<code>__call__(evaluator, args)</code>","text":"<p>Apply this closure to the given arguments.</p> Source code in <code>jsl/core.py</code> <pre><code>def __call__(self, evaluator: 'Evaluator', args: List[JSLValue]) -&gt; JSLValue:\n    \"\"\"Apply this closure to the given arguments.\"\"\"\n    if len(args) != len(self.params):\n        raise JSLTypeError(f\"Function expects {len(self.params)} arguments, got {len(args)}\")\n\n    # Create new environment extending the closure's captured environment\n    call_env = self.env.extend(dict(zip(self.params, args)))\n    return evaluator.eval(self.body, call_env)\n</code></pre>"},{"location":"api/core/#jsl.core.Closure.deepcopy","title":"<code>deepcopy(env=None)</code>","text":"<p>Create a deep copy of this closure.</p> <p>Parameters:</p> Name Type Description Default <code>env</code> <code>Optional[Env]</code> <p>Optional environment to use for the copy. If not provided,  deep copies the closure's environment.</p> <code>None</code> Source code in <code>jsl/core.py</code> <pre><code>def deepcopy(self, env: Optional['Env'] = None) -&gt; 'Closure':\n    \"\"\"\n    Create a deep copy of this closure.\n\n    Args:\n        env: Optional environment to use for the copy. If not provided,\n             deep copies the closure's environment.\n    \"\"\"\n    # Deep copy the body\n    def copy_expr(expr):\n        if isinstance(expr, list):\n            return [copy_expr(item) for item in expr]\n        elif isinstance(expr, dict):\n            return {k: copy_expr(v) for k, v in expr.items()}\n        else:\n            return expr\n\n    new_body = copy_expr(self.body)\n    new_params = self.params[:]  # Copy params list\n\n    # Use provided env or deep copy the closure's env\n    if env is not None:\n        new_env = env\n    else:\n        new_env = self.env.deepcopy() if self.env else None\n\n    return Closure(new_params, new_body, new_env)\n</code></pre>"},{"location":"api/core/#evaluator","title":"<code>Evaluator</code>","text":"<p>The main JSL expression evaluator:</p>"},{"location":"api/core/#jsl.core.Evaluator","title":"<code>jsl.core.Evaluator(host_dispatcher=None, resource_limits=None, host_gas_policy=None)</code>","text":"<p>The core JSL evaluator - recursive evaluation engine.</p> <p>This is a clean, elegant reference implementation that uses traditional  recursive tree-walking to evaluate S-expressions. It serves as the specification for JSL's semantics.</p> <p>Characteristics: - Simple and easy to understand - Direct mapping from S-expressions to evaluation - Perfect for learning and testing JSL semantics - Limited by Python's recursion depth for deep expressions</p> <p>For production use with resumption and better performance, use the  stack-based evaluator which compiles to JPN (JSL Postfix Notation).</p> Source code in <code>jsl/core.py</code> <pre><code>def __init__(self, host_dispatcher: Optional[HostDispatcher] = None, \n             resource_limits: Optional[ResourceLimits] = None,\n             host_gas_policy: Optional['HostGasPolicy'] = None):\n    self.host = host_dispatcher or HostDispatcher()\n    self.resources = ResourceBudget(resource_limits, host_gas_policy) if resource_limits else None\n</code></pre>"},{"location":"api/core/#jsl.core.Evaluator.eval","title":"<code>eval(expr, env)</code>","text":"<p>Evaluate a JSL expression in the given environment.</p> <p>This is a pure recursive evaluator without resumption support. For resumable evaluation, use the stack-based evaluator.</p> Source code in <code>jsl/core.py</code> <pre><code>def eval(self, expr: JSLExpression, env: Env) -&gt; JSLValue:\n    \"\"\"\n    Evaluate a JSL expression in the given environment.\n\n    This is a pure recursive evaluator without resumption support.\n    For resumable evaluation, use the stack-based evaluator.\n    \"\"\"\n    # Resource checking\n    if self.resources:\n        # Check time periodically\n        self.resources.check_time()\n\n        # Consume gas based on expression type\n        if isinstance(expr, (int, float, bool)) or expr is None:\n            self.resources.consume_gas(GasCost.LITERAL)\n        elif isinstance(expr, str):\n            if expr.startswith(\"@\"):\n                self.resources.consume_gas(GasCost.LITERAL)\n            else:\n                self.resources.consume_gas(GasCost.VARIABLE)\n        elif isinstance(expr, dict):\n            self.resources.consume_gas(GasCost.DICT_CREATE + \n                                      len(expr) * GasCost.DICT_PER_ITEM)\n\n    # Literals: numbers, booleans, null, objects\n    if isinstance(expr, (int, float, bool)) or expr is None:\n        return expr\n\n    # Objects: evaluate both keys and values, keys must be strings\n    if isinstance(expr, dict):\n        return self._eval_dict(expr, env)\n\n    # Strings: variables or string literals\n    if isinstance(expr, str):\n        return self._eval_string(expr, env)\n\n    # Arrays: function calls or special forms\n    if isinstance(expr, list):\n        return self._eval_list(expr, env)\n\n    raise JSLTypeError(f\"Cannot evaluate expression of type {type(expr)}\")\n</code></pre>"},{"location":"api/core/#hostdispatcher","title":"<code>HostDispatcher</code>","text":"<p>Manages host interactions for side effects:</p>"},{"location":"api/core/#jsl.core.HostDispatcher","title":"<code>jsl.core.HostDispatcher()</code>","text":"<p>Handles JHIP (JSL Host Interaction Protocol) requests.</p> <p>This is where all side effects are controlled. The host environment registers handlers for specific commands and decides what operations are permitted.</p> Source code in <code>jsl/core.py</code> <pre><code>def __init__(self):\n    self.handlers: Dict[str, Callable] = {}\n</code></pre>"},{"location":"api/core/#jsl.core.HostDispatcher.dispatch","title":"<code>dispatch(command, args)</code>","text":"<p>Dispatch a host command with arguments.</p> Source code in <code>jsl/core.py</code> <pre><code>def dispatch(self, command: str, args: List[Any]) -&gt; Any:\n    \"\"\"Dispatch a host command with arguments.\"\"\"\n    if command not in self.handlers:\n        raise JSLError(f\"Unknown host command: {command}\")\n\n    try:\n        return self.handlers[command](*args)\n    except Exception as e:\n        raise JSLError(f\"Host command '{command}' failed: {e}\")\n</code></pre>"},{"location":"api/core/#jsl.core.HostDispatcher.register","title":"<code>register(command, handler)</code>","text":"<p>Register a handler for a specific host command.</p> Source code in <code>jsl/core.py</code> <pre><code>def register(self, command: str, handler: Callable) -&gt; None:\n    \"\"\"Register a handler for a specific host command.\"\"\"\n    self.handlers[command] = handler\n</code></pre>"},{"location":"api/core/#resource-management","title":"Resource Management","text":""},{"location":"api/core/#resourcebudget","title":"<code>ResourceBudget</code>","text":""},{"location":"api/core/#jsl.core.ResourceBudget","title":"<code>jsl.core.ResourceBudget(limits=None, host_gas_policy=None)</code>","text":"<p>Comprehensive resource tracking for secure JSL execution.</p> <p>Tracks gas consumption, memory allocation, execution time, and stack depth to prevent DOS attacks and ensure fair resource allocation.</p> <p>Initialize resource budget.</p> <p>Parameters:</p> Name Type Description Default <code>limits</code> <code>Optional[ResourceLimits]</code> <p>Resource limits configuration</p> <code>None</code> <code>host_gas_policy</code> <code>Optional[HostGasPolicy]</code> <p>Gas cost policy for host operations</p> <code>None</code>"},{"location":"api/core/#jsl.core.ResourceBudget.allocate_memory","title":"<code>allocate_memory(bytes_count, description='')</code>","text":"<p>Account for memory allocation.</p> <p>Parameters:</p> Name Type Description Default <code>bytes_count</code> <code>int</code> <p>Number of bytes to allocate</p> required <code>description</code> <code>str</code> <p>Description of allocation</p> <code>''</code> <p>Raises:</p> Type Description <code>MemoryExhausted</code> <p>If memory limit would be exceeded</p>"},{"location":"api/core/#jsl.core.ResourceBudget.check_collection_size","title":"<code>check_collection_size(size)</code>","text":"<p>Check if a collection size is within limits.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Size of the collection</p> required <p>Raises:</p> Type Description <code>MemoryExhausted</code> <p>If collection size exceeds limit</p>"},{"location":"api/core/#jsl.core.ResourceBudget.check_result","title":"<code>check_result(result)</code>","text":"<p>Check resource constraints for a computed result.</p> <p>This centralizes checking for collection sizes, string lengths, etc.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>Any</code> <p>The result value to check</p> required"},{"location":"api/core/#jsl.core.ResourceBudget.check_string_length","title":"<code>check_string_length(length)</code>","text":"<p>Check if a string length is within limits.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>Length of the string</p> required <p>Raises:</p> Type Description <code>MemoryExhausted</code> <p>If string length exceeds limit</p>"},{"location":"api/core/#jsl.core.ResourceBudget.check_time","title":"<code>check_time()</code>","text":"<p>Check if time limit has been exceeded.</p> <p>Raises:</p> Type Description <code>TimeExhausted</code> <p>If time limit has been exceeded</p>"},{"location":"api/core/#jsl.core.ResourceBudget.checkpoint","title":"<code>checkpoint()</code>","text":"<p>Create a checkpoint of current resource usage.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with current resource usage</p>"},{"location":"api/core/#jsl.core.ResourceBudget.consume_gas","title":"<code>consume_gas(amount, operation='')</code>","text":"<p>Consume gas for an operation.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>Gas amount to consume</p> required <code>operation</code> <code>str</code> <p>Description of operation (for error messages)</p> <code>''</code> <p>Raises:</p> Type Description <code>GasExhausted</code> <p>If gas limit would be exceeded</p>"},{"location":"api/core/#jsl.core.ResourceBudget.consume_host_gas","title":"<code>consume_host_gas(operation)</code>","text":"<p>Consume gas for a host operation based on namespace.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>Host operation path (e.g., \"@file/read\")</p> required"},{"location":"api/core/#jsl.core.ResourceBudget.enter_call","title":"<code>enter_call()</code>","text":"<p>Enter a function call (increase stack depth).</p> <p>Raises:</p> Type Description <code>StackOverflow</code> <p>If stack depth limit would be exceeded</p>"},{"location":"api/core/#jsl.core.ResourceBudget.exit_call","title":"<code>exit_call()</code>","text":"<p>Exit a function call (decrease stack depth).</p>"},{"location":"api/core/#jsl.core.ResourceBudget.restore","title":"<code>restore(checkpoint)</code>","text":"<p>Restore resource usage from a checkpoint.</p> <p>Parameters:</p> Name Type Description Default <code>checkpoint</code> <code>Dict[str, Any]</code> <p>Previously saved checkpoint</p> required"},{"location":"api/core/#resourcelimits","title":"<code>ResourceLimits</code>","text":""},{"location":"api/core/#jsl.core.ResourceLimits","title":"<code>jsl.core.ResourceLimits(max_gas=None, max_memory=None, max_time_ms=None, max_stack_depth=100, max_collection_size=10000, max_string_length=100000)</code>","text":"<p>Configuration for resource limits.</p>"},{"location":"api/core/#gascost","title":"<code>GasCost</code>","text":""},{"location":"api/core/#jsl.core.GasCost","title":"<code>jsl.core.GasCost</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Gas costs for different operation types.</p>"},{"location":"api/core/#error-types","title":"Error Types","text":""},{"location":"api/core/#jslerror","title":"<code>JSLError</code>","text":""},{"location":"api/core/#jsl.core.JSLError","title":"<code>jsl.core.JSLError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all JSL runtime errors.</p>"},{"location":"api/core/#symbolnotfounderror","title":"<code>SymbolNotFoundError</code>","text":""},{"location":"api/core/#jsl.core.SymbolNotFoundError","title":"<code>jsl.core.SymbolNotFoundError</code>","text":"<p>               Bases: <code>JSLError</code></p> <p>Raised when a symbol cannot be found in the current environment.</p>"},{"location":"api/core/#jsltypeerror","title":"<code>JSLTypeError</code>","text":""},{"location":"api/core/#jsl.core.JSLTypeError","title":"<code>jsl.core.JSLTypeError</code>","text":"<p>               Bases: <code>JSLError</code></p> <p>Raised when there's a type mismatch in JSL operations.</p>"},{"location":"api/core/#global-state","title":"Global State","text":""},{"location":"api/core/#prelude","title":"<code>prelude</code>","text":"<p>The global prelude environment containing all built-in functions. A global, read-only instance of <code>Env</code> that contains all the JSL built-in functions (e.g., <code>+</code>, <code>map</code>, <code>get</code>). It serves as the ultimate parent of all other environments.</p> <pre><code>from jsl.core import prelude\n\n# Access built-in functions\nplus_func = prelude.get(\"+\")\nmap_func = prelude.get(\"map\")\n</code></pre>"},{"location":"api/core/#implementation-details","title":"Implementation Details","text":""},{"location":"api/core/#environment-chains","title":"Environment Chains","text":"<p>JSL uses environment chains for variable resolution:</p> <ol> <li>Current Environment: Look for variable in current scope</li> <li>Parent Environment: If not found, check parent scope  </li> <li>Continue Chain: Repeat until variable found or chain ends</li> <li>Prelude Access: All chains eventually reach the global prelude</li> </ol>"},{"location":"api/core/#closure-serialization","title":"Closure Serialization","text":"<p>Closures are designed for safe serialization:</p> <ul> <li>Parameters: Always serializable (list of strings)</li> <li>Body: Always serializable (JSON expression)</li> <li>Environment: Only user-defined bindings are serialized</li> <li>Prelude: Built-in functions are reconstructed, not serialized</li> </ul> <p>This ensures transmitted closures are safe and can be reconstructed in any compatible JSL runtime.</p>"},{"location":"api/core/#type-definitions","title":"Type Definitions","text":"<p>The module defines the following type aliases for clarity:</p> <pre><code>from typing import Union, List, Dict, Any\n\nJSLValue = Union[None, bool, int, float, str, List[Any], Dict[str, Any], Closure]\nJSLExpression = Union[JSLValue, List[Any], Dict[str, Any]]\n</code></pre>"},{"location":"api/core/#usage-examples","title":"Usage Examples","text":""},{"location":"api/core/#basic-evaluation","title":"Basic Evaluation","text":"<pre><code>from jsl.core import Evaluator, Env\nfrom jsl.prelude import make_prelude\n\n# Create evaluator and environment\nevaluator = Evaluator()\nenv = make_prelude()\n\n# Evaluate an expression\nresult = evaluator.eval([\"+\", 1, 2, 3], env)\nprint(result)  # Output: 6\n</code></pre>"},{"location":"api/core/#working-with-closures","title":"Working with Closures","text":"<pre><code>from jsl.core import Evaluator, Env\nfrom jsl.prelude import make_prelude\n\nevaluator = Evaluator()\nenv = make_prelude()\n\n# Define a function\nevaluator.eval([\"def\", \"square\", [\"lambda\", [\"x\"], [\"*\", \"x\", \"x\"]]], env)\n\n# Call the function\nresult = evaluator.eval([\"square\", 5], env)\nprint(result)  # Output: 25\n</code></pre>"},{"location":"api/core/#resource-limited-execution","title":"Resource-Limited Execution","text":"<pre><code>from jsl.core import Evaluator, ResourceBudget, ResourceLimits\n\n# Create evaluator with resource limits\nlimits = ResourceLimits(max_steps=1000, max_gas=10000)\nbudget = ResourceBudget(limits=limits)\nevaluator = Evaluator(resource_budget=budget)\n\n# Execute with resource tracking\nresult = evaluator.eval(expensive_computation, env)\nprint(f\"Gas used: {budget.gas_used}\")\nprint(f\"Steps taken: {budget.steps_taken}\")\n</code></pre>"},{"location":"api/evaluator/","title":"Evaluator API Reference","text":"<p>The core module (<code>jsl.core</code>) contains the main evaluation engine for JSL expressions.</p>"},{"location":"api/evaluator/#main-evaluator-class","title":"Main Evaluator Class","text":""},{"location":"api/evaluator/#evaluator","title":"Evaluator","text":"<p>The main evaluator class for JSL expressions.</p>"},{"location":"api/evaluator/#jsl.core.Evaluator","title":"<code>jsl.core.Evaluator(host_dispatcher=None, resource_limits=None, host_gas_policy=None)</code>","text":"<p>The core JSL evaluator - recursive evaluation engine.</p> <p>This is a clean, elegant reference implementation that uses traditional  recursive tree-walking to evaluate S-expressions. It serves as the specification for JSL's semantics.</p> <p>Characteristics: - Simple and easy to understand - Direct mapping from S-expressions to evaluation - Perfect for learning and testing JSL semantics - Limited by Python's recursion depth for deep expressions</p> <p>For production use with resumption and better performance, use the  stack-based evaluator which compiles to JPN (JSL Postfix Notation).</p> Source code in <code>jsl/core.py</code> <pre><code>def __init__(self, host_dispatcher: Optional[HostDispatcher] = None, \n             resource_limits: Optional[ResourceLimits] = None,\n             host_gas_policy: Optional['HostGasPolicy'] = None):\n    self.host = host_dispatcher or HostDispatcher()\n    self.resources = ResourceBudget(resource_limits, host_gas_policy) if resource_limits else None\n</code></pre>"},{"location":"api/evaluator/#jsl.core.Evaluator.eval","title":"<code>eval(expr, env)</code>","text":"<p>Evaluate a JSL expression in the given environment.</p> <p>This is a pure recursive evaluator without resumption support. For resumable evaluation, use the stack-based evaluator.</p> Source code in <code>jsl/core.py</code> <pre><code>def eval(self, expr: JSLExpression, env: Env) -&gt; JSLValue:\n    \"\"\"\n    Evaluate a JSL expression in the given environment.\n\n    This is a pure recursive evaluator without resumption support.\n    For resumable evaluation, use the stack-based evaluator.\n    \"\"\"\n    # Resource checking\n    if self.resources:\n        # Check time periodically\n        self.resources.check_time()\n\n        # Consume gas based on expression type\n        if isinstance(expr, (int, float, bool)) or expr is None:\n            self.resources.consume_gas(GasCost.LITERAL)\n        elif isinstance(expr, str):\n            if expr.startswith(\"@\"):\n                self.resources.consume_gas(GasCost.LITERAL)\n            else:\n                self.resources.consume_gas(GasCost.VARIABLE)\n        elif isinstance(expr, dict):\n            self.resources.consume_gas(GasCost.DICT_CREATE + \n                                      len(expr) * GasCost.DICT_PER_ITEM)\n\n    # Literals: numbers, booleans, null, objects\n    if isinstance(expr, (int, float, bool)) or expr is None:\n        return expr\n\n    # Objects: evaluate both keys and values, keys must be strings\n    if isinstance(expr, dict):\n        return self._eval_dict(expr, env)\n\n    # Strings: variables or string literals\n    if isinstance(expr, str):\n        return self._eval_string(expr, env)\n\n    # Arrays: function calls or special forms\n    if isinstance(expr, list):\n        return self._eval_list(expr, env)\n\n    raise JSLTypeError(f\"Cannot evaluate expression of type {type(expr)}\")\n</code></pre>"},{"location":"api/evaluator/#overview","title":"Overview","text":"<p>The evaluator implements JSL's core evaluation semantics:</p> <ul> <li>Expressions: Everything in JSL is an expression that evaluates to a value</li> <li>Environments: Lexical scoping with nested environment chains  </li> <li>Host Commands: Bidirectional communication with the host system</li> <li>Tail Call Optimization: Efficient recursion handling</li> </ul>"},{"location":"api/evaluator/#evaluation-rules","title":"Evaluation Rules","text":""},{"location":"api/evaluator/#literals","title":"Literals","text":"<ul> <li>Numbers: <code>42</code>, <code>3.14</code> evaluate to themselves</li> <li>Strings: <code>\"@hello\"</code> evaluates to the literal string <code>\"hello\"</code></li> <li>Booleans: <code>true</code>, <code>false</code> evaluate to themselves</li> <li>null: <code>null</code> evaluates to itself</li> </ul>"},{"location":"api/evaluator/#variables","title":"Variables","text":"<p>Variable references are resolved through the environment chain:</p> <pre><code>[\"let\", {\"x\": 42}, \"x\"]\n</code></pre>"},{"location":"api/evaluator/#special-forms","title":"Special Forms","text":"<ul> <li><code>let</code>: Creates local bindings</li> <li><code>def</code>: Defines variables in the current environment</li> <li><code>lambda</code>: Creates function closures</li> <li><code>if</code>: Conditional evaluation</li> <li><code>do</code>: Sequential execution</li> <li><code>quote</code>: Prevents evaluation</li> <li><code>host</code>: Executes host commands</li> </ul>"},{"location":"api/evaluator/#function-calls","title":"Function Calls","text":"<p>Regular function calls use list syntax:</p> <pre><code>[\"func\", \"arg1\", \"arg2\"]\n</code></pre> <p>Where <code>func</code> evaluates to a callable (function or closure).</p>"},{"location":"api/evaluator/#objects","title":"Objects","text":"<p>Objects are evaluated by evaluating all key-value pairs:</p> <pre><code>{\"key\": \"value\", \"computed\": [\"add\", 1, 2]}\n</code></pre> <p>Keys must evaluate to strings, values can be any JSL expression.</p>"},{"location":"api/evaluator/#error-handling","title":"Error Handling","text":"<p>The evaluator provides detailed error information including:</p> <ul> <li>Expression context</li> <li>Environment state</li> <li>Call stack trace</li> <li>Host command failures</li> </ul>"},{"location":"api/evaluator/#security","title":"Security","text":"<p>The evaluator includes security measures:</p> <ul> <li>Sandboxing: Host commands are controlled by the dispatcher</li> <li>Resource Limits: Evaluation depth and memory usage controls</li> <li>Safe Evaluation: No access to Python internals by default</li> </ul>"},{"location":"api/evaluator/#usage-examples","title":"Usage Examples","text":""},{"location":"api/evaluator/#basic-evaluation","title":"Basic Evaluation","text":"<pre><code>from jsl.core import Evaluator, Env\n\nevaluator = Evaluator()\nenv = Env()\n\n# Evaluate a simple expression\nresult = evaluator.eval([\"+\", 1, 2], env)\nprint(result)  # 3\n</code></pre>"},{"location":"api/evaluator/#with-variables","title":"With Variables","text":"<pre><code># Define a variable\nevaluator.eval([\"def\", \"x\", 42], env)\n\n# Use the variable\nresult = evaluator.eval([\"*\", \"x\", 2], env)\nprint(result)  # 84\n</code></pre>"},{"location":"api/evaluator/#function-definition-and-call","title":"Function Definition and Call","text":"<pre><code># Define a function\nevaluator.eval([\"def\", \"square\", [\"lambda\", [\"x\"], [\"*\", \"x\", \"x\"]]], env)\n\n# Call the function\nresult = evaluator.eval([\"square\", 5], env)\nprint(result)  # 25\n</code></pre>"},{"location":"api/evaluator/#host-commands","title":"Host Commands","text":"<pre><code>from jsl.core import HostDispatcher\n\n# Create a dispatcher with custom commands\ndispatcher = HostDispatcher()\ndispatcher.register(\"print\", lambda args: print(*args))\n\nevaluator = Evaluator(host_dispatcher=dispatcher)\n\n# Execute a host command\nevaluator.eval([\"host\", \"print\", \"@Hello, World!\"], env)\n</code></pre>"},{"location":"api/evaluator/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/evaluator/#tail-call-optimization","title":"Tail Call Optimization","text":"<p>The evaluator optimizes tail calls to prevent stack overflow in recursive functions.</p>"},{"location":"api/evaluator/#memory-management","title":"Memory Management","text":"<ul> <li>Environments use reference counting</li> <li>Closures are garbage collected when no longer referenced</li> <li>Host commands can implement resource limits</li> </ul>"},{"location":"api/evaluator/#caching","title":"Caching","text":"<ul> <li>Function closures cache their compiled form</li> <li>Environment lookups are optimized for common patterns</li> <li>Object evaluation caches key-value pairs when possible</li> </ul>"},{"location":"api/fluent/","title":"Fluent Python API","text":""},{"location":"api/fluent/#overview","title":"Overview","text":"<p>The JSL Fluent Python API provides a Pythonic way to build JSL expressions. It is designed for developers who want to leverage JSL's power within a Python environment, combining Python's scripting capabilities with JSL's safe, functional, and serializable core.</p> <p>The Fluent API does not execute code; it constructs the JSL data structures (lists and dictionaries) that you can then pass to an execution engine like the JSLRunner.</p>"},{"location":"api/fluent/#key-design-principles","title":"Key Design Principles","text":"<ol> <li>Clear Separation of Concerns: The Fluent API builds expressions, JSLRunner executes them</li> <li>Immutability: Every operation returns a new expression object</li> <li>Type Safety: Explicit methods for creating literals vs variables</li> <li>Pythonic Interface: Uses operator overloading and method chaining for natural syntax</li> </ol>"},{"location":"api/fluent/#core-concepts","title":"Core Concepts","text":"<ol> <li>Pythonic Expression Building: Construct complex JSL expressions using method chaining and operator overloading.</li> <li>Immutability: Every operation on a fluent object returns a new object representing a new JSL expression.</li> <li>Lazy Construction: Expressions are built as Python objects; they are not evaluated until passed to a runner.</li> </ol>"},{"location":"api/fluent/#getting-started-e-and-v","title":"Getting Started: <code>E</code> and <code>V</code>","text":"<p>The two fundamental building blocks are <code>E</code> (Expression builder) and <code>V</code> (Variable builder).</p> <pre><code>from jsl.fluent import E, V\nimport jsl\n\n# Use the Expression builder E for function calls\nexpr_e = E.add(1, 2, 3)\n# Represents the JSL: [\"+\", 1, 2, 3]\n\n# Use the Variable builder V for variable references\nexpr_v = V.x + V.y\n# Represents the JSL: [\"+\", \"x\", \"y\"]\n\n# Use the JSLRunner to execute the expression\nrunner = jsl.JSLRunner()\nrunner.define(\"x\", 10)\nrunner.define(\"y\", 20)\nprint(runner.execute(expr_v.to_jsl())) # Output: 30\n</code></pre>"},{"location":"api/fluent/#string-literals-vs-variables","title":"String Literals vs Variables","text":"<p>JSL distinguishes between string literals and variable names. The Fluent API provides explicit methods to handle this:</p> <pre><code>from jsl.fluent import E, V, literal\n\n# Variable reference (will lookup \"name\" in environment)\nvar_ref = V.name\n# Represents: \"name\"\n\n# String literal (the actual string \"hello\")\nstr_lit = E.string(\"hello\")\n# Represents: \"@hello\"\n\n# Alternative using literal() function\nstr_lit2 = literal(\"hello\")\n# Also represents: \"@hello\"\n\n# In expressions\ngreeting = E.str_concat(E.string(\"Hello \"), V.name)\n# Represents: [\"str-concat\", \"@Hello \", \"name\"]\n\n# The runner distinguishes between them\nrunner = jsl.JSLRunner()\nrunner.define(\"name\", \"World\")\nprint(runner.execute(greeting.to_jsl()))  # Output: \"Hello World\"\n</code></pre>"},{"location":"api/fluent/#method-chaining-and-pipelines","title":"Method Chaining and Pipelines","text":"<p>For linear sequences of operations, the fluent API supports method chaining, creating a clean, readable pipeline.</p> <pre><code>from jsl.fluent import E, V\nimport jsl\n\n# Define a pipeline using method chaining\npipeline = E.list(1, 2, 3, 4, 5, 6).map(\n    E.lambda_(\"n\", V.n * 2)\n).filter(\n    E.lambda_(\"n\", V.n &gt; 5)\n)\n\n# The `pipeline` object now represents a complex, nested JSL expression.\n# Pass it to a runner to execute it.\nrunner = jsl.JSLRunner()\nprint(runner.execute(pipeline.to_jsl())) # Output: [6, 8, 10, 12]\n</code></pre>"},{"location":"api/fluent/#complex-expressions","title":"Complex Expressions","text":"<p>The Fluent API supports building arbitrarily complex JSL expressions:</p> <pre><code>from jsl.fluent import E, V\n\n# Conditional with let binding\nexpr = E.let(\n    {\"threshold\": 10},\n    E.if_(\n        V.value &gt; V.threshold,\n        E.string(\"high\"),\n        E.string(\"low\")\n    )\n)\n\n# Nested function definitions\ncalculator = E.do(\n    E.def_(\"add\", E.lambda_([\"a\", \"b\"], V.a + V.b)),\n    E.def_(\"multiply\", E.lambda_([\"a\", \"b\"], V.a * V.b)),\n    E.def_(\"calculate\", E.lambda_([\"x\", \"y\"],\n        E.if_(\n            V.operation == E.string(\"add\"),\n            E.add(V.x, V.y),\n            E.multiply(V.x, V.y)\n        )\n    ))\n)\n</code></pre>"},{"location":"api/fluent/#api-reference","title":"API Reference","text":""},{"location":"api/fluent/#expression-builder-e","title":"Expression Builder (<code>E</code>)","text":"<p>The expression builder provides methods for all JSL functions:</p> <ul> <li>Arithmetic: <code>add()</code>, <code>subtract()</code>, <code>multiply()</code>, <code>divide()</code></li> <li>Comparison: <code>equals()</code>, <code>less_than()</code>, <code>greater_than()</code></li> <li>Logic: <code>if_()</code>, <code>and_()</code>, <code>or_()</code>, <code>not_()</code></li> <li>Data: <code>list()</code>, <code>object()</code>, <code>string()</code>, <code>quote()</code></li> <li>Functions: <code>lambda_()</code>, <code>def_()</code>, <code>let()</code>, <code>do()</code></li> <li>Collections: <code>map()</code>, <code>filter()</code>, <code>reduce()</code>, <code>get()</code></li> <li>Strings: <code>str_concat()</code>, <code>str_split()</code>, <code>str_upper()</code>, <code>str_lower()</code></li> <li>Host: <code>host()</code> for host interactions</li> </ul>"},{"location":"api/fluent/#variable-builder-v","title":"Variable Builder (<code>V</code>)","text":"<p>Access variables using attribute syntax:</p> <pre><code>V.variable_name  # Simple variable\nV[\"complex-name\"]  # Variables with special characters\n</code></pre>"},{"location":"api/fluent/#utility-functions","title":"Utility Functions","text":"<ul> <li><code>literal(value)</code>: Create a literal value (string, list, or dict)</li> <li><code>var(name)</code>: Create a variable reference</li> <li><code>expr(jsl)</code>: Wrap existing JSL in fluent interface</li> <li><code>pipeline(initial)</code>: Create a pipeline for chaining operations</li> </ul>"},{"location":"api/fluent/#integration-with-jslrunner","title":"Integration with JSLRunner","text":"<p>The Fluent API is designed to work seamlessly with JSLRunner:</p> <pre><code>from jsl.fluent import E, V\nfrom jsl.runner import JSLRunner\n\n# Create runner with security settings\nrunner = JSLRunner(security={\"sandbox_mode\": True})\n\n# Build complex expression with Fluent API\nexpr = E.let(\n    {\"data\": E.list(1, 2, 3, 4, 5)},\n    V.data.map(E.lambda_(\"x\", V.x * V.x)).reduce(\n        E.lambda_([\"acc\", \"x\"], V.acc + V.x),\n        0\n    )\n)\n\n# Execute the expression\nresult = runner.execute(expr.to_jsl())\nprint(result)  # Output: 55 (sum of squares)\n</code></pre>"},{"location":"api/fluent/#best-practices","title":"Best Practices","text":"<ol> <li>Use <code>E.string()</code> or <code>literal()</code> for string literals, not raw strings</li> <li>Use <code>V</code> for variable references, not quoted strings</li> <li>Call <code>.to_jsl()</code> when passing to JSLRunner</li> <li>Leverage method chaining for readable pipelines</li> <li>Use explicit methods like <code>E.if_()</code> over dynamic <code>E.if()</code></li> </ol>"},{"location":"api/runner/","title":"Runner API","text":""},{"location":"api/runner/#overview","title":"Overview","text":"<p>The JSL Runner API provides the core execution engine for JSL programs, handling evaluation, environment management, and host interaction coordination.</p>"},{"location":"api/runner/#core-classes","title":"Core Classes","text":"<p>JSL Runner - High-level execution interface</p> <p>This module provides the JSLRunner class and related utilities for executing JSL programs with advanced features like environment management, host interaction, and performance monitoring.</p>"},{"location":"api/runner/#jsl.runner.JSLRunner","title":"<code>JSLRunner(config=None, security=None, resource_limits=None, host_gas_policy=None, use_recursive_evaluator=False)</code>","text":"<p>High-level JSL execution engine with advanced features.</p> <p>Initialize JSL runner.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Optional[Dict[str, Any]]</code> <p>Configuration options (recursion depth, debugging, etc.)</p> <code>None</code> <code>security</code> <code>Optional[Dict[str, Any]]</code> <p>Security settings (allowed commands, sandbox mode, etc.)</p> <code>None</code> <code>resource_limits</code> <code>Optional[ResourceLimits]</code> <p>Resource limits for execution</p> <code>None</code> <code>host_gas_policy</code> <code>Optional[HostGasPolicy]</code> <p>Gas cost policy for host operations</p> <code>None</code> <code>use_recursive_evaluator</code> <code>bool</code> <p>If True, use recursive evaluator instead of stack (default: False)</p> <code>False</code> Source code in <code>jsl/runner.py</code> <pre><code>def __init__(self, config: Optional[Dict[str, Any]] = None, \n             security: Optional[Dict[str, Any]] = None,\n             resource_limits: Optional[ResourceLimits] = None,\n             host_gas_policy: Optional[HostGasPolicy] = None,\n             use_recursive_evaluator: bool = False):\n    \"\"\"\n    Initialize JSL runner.\n\n    Args:\n        config: Configuration options (recursion depth, debugging, etc.)\n        security: Security settings (allowed commands, sandbox mode, etc.)\n        resource_limits: Resource limits for execution\n        host_gas_policy: Gas cost policy for host operations\n        use_recursive_evaluator: If True, use recursive evaluator instead of stack (default: False)\n    \"\"\"\n    self.config = config or {}\n    self.security = security or {}\n    self.use_recursive_evaluator = use_recursive_evaluator\n\n    # Set up host dispatcher\n    self.host_dispatcher = HostDispatcher()\n\n    # Set up base environment - keep prelude separate\n    self.prelude = make_prelude()\n    # Working environment extends the prelude (can be modified)\n    self.base_environment = self.prelude.extend({})\n\n    # Set up resource limits\n    if resource_limits is None and self.config:\n        # Build from config\n        resource_limits = ResourceLimits(\n            max_gas=self.config.get('max_gas'),\n            max_memory=self.config.get('max_memory'),\n            max_time_ms=self.config.get('max_time_ms'),\n            max_stack_depth=self.config.get('max_stack_depth'),\n            max_collection_size=self.config.get('max_collection_size'),\n            max_string_length=self.config.get('max_string_length')\n        )\n\n    # Set up evaluators\n    if use_recursive_evaluator:\n        # Recursive evaluator as reference implementation\n        self.recursive_evaluator = Evaluator(\n            self.host_dispatcher, \n            resource_limits=resource_limits,\n            host_gas_policy=host_gas_policy\n        )\n        self.stack_evaluator = None\n    else:\n        # Stack evaluator is the default for production use\n        # Create resource budget if we have limits\n        budget = None\n        if resource_limits:\n            from .resources import ResourceBudget\n            budget = ResourceBudget(resource_limits, host_gas_policy)\n        self.stack_evaluator = StackEvaluator(\n            env=self.base_environment,\n            resource_budget=budget,\n            host_dispatcher=self.host_dispatcher\n        )\n        self.recursive_evaluator = None\n\n    # Keep backward compatibility - evaluator points to the active one\n    self.evaluator = self.recursive_evaluator if use_recursive_evaluator else self.stack_evaluator\n\n    # Store for reference\n    self.resource_limits = resource_limits\n    self.host_gas_policy = host_gas_policy\n\n    # Performance tracking\n    self._profiling_enabled = False\n    self._performance_stats = {}\n\n    # Apply configuration\n    self._apply_config()\n</code></pre>"},{"location":"api/runner/#jsl.runner.JSLRunner.add_host_handler","title":"<code>add_host_handler(command, handler)</code>","text":"<p>Add a host command handler.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>Command name (e.g., \"file\", \"time\")</p> required <code>handler</code> <code>Any</code> <p>Handler object or function</p> required Source code in <code>jsl/runner.py</code> <pre><code>def add_host_handler(self, command: str, handler: Any) -&gt; None:\n    \"\"\"\n    Add a host command handler.\n\n    Args:\n        command: Command name (e.g., \"file\", \"time\")\n        handler: Handler object or function\n    \"\"\"\n    # Check security restrictions\n    allowed_commands = self.security.get('allowed_host_commands')\n    if allowed_commands and command not in allowed_commands:\n        raise JSLRuntimeError(f\"Host command '{command}' not allowed by security policy\")\n\n    self.host_dispatcher.register(command, handler)\n</code></pre>"},{"location":"api/runner/#jsl.runner.JSLRunner.disable_profiling","title":"<code>disable_profiling()</code>","text":"<p>Disable performance profiling.</p> Source code in <code>jsl/runner.py</code> <pre><code>def disable_profiling(self) -&gt; None:\n    \"\"\"Disable performance profiling.\"\"\"\n    self._profiling_enabled = False\n</code></pre>"},{"location":"api/runner/#jsl.runner.JSLRunner.enable_profiling","title":"<code>enable_profiling()</code>","text":"<p>Enable performance profiling.</p> Source code in <code>jsl/runner.py</code> <pre><code>def enable_profiling(self) -&gt; None:\n    \"\"\"Enable performance profiling.\"\"\"\n    self._profiling_enabled = True\n    self._performance_stats = {}\n</code></pre>"},{"location":"api/runner/#jsl.runner.JSLRunner.execute","title":"<code>execute(expression)</code>","text":"<p>Execute a JSL expression.</p> <p>Supports multiple input formats: - S-expression Lisp style: \"(+ 1 2 3)\" - S-expression JSON style: \"[\"+\", 1, 2, 3]\" - JPN postfix compiled: \"[1, 2, 3, 3, \"+\"]\"</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>Union[str, JSLExpression]</code> <p>JSL expression as string or parsed structure</p> required <p>Returns:</p> Type Description <code>JSLValue</code> <p>The result of evaluating the expression</p> <p>Raises:</p> Type Description <code>JSLSyntaxError</code> <p>If the expression is malformed</p> <code>JSLRuntimeError</code> <p>If execution fails</p> Source code in <code>jsl/runner.py</code> <pre><code>def execute(self, expression: Union[str, JSLExpression]) -&gt; JSLValue:\n    \"\"\"\n    Execute a JSL expression.\n\n    Supports multiple input formats:\n    - S-expression Lisp style: \"(+ 1 2 3)\"\n    - S-expression JSON style: \"[\\\"+\\\", 1, 2, 3]\"\n    - JPN postfix compiled: \"[1, 2, 3, 3, \\\"+\\\"]\"\n\n    Args:\n        expression: JSL expression as string or parsed structure\n\n    Returns:\n        The result of evaluating the expression\n\n    Raises:\n        JSLSyntaxError: If the expression is malformed\n        JSLRuntimeError: If execution fails\n    \"\"\"\n    start_time = time.time() if self._profiling_enabled else None\n\n    try:\n        # Detect format and parse accordingly\n        format_type = self._detect_format(expression)\n        parse_start = time.time() if self._profiling_enabled else None\n\n        if format_type == 'lisp':\n            # Parse Lisp-style S-expressions\n            if isinstance(expression, str):\n                expression = from_canonical_sexp(expression)\n            else:\n                raise JSLSyntaxError(\"Lisp format detected but expression is not a string\")\n        elif isinstance(expression, str):\n            # Try to parse as JSON\n            try:\n                expression = json.loads(expression)\n            except json.JSONDecodeError:\n                # If it's a simple identifier (variable name), keep it as-is\n                # This allows execute(\"x\") to work for variable lookup\n                if expression.isidentifier() or expression.startswith('@'):\n                    expression = expression\n                else:\n                    # Invalid JSON that's not a simple identifier\n                    raise JSLSyntaxError(f\"Invalid expression: {expression}\")\n\n        # Re-detect format after parsing\n        if isinstance(expression, list):\n            format_type = self._detect_parsed_format(expression)\n\n        if self._profiling_enabled and parse_start:\n            self._performance_stats['parse_time_ms'] = (time.time() - parse_start) * 1000\n            self._performance_stats['input_format'] = format_type\n\n        # Execute the expression\n        eval_start = time.time() if self._profiling_enabled else None\n\n        # Don't reset resources - they persist across executions\n        # If users want fresh resources, they should create a new Runner\n\n        try:\n            if format_type == 'jpn':\n                # Already in JPN format, use stack evaluator directly\n                if self.use_recursive_evaluator:\n                    # Need to decompile JPN back to S-expression for recursive evaluator\n                    expression = decompile_from_postfix(expression)\n                    result = self.recursive_evaluator.eval(expression, self.base_environment)\n                else:\n                    result = self.stack_evaluator.eval(expression, env=self.base_environment)\n            else:\n                # S-expression format (json or lisp parsed to json)\n                if self.use_recursive_evaluator:\n                    # Use recursive evaluator directly\n                    result = self.recursive_evaluator.eval(expression, self.base_environment)\n                else:\n                    # Compile to JPN and use stack evaluator\n                    jpn = compile_to_postfix(expression)\n                    result = self.stack_evaluator.eval(jpn, env=self.base_environment)\n\n            # Record performance stats\n            if self._profiling_enabled:\n                if eval_start:\n                    self._performance_stats['eval_time_ms'] = (time.time() - eval_start) * 1000\n                if start_time:\n                    self._performance_stats['total_time_ms'] = (time.time() - start_time) * 1000\n\n                # Resource usage stats (only for recursive evaluator currently)\n                if self.use_recursive_evaluator and self.recursive_evaluator.resources:\n                    checkpoint = self.recursive_evaluator.resources.checkpoint()\n                    self._performance_stats['gas_used'] = checkpoint.get('gas_used', 0)\n                    self._performance_stats['memory_used'] = checkpoint.get('memory_used', 0)\n                    self._performance_stats['stack_depth_max'] = checkpoint.get('stack_depth', 0)\n\n                # Track call count\n                self._performance_stats['call_count'] = self._performance_stats.get('call_count', 0) + 1\n\n            return result\n\n        except ResourceExhausted as e:\n            # Record resource exhaustion in stats\n            if self._profiling_enabled:\n                if self.use_recursive_evaluator and self.recursive_evaluator.resources:\n                    checkpoint = self.recursive_evaluator.resources.checkpoint()\n                    self._performance_stats['resources_exhausted'] = True\n                    self._performance_stats['gas_used'] = checkpoint.get('gas_used', 0)\n                    self._performance_stats['memory_used'] = checkpoint.get('memory_used', 0)\n\n            # Re-raise directly - ResourceExhausted is already informative\n            # The evaluator will have already set remaining_expr and env if needed\n            raise\n\n    except Exception as e:\n        if self._profiling_enabled and start_time:\n            self._performance_stats['error_time_ms'] = (time.time() - start_time) * 1000\n            self._performance_stats['error_count'] = self._performance_stats.get('error_count', 0) + 1\n\n        if isinstance(e, (JSLSyntaxError, JSLRuntimeError, ResourceExhausted)):\n            raise\n        else:\n            raise JSLRuntimeError(f\"Execution failed: {e}\")\n</code></pre>"},{"location":"api/runner/#jsl.runner.JSLRunner.get_performance_stats","title":"<code>get_performance_stats()</code>","text":"<p>Get performance statistics.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with performance metrics including:</p> <code>Dict[str, Any]</code> <ul> <li>total_time_ms: Total execution time</li> </ul> <code>Dict[str, Any]</code> <ul> <li>parse_time_ms: Time spent parsing JSON</li> </ul> <code>Dict[str, Any]</code> <ul> <li>eval_time_ms: Time spent evaluating</li> </ul> <code>Dict[str, Any]</code> <ul> <li>call_count: Number of execute() calls</li> </ul> <code>Dict[str, Any]</code> <ul> <li>error_count: Number of errors encountered</li> </ul> <code>Dict[str, Any]</code> <ul> <li>gas_used: Amount of gas consumed (if resource limits are set)</li> </ul> <code>Dict[str, Any]</code> <ul> <li>resources_exhausted: True if resource limits were hit</li> </ul> Source code in <code>jsl/runner.py</code> <pre><code>def get_performance_stats(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Get performance statistics.\n\n    Returns:\n        Dictionary with performance metrics including:\n        - total_time_ms: Total execution time\n        - parse_time_ms: Time spent parsing JSON\n        - eval_time_ms: Time spent evaluating\n        - call_count: Number of execute() calls\n        - error_count: Number of errors encountered\n        - gas_used: Amount of gas consumed (if resource limits are set)\n        - resources_exhausted: True if resource limits were hit\n    \"\"\"\n    return self._performance_stats.copy()\n</code></pre>"},{"location":"api/runner/#jsl.runner.JSLRunner.new_environment","title":"<code>new_environment()</code>","text":"<p>Create a new isolated environment context.</p> <p>Yields:</p> Name Type Description <code>ExecutionContext</code> <p>New execution context</p> Source code in <code>jsl/runner.py</code> <pre><code>@contextmanager\ndef new_environment(self):\n    \"\"\"\n    Create a new isolated environment context.\n\n    Yields:\n        ExecutionContext: New execution context\n    \"\"\"\n    # Create new environment extending the current base environment\n    # This allows access to variables defined in the parent context\n    new_env = self.base_environment.extend({})        \n    context = ExecutionContext(new_env)\n\n    # Create temporary runner for this context with same configuration\n    temp_runner = JSLRunner(\n        self.config, \n        self.security,\n        use_recursive_evaluator=self.use_recursive_evaluator\n    )\n    temp_runner.base_environment = new_env\n\n    # Update the stack evaluator's default env (if it exists)\n    # Both evaluators receive env as parameter, but stack evaluator also\n    # needs its internal env updated for variable lookups during evaluation\n    if temp_runner.stack_evaluator:\n        temp_runner.stack_evaluator.env = new_env\n\n    try:\n        yield temp_runner\n    finally:\n        # Cleanup happens automatically when context exits\n        pass\n</code></pre>"},{"location":"api/runner/#jsl.runner.JSLRunner.reset_performance_stats","title":"<code>reset_performance_stats()</code>","text":"<p>Reset performance statistics.</p> Source code in <code>jsl/runner.py</code> <pre><code>def reset_performance_stats(self) -&gt; None:\n    \"\"\"Reset performance statistics.\"\"\"\n    self._performance_stats = {}\n</code></pre>"},{"location":"api/runner/#jsl.runner.ExecutionContext","title":"<code>ExecutionContext(environment, parent=None)</code>","text":"<p>Context for a single execution session.</p> Source code in <code>jsl/runner.py</code> <pre><code>def __init__(self, environment: Env, parent: Optional['ExecutionContext'] = None):\n    self.environment = environment\n    self.parent = parent\n    self.start_time = time.time()\n    self.memory_used = 0\n</code></pre>"},{"location":"api/runner/#jsl.runner.ExecutionContext.define","title":"<code>define(name, value)</code>","text":"<p>Define a variable in this context.</p> Source code in <code>jsl/runner.py</code> <pre><code>def define(self, name: str, value: Any) -&gt; None:\n    \"\"\"Define a variable in this context.\"\"\"\n    self.environment.define(name, value)\n</code></pre>"},{"location":"api/runner/#jsl.runner.ExecutionContext.get_variable","title":"<code>get_variable(name)</code>","text":"<p>Get a variable from this context.</p> Source code in <code>jsl/runner.py</code> <pre><code>def get_variable(self, name: str) -&gt; Any:\n    \"\"\"Get a variable from this context.\"\"\"\n    try:\n        return self.environment.get(name)\n    except KeyError:\n        raise JSLRuntimeError(f\"Undefined variable: {name}\")\n</code></pre>"},{"location":"api/runner/#jsl.runner.JSLRuntimeError","title":"<code>JSLRuntimeError(message, remaining_expr=None, env=None)</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Runtime error during JSL execution.</p> Source code in <code>jsl/runner.py</code> <pre><code>def __init__(self, message: str, remaining_expr=None, env=None):\n    super().__init__(message)\n    self.remaining_expr = remaining_expr\n    self.env = env\n</code></pre>"},{"location":"api/runner/#jsl.runner.JSLSyntaxError","title":"<code>JSLSyntaxError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Syntax error in JSL code.</p>"},{"location":"api/runner/#usage-examples","title":"Usage Examples","text":""},{"location":"api/runner/#basic-program-execution","title":"Basic Program Execution","text":"<pre><code>from jsl.runner import JSLRunner\n\n# Create runner instance\nrunner = JSLRunner()\n\n# Execute simple expression\nresult = runner.execute([\"+\", 1, 2])\nprint(result)  # Output: 3\n\n# Execute with variables\nrunner.define(\"x\", 10)\nresult = runner.execute([\"*\", \"x\", 2])\nprint(result)  # Output: 20\n</code></pre>"},{"location":"api/runner/#environment-management","title":"Environment Management","text":"<pre><code># Create isolated environment\nwith runner.new_environment() as env:\n    env.define(\"temp_var\", 42)\n    result = env.execute([\"*\", \"temp_var\", 2])\n    print(result)  # Output: 84\n# temp_var is no longer accessible\n</code></pre>"},{"location":"api/runner/#closure-execution","title":"Closure Execution","text":"<pre><code># Define function\nrunner.execute([\"def\", \"square\", [\"lambda\", [\"x\"], [\"*\", \"x\", \"x\"]]])\n\n# Call function\nresult = runner.execute([\"square\", 5])\nprint(result)  # Output: 25\n\n# Access function object\nsquare_fn = runner.get_variable(\"square\")\nprint(square_fn.params)  # Output: [\"x\"]\nprint(square_fn.body)    # Output: [\"*\", \"x\", \"x\"]\n</code></pre>"},{"location":"api/runner/#host-interaction","title":"Host Interaction","text":"<pre><code>from jsl.runner import JSLRunner\nfrom jsl.jhip import FileHandler\n\n# Configure with host handlers\nrunner = JSLRunner()\nrunner.add_host_handler(\"file\", FileHandler())\n\n# Execute host interaction\nresult = runner.execute([\"host\", \"file/read\", \"/tmp/data.txt\"])\n</code></pre>"},{"location":"api/runner/#error-handling","title":"Error Handling","text":"<pre><code>try:\n    result = runner.execute([\"undefined_function\", 1, 2])\nexcept JSLRuntimeError as e:\n    print(f\"Runtime error: {e}\")\nexcept JSLSyntaxError as e:\n    print(f\"Syntax error: {e}\")\n</code></pre>"},{"location":"api/runner/#configuration-options","title":"Configuration Options","text":""},{"location":"api/runner/#runner-configuration","title":"Runner Configuration","text":"<pre><code>config = {\n    \"max_recursion_depth\": 1000,\n    \"max_steps\": 10000,  # Limit evaluation steps (None for unlimited)\n    \"enable_debugging\": True,\n    \"timeout_seconds\": 30,\n    \"memory_limit_mb\": 512\n}\n\nrunner = JSLRunner(config=config)\n</code></pre>"},{"location":"api/runner/#security-settings","title":"Security Settings","text":"<pre><code># Restrict to specific host commands\nsecurity_config = {\n    \"allowed_host_commands\": [\"file/read\", \"time/now\"]\n}\nrunner = JSLRunner(security=security_config)\n\n# Sandbox mode - blocks all host commands unless explicitly allowed\nsandbox_config = {\n    \"sandbox_mode\": True,\n    \"allowed_host_commands\": [\"safe_operation\"]  # Only this is allowed\n}\nsandbox_runner = JSLRunner(security=sandbox_config)\n\n# Complete sandbox - no host operations\nstrict_sandbox = JSLRunner(security={\"sandbox_mode\": True})\n</code></pre>"},{"location":"api/runner/#step-limiting-and-resumption","title":"Step Limiting and Resumption","text":"<p>JSL supports limiting the number of evaluation steps to prevent DOS attacks and enable fair resource allocation in distributed environments:</p> <pre><code># Create runner with step limit\nrunner = JSLRunner(config={\"max_steps\": 1000})\n\ntry:\n    result = runner.execute(complex_expression)\nexcept JSLRuntimeError as e:\n    if \"Step limit exceeded\" in str(e):\n        # Can resume with additional steps\n        if hasattr(e, 'remaining_expr'):\n            result = runner.resume(\n                e.remaining_expr, \n                e.env, \n                additional_steps=500\n            )\n</code></pre> <p>This enables:</p> <ul> <li>DOS Prevention: Limits computation to prevent infinite loops</li> <li>Fair Resource Allocation: In multi-tenant environments</li> <li>Pauseable Computation: Serialize and resume long-running tasks</li> <li>Step Accounting: Track resource usage per user/request</li> </ul>"},{"location":"api/runner/#performance-monitoring","title":"Performance Monitoring","text":"<pre><code># Enable performance tracking\nrunner.enable_profiling()\n\n# Execute expressions\nrunner.execute('[\"*\", 10, 20]')  # Parse from JSON\nrunner.execute([\"+\", 1, 2, 3])   # Direct expression\n\n# Get performance metrics\nstats = runner.get_performance_stats()\nprint(f\"Total time: {stats['total_time_ms']}ms\")\nprint(f\"Parse time: {stats.get('parse_time_ms', 0)}ms\")\nprint(f\"Eval time: {stats['eval_time_ms']}ms\")\nprint(f\"Call count: {stats['call_count']}\")\nprint(f\"Errors: {stats.get('error_count', 0)}\")\n\n# Reset stats\nrunner.reset_performance_stats()\n\n# Disable profiling\nrunner.disable_profiling()\n</code></pre>"},{"location":"api/serialization/","title":"Serialization API","text":"<p>For conceptual background on JSL's serialization design, see Architecture: Serialization.</p>"},{"location":"api/serialization/#overview","title":"Overview","text":"<p>The JSL serialization API provides functions for converting JSL code and data structures to and from JSON representations using content-addressable storage. This approach elegantly handles circular references and ensures efficient serialization of complex object graphs including closures and environments.</p>"},{"location":"api/serialization/#core-functions","title":"Core Functions","text":"<p>JSL Serialization - JSON serialization for JSL values and closures</p> <p>This module handles the serialization and deserialization of JSL values, including closures with their captured environments. Uses content-addressable storage to handle circular references elegantly.</p>"},{"location":"api/serialization/#jsl.serialization.serialize","title":"<code>serialize(obj)</code>","text":"<p>Serialize a JSL value to JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The JSL value to serialize</p> required <p>Returns:</p> Type Description <code>str</code> <p>JSON string representation</p> Source code in <code>jsl/serialization.py</code> <pre><code>def serialize(obj: Any) -&gt; str:\n    \"\"\"\n    Serialize a JSL value to JSON string.\n\n    Args:\n        obj: The JSL value to serialize\n\n    Returns:\n        JSON string representation\n    \"\"\"\n    serializer = ContentAddressableSerializer()\n    return serializer.serialize(obj)\n</code></pre>"},{"location":"api/serialization/#jsl.serialization.deserialize","title":"<code>deserialize(json_str, prelude_env=None)</code>","text":"<p>Deserialize a JSON string to JSL value.</p> <p>Parameters:</p> Name Type Description Default <code>json_str</code> <code>str</code> <p>JSON string to deserialize</p> required <code>prelude_env</code> <code>Env</code> <p>Optional prelude environment for closure reconstruction</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>Reconstructed JSL value</p> Source code in <code>jsl/serialization.py</code> <pre><code>def deserialize(json_str: str, prelude_env: Env = None) -&gt; Any:\n    \"\"\"\n    Deserialize a JSON string to JSL value.\n\n    Args:\n        json_str: JSON string to deserialize\n        prelude_env: Optional prelude environment for closure reconstruction\n\n    Returns:\n        Reconstructed JSL value\n    \"\"\"\n    deserializer = ContentAddressableDeserializer(prelude_env)\n    return deserializer.deserialize(json_str)\n</code></pre>"},{"location":"api/serialization/#jsl.serialization.to_json","title":"<code>to_json(obj)</code>","text":"<p>Convert JSL value to JSON-compatible dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>JSL value to convert</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>JSON-compatible dictionary</p> Source code in <code>jsl/serialization.py</code> <pre><code>def to_json(obj: Any) -&gt; Dict:\n    \"\"\"\n    Convert JSL value to JSON-compatible dictionary.\n\n    Args:\n        obj: JSL value to convert\n\n    Returns:\n        JSON-compatible dictionary\n    \"\"\"\n    serialized = serialize(obj)\n    return json.loads(serialized)\n</code></pre>"},{"location":"api/serialization/#jsl.serialization.from_json","title":"<code>from_json(json_data, prelude_env=None)</code>","text":"<p>Reconstruct JSL value from JSON data.</p> <p>Parameters:</p> Name Type Description Default <code>json_data</code> <code>Any</code> <p>JSON string or dictionary</p> required <code>prelude_env</code> <code>Env</code> <p>Optional prelude environment</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>Reconstructed JSL value</p> Source code in <code>jsl/serialization.py</code> <pre><code>def from_json(json_data: Any, prelude_env: Env = None) -&gt; Any:\n    \"\"\"\n    Reconstruct JSL value from JSON data.\n\n    Args:\n        json_data: JSON string or dictionary\n        prelude_env: Optional prelude environment\n\n    Returns:\n        Reconstructed JSL value\n    \"\"\"\n    if isinstance(json_data, str):\n        return deserialize(json_data, prelude_env)\n    else:\n        # Convert dict back to JSON string and deserialize\n        json_str = json.dumps(json_data)\n        return deserialize(json_str, prelude_env)\n</code></pre>"},{"location":"api/serialization/#jsl.serialization.serialize_program","title":"<code>serialize_program(program, prelude_hash=None)</code>","text":"<p>Serialize a complete JSL program with metadata.</p> <p>Parameters:</p> Name Type Description Default <code>program</code> <code>Any</code> <p>The JSL program to serialize</p> required <code>prelude_hash</code> <code>str</code> <p>Optional hash of the prelude version</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict</code> <p>Dictionary with program and metadata</p> Source code in <code>jsl/serialization.py</code> <pre><code>def serialize_program(program: Any, prelude_hash: str = None) -&gt; Dict:\n    \"\"\"\n    Serialize a complete JSL program with metadata.\n\n    Args:\n        program: The JSL program to serialize\n        prelude_hash: Optional hash of the prelude version\n\n    Returns:\n        Dictionary with program and metadata\n    \"\"\"\n    return {\n        \"version\": \"0.1.0\",\n        \"prelude_hash\": prelude_hash,\n        \"program\": to_json(program),\n        \"timestamp\": None  # Could add timestamp if needed\n    }\n</code></pre>"},{"location":"api/serialization/#jsl.serialization.deserialize_program","title":"<code>deserialize_program(program_data, prelude_env=None)</code>","text":"<p>Deserialize a complete JSL program.</p> <p>Parameters:</p> Name Type Description Default <code>program_data</code> <code>Dict</code> <p>Serialized program data</p> required <code>prelude_env</code> <code>Env</code> <p>Prelude environment for reconstruction</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>Reconstructed JSL program</p> Source code in <code>jsl/serialization.py</code> <pre><code>def deserialize_program(program_data: Dict, prelude_env: Env = None) -&gt; Any:\n    \"\"\"\n    Deserialize a complete JSL program.\n\n    Args:\n        program_data: Serialized program data\n        prelude_env: Prelude environment for reconstruction\n\n    Returns:\n        Reconstructed JSL program\n    \"\"\"\n    # Could add version checking here\n    program = program_data.get(\"program\")\n    return from_json(program, prelude_env)\n</code></pre>"},{"location":"api/serialization/#usage-examples","title":"Usage Examples","text":""},{"location":"api/serialization/#basic-serialization","title":"Basic Serialization","text":"<pre><code>from jsl.serialization import serialize, deserialize\n\n# Serialize simple JSL values\nexpr = [\"+\", 1, 2]\njson_str = serialize(expr)\n# Result: '[\"+\", 1, 2]'\n\n# Deserialize back to JSL\nrestored = deserialize(json_str)\n# Result: [\"+\", 1, 2]\n\n# Complex values use content-addressable format\nfrom jsl import eval_expression, make_prelude\nclosure = eval_expression('[\"lambda\", [\"x\"], [\"+\", \"x\", 1]]', make_prelude())\nserialized = serialize(closure)\n# Result contains \"__cas_version__\", \"root\", and \"objects\" fields\n</code></pre>"},{"location":"api/serialization/#closure-serialization","title":"Closure Serialization","text":"<pre><code>from jsl import eval_expression, make_prelude, serialize, deserialize\n\n# Create and serialize a closure with captured environment\nprogram = '''\n[\"do\",\n  [\"def\", \"base\", 100],\n  [\"lambda\", [\"x\"], [\"+\", \"x\", \"base\"]]\n]\n'''\nclosure = eval_expression(program, make_prelude())\nserialized = serialize(closure)\n\n# Deserialize with prelude environment\nrestored = deserialize(serialized, make_prelude())\n</code></pre>"},{"location":"api/serialization/#network-transmission","title":"Network Transmission","text":"<pre><code>import json\nfrom jsl.serialization import serialize\n\n# Prepare JSL code for network transmission\ncode = [\"lambda\", [\"x\"], [\"*\", \"x\", \"x\"]]\npayload = {\n    \"type\": \"execute\",\n    \"code\": serialize(code),\n    \"timestamp\": \"2023-12-01T10:00:00Z\"\n}\n\n# Send as JSON\njson_payload = json.dumps(payload)\n</code></pre>"},{"location":"api/serialization/#program-serialization","title":"Program Serialization","text":"<pre><code>from jsl.serialization import serialize_program, deserialize_program\n\n# Serialize complete program with metadata\nprogram = [\"+\", 1, 2, 3]\nprogram_data = serialize_program(program, prelude_hash=\"v1.0\")\n\n# Result includes version, prelude_hash, and program data\n# {\n#   \"version\": \"0.1.0\",\n#   \"prelude_hash\": \"v1.0\", \n#   \"program\": 6,\n#   \"timestamp\": null\n# }\n\n# Deserialize program\nrestored = deserialize_program(program_data)\n</code></pre>"},{"location":"api/serialization/#type-mappings","title":"Type Mappings","text":"JSL Type JSON Type Notes Number Number Direct mapping for primitives String String Direct mapping for primitives Boolean Boolean Direct mapping for primitives Null Null Direct mapping for primitives Array Array Direct for simple arrays, CAS for arrays containing closures Object Object Direct for simple objects, CAS for objects containing closures Closure Object CAS format with <code>__type__: \"closure\"</code> Environment Object CAS format with <code>__type__: \"env\"</code>"},{"location":"api/serialization/#serialization-formats","title":"Serialization Formats","text":"<p>JSL uses two serialization formats depending on the complexity of the data:</p> <ol> <li>Direct JSON: For primitive values and simple structures without closures</li> <li>Content-Addressable Storage (CAS): For complex objects containing closures or environments</li> </ol> <pre><code># Direct JSON format\nserialize(42)              # \"42\"\nserialize([1, 2, 3])      # \"[1,2,3]\"\nserialize({\"key\": \"val\"}) # \"{\\\"key\\\":\\\"val\\\"}\"\n\n# CAS format (contains closures/environments)\nserialize(some_closure)   # {\"__cas_version__\": 1, \"root\": {...}, \"objects\": {...}}\n</code></pre>"},{"location":"api/serialization/#error-handling","title":"Error Handling","text":"<p>The serialization API handles various error conditions:</p> <ul> <li>Circular References: Handled elegantly using content-addressable storage</li> <li>Invalid JSON: Proper error messages for malformed input</li> <li>Type Errors: Clear indication of unsupported types</li> <li>Encoding Issues: UTF-8 handling for international text</li> <li>Missing Objects: Validation of object references during deserialization</li> </ul>"},{"location":"api/serialization/#performance-notes","title":"Performance Notes","text":"<ul> <li>Time Complexity: O(n) where n is the size of the data structure</li> <li>Space Complexity: Efficient sharing of identical objects through content addressing</li> <li>Circular Reference Handling: No stack overflow or infinite loops</li> <li>Deterministic Hashing: Same content always produces same hash</li> </ul>"},{"location":"api/stack-evaluator/","title":"Stack Evaluator API Reference","text":"<p>The stack evaluator module (<code>jsl.stack_evaluator</code>) provides a stack-based virtual machine for executing JSL programs compiled to JPN (JSL Postfix Notation).</p>"},{"location":"api/stack-evaluator/#overview","title":"Overview","text":"<p>The stack evaluator offers an alternative execution model to the recursive evaluator: - Linear execution of postfix instructions - Natural resumption support for distributed computing - Efficient resource tracking with step counting - Dict-based closures for JSON serialization</p>"},{"location":"api/stack-evaluator/#classes","title":"Classes","text":""},{"location":"api/stack-evaluator/#stackevaluator","title":"<code>StackEvaluator</code>","text":"<p>The main stack-based evaluator class:</p>"},{"location":"api/stack-evaluator/#jsl.stack_evaluator.StackEvaluator","title":"<code>jsl.stack_evaluator.StackEvaluator(env=None, resource_budget=None, host_dispatcher=None)</code>","text":"<p>Evaluator for postfix expressions using a value stack.</p> <p>Initialize evaluator with optional environment and resource budget.</p> <p>Parameters:</p> Name Type Description Default <code>env</code> <code>Optional[Env]</code> <p>Environment for variable lookups (Env object)</p> <code>None</code> <code>resource_budget</code> <code>Optional[ResourceBudget]</code> <p>Optional resource budget for tracking gas/memory</p> <code>None</code> <code>host_dispatcher</code> <p>Optional host dispatcher for side effects</p> <code>None</code> Source code in <code>jsl/stack_evaluator.py</code> <pre><code>def __init__(self, env: Optional[Env] = None, resource_budget: Optional[ResourceBudget] = None, host_dispatcher=None):\n    \"\"\"\n    Initialize evaluator with optional environment and resource budget.\n\n    Args:\n        env: Environment for variable lookups (Env object)\n        resource_budget: Optional resource budget for tracking gas/memory\n        host_dispatcher: Optional host dispatcher for side effects\n    \"\"\"\n    self.env = env or Env()\n    self.resource_budget = resource_budget\n    self.host_dispatcher = host_dispatcher\n    self.builtins = self._setup_builtins()\n    self.special_forms = SpecialFormEvaluator(self)\n</code></pre>"},{"location":"api/stack-evaluator/#jsl.stack_evaluator.StackEvaluator.eval","title":"<code>eval(instructions, state=None, env=None)</code>","text":"<p>Evaluate postfix instructions.</p> <p>Parameters:</p> Name Type Description Default <code>instructions</code> <code>List[Any]</code> <p>List of postfix instructions</p> required <code>state</code> <code>Optional[StackState]</code> <p>Optional saved state for resumption</p> <code>None</code> <code>env</code> <code>Optional[Env]</code> <p>Optional environment override (Env object)</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>Result of evaluation</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>On invalid instructions or stack underflow</p> <code>ResourceExhausted</code> <p>When resource limits are exceeded</p> Source code in <code>jsl/stack_evaluator.py</code> <pre><code>def eval(self, instructions: List[Any], state: Optional[StackState] = None, env: Optional[Env] = None) -&gt; Any:\n    \"\"\"\n    Evaluate postfix instructions.\n\n    Args:\n        instructions: List of postfix instructions\n        state: Optional saved state for resumption\n        env: Optional environment override (Env object)\n\n    Returns:\n        Result of evaluation\n\n    Raises:\n        ValueError: On invalid instructions or stack underflow\n        ResourceExhausted: When resource limits are exceeded\n    \"\"\"\n    if state:\n        # Resume from saved state\n        stack = state.stack.copy()\n        pc = state.pc\n        instructions = state.instructions\n        # Restore resource state if available\n        if state.resource_checkpoint and self.resource_budget:\n            self.resource_budget.restore(state.resource_checkpoint)\n        # Restore environment if available\n        if state.env:\n            self.env = state.env\n    else:\n        # Start fresh\n        stack = []\n        pc = 0\n        self._last_tracked_memory = 0  # Reset memory tracking\n\n    # Use provided env or default\n    old_env = None\n    if env is not None:\n        old_env = self.env\n        self.env = env\n\n    while pc &lt; len(instructions):\n        # Check resources before each operation\n        self._check_resources()\n        self._track_memory_for_stack(len(stack))\n\n        instr = instructions[pc]\n\n        # Check for special form marker\n        if instr == Opcode.SPECIAL_FORM:\n            # Handle special form\n            pc += 1\n            if pc &gt;= len(instructions):\n                raise ValueError(\"Special form marker without form\")\n\n            special_expr = instructions[pc]\n            pc += 1\n\n            if isinstance(special_expr, list) and len(special_expr) &gt; 0:\n                form = special_expr[0]\n                args = special_expr[1:]\n\n                # Consume gas for special form\n                self._consume_gas(GasCost.FUNCTION_CALL, f\"special form: {form}\")\n\n                # Evaluate special form\n                result = self.special_forms.eval_special_form(form, args, self.env)\n\n                # Push result to stack\n                stack.append(result)\n            else:\n                raise ValueError(f\"Invalid special form: {special_expr}\")\n\n        # Check if this is an arity (number followed by operator)\n        elif (isinstance(instr, int) and \n            pc + 1 &lt; len(instructions) and \n            isinstance(instructions[pc + 1], str) and\n            (instructions[pc + 1] in self.builtins or \n             instructions[pc + 1] in self.env or\n             instructions[pc + 1] == '__apply__' or\n             instructions[pc + 1] == '__dict__' or\n             instructions[pc + 1] == '__empty_list__')):\n            # This is an arity-operator pair\n            arity = instr\n            operator = instructions[pc + 1]\n            pc += 2  # Skip both arity and operator\n\n            # Check if it's a special __apply__ operator\n            if operator == '__apply__':\n                # Pop arguments from stack\n                if len(stack) &lt; arity + 1:  # +1 for the function itself\n                    raise ValueError(f\"Stack underflow: apply needs function + {arity} args, have {len(stack)}\")\n\n                # Pop arguments\n                args = []\n                for _ in range(arity):\n                    args.insert(0, stack.pop())\n\n                # Pop function/closure\n                func = stack.pop()\n\n                # Apply the function\n                if isinstance(func, Closure):\n                    # It's a Closure - apply it\n                    self._consume_gas(GasCost.FUNCTION_CALL, \"closure application\")\n\n                    # Check arity\n                    if len(args) != len(func.params):\n                        raise ValueError(f\"Arity mismatch: closure expects {len(func.params)} args, got {len(args)}\")\n\n                    # Create new environment extending the closure's captured environment\n                    call_env = func.env.extend(dict(zip(func.params, args)))\n\n                    # Import compiler here to avoid circular dependency\n                    from .compiler import compile_to_postfix\n\n                    # Compile and evaluate body in new environment\n                    body_jpn = compile_to_postfix(func.body)\n                    result = self.eval(body_jpn, env=call_env)\n\n                    # Check result constraints if we have a resource budget\n                    if self.resource_budget:\n                        self.resource_budget.check_result(result)\n\n                    stack.append(result)\n                else:\n                    raise ValueError(f\"Cannot apply non-closure: {type(func).__name__}\")\n\n            elif operator in self.builtins:\n                # Regular builtin operator\n                # Consume gas based on operation type and arity\n                if operator in ['+', '-', '*', '/', '%']:\n                    base_cost = GasCost.ARITHMETIC\n                elif operator in ['=', '!=', '&lt;', '&gt;', '&lt;=', '&gt;=']:\n                    base_cost = GasCost.COMPARISON\n                elif operator in ['not', 'and', 'or']:\n                    base_cost = GasCost.LOGICAL\n                else:\n                    # Built-in function call (list operations, etc.)\n                    base_cost = GasCost.FUNCTION_CALL\n\n                if arity == 2:\n                    self._consume_gas(base_cost, f\"binary {operator}\")\n                else:\n                    self._consume_gas(base_cost + arity, f\"n-ary {operator}\")\n\n                # Pop arguments from stack\n                if len(stack) &lt; arity:\n                    raise ValueError(f\"Stack underflow: {operator} needs {arity} args, have {len(stack)}\")\n\n                args = []\n                for _ in range(arity):\n                    args.insert(0, stack.pop())\n\n                # Apply operator\n                result = self.builtins[operator](args)\n\n                # Check result constraints if we have a resource budget\n                if self.resource_budget:\n                    self.resource_budget.check_result(result)\n\n                stack.append(result)\n\n            else:\n                # Not a builtin - could be a variable that's a function\n                # Pop arguments from stack\n                if len(stack) &lt; arity:\n                    raise ValueError(f\"Stack underflow: {operator} needs {arity} args, have {len(stack)}\")\n\n                args = []\n                for _ in range(arity):\n                    args.insert(0, stack.pop())\n\n                # Look up the function\n                if operator in self.env:\n                    func = self.env.get(operator)\n                    if isinstance(func, Closure):\n                        # It's a closure - apply it\n                        self._consume_gas(GasCost.FUNCTION_CALL, f\"closure call: {operator}\")\n\n                        # Check arity\n                        if len(args) != len(func.params):\n                            raise ValueError(f\"Arity mismatch: {operator} expects {len(func.params)} args, got {len(args)}\")\n\n                        # Create new environment extending the closure's captured environment\n                        call_env = func.env.extend(dict(zip(func.params, args)))\n\n                        # Import compiler here to avoid circular dependency\n                        from .compiler import compile_to_postfix\n\n                        # Compile and evaluate body in new environment\n                        body_jpn = compile_to_postfix(func.body)\n                        result = self.eval(body_jpn, env=call_env)\n\n                        # Check result constraints if we have a resource budget\n                        if self.resource_budget:\n                            self.resource_budget.check_result(result)\n\n                        stack.append(result)\n                    elif callable(func):\n                        # Built-in function stored in env\n                        self._consume_gas(GasCost.FUNCTION_CALL, f\"builtin call: {operator}\")\n                        result = func(*args)\n                        if self.resource_budget:\n                            self.resource_budget.check_result(result)\n                        stack.append(result)\n                    else:\n                        raise ValueError(f\"'{operator}' is not a function\")\n                else:\n                    raise ValueError(f\"Undefined function: {operator}\")\n\n        elif isinstance(instr, (int, float, bool, type(None))):\n            # Push literal number/bool/null\n            self._consume_gas(GasCost.LITERAL, \"literal\")\n            stack.append(instr)\n            pc += 1\n\n        elif isinstance(instr, str):\n            if instr.startswith('@'):\n                # Literal string (@ prefix)\n                self._consume_gas(GasCost.LITERAL, \"string literal\")\n                result = instr[1:]\n                if self.resource_budget:\n                    self.resource_budget.check_string_length(len(result))\n                stack.append(result)\n            else:\n                # Variable lookup\n                self._consume_gas(GasCost.VARIABLE, f\"variable {instr}\")\n                try:\n                    value = self.env.get(instr)\n                    stack.append(value)\n                except:\n                    raise ValueError(f\"Undefined variable: {instr}\")\n            pc += 1\n\n        elif isinstance(instr, list):\n            # Push list literal\n            self._consume_gas(GasCost.LIST_CREATE + len(instr) * GasCost.LIST_PER_ITEM, \"list literal\")\n            if self.resource_budget:\n                self.resource_budget.check_collection_size(len(instr))\n            stack.append(instr)\n            pc += 1\n\n        elif isinstance(instr, dict):\n            # Push dict literal\n            self._consume_gas(GasCost.DICT_CREATE + len(instr) * GasCost.DICT_PER_ITEM, \"dict literal\")\n            if self.resource_budget:\n                self.resource_budget.check_collection_size(len(instr))\n            stack.append(instr)\n            pc += 1\n\n        else:\n            # Other types - push as-is\n            self._consume_gas(GasCost.LITERAL, \"literal\")\n            stack.append(instr)\n            pc += 1\n\n    if len(stack) != 1:\n        raise ValueError(f\"Invalid expression: stack has {len(stack)} items at end\")\n\n    # Restore original env if we overrode it\n    if old_env is not None:\n        self.env = old_env\n\n    return stack[0]\n</code></pre>"},{"location":"api/stack-evaluator/#jsl.stack_evaluator.StackEvaluator.eval_partial","title":"<code>eval_partial(instructions, max_steps, state=None)</code>","text":"<p>Evaluate with step limit for resumption.</p> <p>Parameters:</p> Name Type Description Default <code>instructions</code> <code>List[Any]</code> <p>Postfix instructions</p> required <code>max_steps</code> <code>int</code> <p>Maximum steps to execute</p> required <code>state</code> <code>Optional[StackState]</code> <p>Optional saved state</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[Optional[Any], Optional[StackState]]</code> <p>Tuple of (result, state) - result is None if not complete</p> <p>Raises:</p> Type Description <code>ResourceExhausted</code> <p>When resource limits are exceeded</p> Source code in <code>jsl/stack_evaluator.py</code> <pre><code>def eval_partial(self, instructions: List[Any], max_steps: int, \n                 state: Optional[StackState] = None) -&gt; tuple[Optional[Any], Optional[StackState]]:\n    \"\"\"\n    Evaluate with step limit for resumption.\n\n    Args:\n        instructions: Postfix instructions\n        max_steps: Maximum steps to execute\n        state: Optional saved state\n\n    Returns:\n        Tuple of (result, state) - result is None if not complete\n\n    Raises:\n        ResourceExhausted: When resource limits are exceeded\n    \"\"\"\n    if state:\n        stack = state.stack.copy()\n        pc = state.pc\n        instructions = state.instructions\n        # Restore resource state if available\n        if state.resource_checkpoint and self.resource_budget:\n            self.resource_budget.restore(state.resource_checkpoint)\n        # Restore user environment if available\n        if state.env:\n            # Use the restored environment\n            self.env = state.env\n    else:\n        stack = []\n        pc = 0\n        self._last_tracked_memory = 0  # Reset memory tracking\n\n    steps = 0\n\n    while pc &lt; len(instructions) and steps &lt; max_steps:\n        # Check resources before each operation\n        self._check_resources()\n        self._track_memory_for_stack(len(stack))\n\n        instr = instructions[pc]\n\n        # Check if this is an arity (number followed by operator)\n        if (isinstance(instr, int) and \n            pc + 1 &lt; len(instructions) and \n            isinstance(instructions[pc + 1], str) and\n            (instructions[pc + 1] in self.builtins or\n             instructions[pc + 1] in self.env)):\n            # This is an arity-operator pair\n            arity = instr\n            operator = instructions[pc + 1]\n            pc += 2  # Skip both arity and operator\n\n            # Consume gas based on operation type and arity\n            # Use different gas costs based on operator type\n            if operator in ['+', '-', '*', '/', '%']:\n                base_cost = GasCost.ARITHMETIC\n            elif operator in ['=', '!=', '&lt;', '&gt;', '&lt;=', '&gt;=']:\n                base_cost = GasCost.COMPARISON\n            elif operator in ['not', 'and', 'or']:\n                base_cost = GasCost.LOGICAL\n            else:\n                # Built-in function call (list operations, etc.)\n                base_cost = GasCost.FUNCTION_CALL\n\n            if arity == 2:\n                self._consume_gas(base_cost, f\"binary {operator}\")\n            else:\n                self._consume_gas(base_cost + arity, f\"n-ary {operator}\")\n\n            # Pop arguments from stack\n            if len(stack) &lt; arity:\n                raise ValueError(f\"Stack underflow: {operator} needs {arity} args, have {len(stack)}\")\n\n            args = []\n            for _ in range(arity):\n                args.insert(0, stack.pop())\n\n            # Apply operator\n            if operator in self.builtins:\n                result = self.builtins[operator](args)\n\n                # Check result constraints if we have a resource budget\n                if self.resource_budget:\n                    self.resource_budget.check_result(result)\n\n                stack.append(result)\n            else:\n                # Not a builtin - could be a user-defined function in env\n                if operator in self.env:\n                    func = self.env.get(operator)\n                    if isinstance(func, Closure):\n                        # It's a closure - apply it\n                        self._consume_gas(GasCost.FUNCTION_CALL, f\"closure call: {operator}\")\n\n                        # Check arity\n                        if len(args) != len(func.params):\n                            raise ValueError(f\"Arity mismatch: {operator} expects {len(func.params)} args, got {len(args)}\")\n\n                        # Create new environment extending the closure's captured environment\n                        call_env = func.env.extend(dict(zip(func.params, args)))\n\n                        # Import compiler here to avoid circular dependency\n                        from .compiler import compile_to_postfix\n\n                        # Compile and evaluate body in new environment\n                        body_jpn = compile_to_postfix(func.body)\n                        result = self.eval(body_jpn, env=call_env)\n\n                        # Check result constraints if we have a resource budget\n                        if self.resource_budget:\n                            self.resource_budget.check_result(result)\n\n                        stack.append(result)\n                    elif callable(func):\n                        # Built-in function stored in env\n                        self._consume_gas(GasCost.FUNCTION_CALL, f\"builtin call: {operator}\")\n                        result = func(*args)\n                        if self.resource_budget:\n                            self.resource_budget.check_result(result)\n                        stack.append(result)\n                    else:\n                        raise ValueError(f\"'{operator}' is not a function\")\n                else:\n                    raise ValueError(f\"Undefined function: {operator}\")\n\n        elif isinstance(instr, (int, float, bool, type(None))):\n            # Push literal number/bool/null\n            self._consume_gas(GasCost.LITERAL, \"literal\")\n            stack.append(instr)\n            pc += 1\n\n        elif isinstance(instr, str):\n            if instr.startswith('@'):\n                # Literal string (@ prefix)\n                self._consume_gas(GasCost.LITERAL, \"string literal\")\n                result = instr[1:]\n                if self.resource_budget:\n                    self.resource_budget.check_string_length(len(result))\n                stack.append(result)\n            else:\n                # Variable lookup\n                self._consume_gas(GasCost.VARIABLE, f\"variable {instr}\")\n                try:\n                    value = self.env.get(instr)\n                    stack.append(value)\n                except:\n                    raise ValueError(f\"Undefined variable: {instr}\")\n            pc += 1\n\n        elif isinstance(instr, list):\n            # Push list literal\n            self._consume_gas(GasCost.LIST_CREATE + len(instr) * GasCost.LIST_PER_ITEM, \"list literal\")\n            if self.resource_budget:\n                self.resource_budget.check_collection_size(len(instr))\n            stack.append(instr)\n            pc += 1\n\n        elif isinstance(instr, dict):\n            # Push dict literal\n            self._consume_gas(GasCost.DICT_CREATE + len(instr) * GasCost.DICT_PER_ITEM, \"dict literal\")\n            if self.resource_budget:\n                self.resource_budget.check_collection_size(len(instr))\n            stack.append(instr)\n            pc += 1\n\n        else:\n            # Other types - push as-is\n            self._consume_gas(GasCost.LITERAL, \"literal\")\n            stack.append(instr)\n            pc += 1\n\n        steps += 1\n\n    if pc &gt;= len(instructions) and len(stack) == 1:\n        # Complete\n        return stack[0], None\n    else:\n        # Incomplete - save state with resource checkpoint\n        resource_checkpoint = None\n        if self.resource_budget:\n            resource_checkpoint = self.resource_budget.checkpoint()\n\n        state = StackState(\n            stack=stack, \n            pc=pc, \n            instructions=instructions,\n            resource_checkpoint=resource_checkpoint,\n            env=self.env\n        )\n        return None, state\n</code></pre>"},{"location":"api/stack-evaluator/#stackstate","title":"<code>StackState</code>","text":"<p>Represents the state of the stack machine for resumption:</p>"},{"location":"api/stack-evaluator/#jsl.stack_evaluator.StackState","title":"<code>jsl.stack_evaluator.StackState(stack, pc, instructions, resource_checkpoint=None, env=None)</code>  <code>dataclass</code>","text":"<p>State of the stack evaluator, can be serialized for resumption.</p>"},{"location":"api/stack-evaluator/#jsl.stack_evaluator.StackState.from_dict","title":"<code>from_dict(data, prelude_env=None)</code>  <code>classmethod</code>","text":"<p>Restore from dictionary.</p> Source code in <code>jsl/stack_evaluator.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict, prelude_env: Optional[Env] = None) -&gt; 'StackState':\n    \"\"\"Restore from dictionary.\"\"\"\n    return cls(\n        stack=from_json(data['stack'], prelude_env),\n        pc=data['pc'],\n        instructions=data['instructions'],\n        resource_checkpoint=data.get('resource_checkpoint'),\n        env=from_json(data['env'], prelude_env) if data.get('env') else prelude_env\n    )\n</code></pre>"},{"location":"api/stack-evaluator/#jsl.stack_evaluator.StackState.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to serializable dictionary.</p> Source code in <code>jsl/stack_evaluator.py</code> <pre><code>def to_dict(self) -&gt; Dict:\n    \"\"\"Convert to serializable dictionary.\"\"\"\n    return {\n        'stack': to_json(self.stack),\n        'pc': self.pc,\n        'instructions': self.instructions,\n        'resource_checkpoint': self.resource_checkpoint,\n        'env': to_json(self.env) if self.env else None\n    }\n</code></pre>"},{"location":"api/stack-evaluator/#usage-examples","title":"Usage Examples","text":""},{"location":"api/stack-evaluator/#basic-evaluation","title":"Basic Evaluation","text":"<pre><code>from jsl.stack_evaluator import StackEvaluator\nfrom jsl.compiler import compile_to_postfix\n\n# Create evaluator\nevaluator = StackEvaluator()\n\n# Compile S-expression to JPN\nexpr = [\"+\", 1, 2, 3]\njpn = compile_to_postfix(expr)  # [1, 2, 3, 3, \"+\"]\n\n# Evaluate\nresult = evaluator.eval(jpn)\nprint(result)  # Output: 6\n</code></pre>"},{"location":"api/stack-evaluator/#resumable-execution","title":"Resumable Execution","text":"<pre><code>from jsl.stack_evaluator import StackEvaluator\nfrom jsl.compiler import compile_to_postfix\n\nevaluator = StackEvaluator()\n\n# Compile a complex expression\nexpr = [\"*\", [\"+\", 10, 20], [\"-\", 100, 50]]\njpn = compile_to_postfix(expr)\n\n# Execute with step limit\nresult, state = evaluator.eval_partial(jpn, max_steps=3)\n\nif state:  # Execution paused\n    print(f\"Paused at PC: {state.pc}\")\n    print(f\"Stack: {state.stack}\")\n\n    # Resume execution\n    final_result, _ = evaluator.eval_partial(jpn, state=state)\n    print(f\"Result: {final_result}\")  # Output: 1500\n</code></pre>"},{"location":"api/stack-evaluator/#working-with-closures","title":"Working with Closures","text":"<pre><code>from jsl.stack_evaluator import StackEvaluator\nfrom jsl.compiler import compile_to_postfix\n\nevaluator = StackEvaluator()\n\n# Define a function\nprogram = [\n    \"do\",\n    [\"def\", \"square\", [\"lambda\", [\"x\"], [\"*\", \"x\", \"x\"]]],\n    [\"square\", 5]\n]\n\njpn = compile_to_postfix(program)\nresult = evaluator.eval(jpn)\nprint(result)  # Output: 25\n\n# The closure is stored as a dict\nclosure = evaluator.env.get(\"square\")\nprint(closure[\"type\"])    # \"closure\"\nprint(closure[\"params\"])  # [\"x\"]\nprint(closure[\"body\"])    # [\"*\", \"x\", \"x\"]\n</code></pre>"},{"location":"api/stack-evaluator/#jpn-instruction-set","title":"JPN Instruction Set","text":"<p>The stack evaluator processes these instruction types:</p>"},{"location":"api/stack-evaluator/#values","title":"Values","text":"<ul> <li>Literals: Numbers, strings, booleans, null, lists, dicts push themselves</li> <li>Variables: String identifiers trigger environment lookup</li> </ul>"},{"location":"api/stack-evaluator/#operators","title":"Operators","text":"<ul> <li>N-ary operators: Preceded by arity count (e.g., <code>3, \"+\"</code> for 3-argument addition)</li> <li>Built-in functions: Called like operators with arity</li> </ul>"},{"location":"api/stack-evaluator/#special-forms","title":"Special Forms","text":"<ul> <li><code>Opcode.SPECIAL_FORM</code>: Marks special form instructions</li> <li><code>Opcode.JUMP</code>: Conditional/unconditional jumps</li> <li><code>Opcode.JUMP_IF_FALSE</code>: Jump if top of stack is false</li> <li><code>Opcode.LAMBDA</code>: Create closure from body and params</li> </ul>"},{"location":"api/stack-evaluator/#stack-machine-architecture","title":"Stack Machine Architecture","text":""},{"location":"api/stack-evaluator/#execution-model","title":"Execution Model","text":"<ol> <li>Program Counter (PC): Points to current instruction</li> <li>Operand Stack: Holds intermediate values</li> <li>Environment: Variable bindings (dict-based)</li> <li>Call Stack: For function calls (managed internally)</li> </ol>"},{"location":"api/stack-evaluator/#instruction-processing","title":"Instruction Processing","text":"<pre><code># Simplified execution loop\nwhile pc &lt; len(program):\n    instruction = program[pc]\n\n    if isinstance(instruction, (int, float, str, bool, type(None))):\n        stack.append(instruction)\n    elif instruction in operators:\n        arity = program[pc - 1]\n        args = [stack.pop() for _ in range(arity)]\n        result = operators[instruction](*reversed(args))\n        stack.append(result)\n\n    pc += 1\n</code></pre>"},{"location":"api/stack-evaluator/#differences-from-recursive-evaluator","title":"Differences from Recursive Evaluator","text":"Feature Recursive Evaluator Stack Evaluator Execution Tree walking Linear instruction stream Closures <code>Closure</code> objects Dict representations Resumption Difficult Natural with <code>StackState</code> Performance Good for small programs Better for large programs Debugging Natural call stack Requires PC tracking"},{"location":"api/stack-evaluator/#integration-with-jslrunner","title":"Integration with JSLRunner","text":"<p>The <code>JSLRunner</code> can use either evaluator:</p> <pre><code>from jsl.runner import JSLRunner\n\n# Use stack evaluator (default)\nrunner_stack = JSLRunner(use_recursive_evaluator=False)\n\n# Use recursive evaluator\nrunner_recursive = JSLRunner(use_recursive_evaluator=True)\n\n# Both produce identical results\nresult1 = runner_stack.execute([\"+\", 1, 2, 3])\nresult2 = runner_recursive.execute([\"+\", 1, 2, 3])\nassert result1 == result2  # True\n</code></pre>"},{"location":"architecture/abstract-machine/","title":"JSL Abstract Machine Specification","text":""},{"location":"architecture/abstract-machine/#1-overview","title":"1. Overview","text":"<p>The JSL Abstract Machine is a stack-based virtual machine designed to execute JSL postfix bytecode. It provides a simple, resumable, and network-friendly execution model.</p>"},{"location":"architecture/abstract-machine/#2-machine-architecture","title":"2. Machine Architecture","text":""},{"location":"architecture/abstract-machine/#21-components","title":"2.1 Components","text":"<p>The abstract machine consists of:</p> <pre><code>Machine M = \u27e8S, E, C, D, R\u27e9\n</code></pre> <p>Where: - S (Stack): Value stack for operands and results - E (Environment): Variable bindings - C (Code): Array of instructions (postfix) - D (Dump): Saved states for function calls (future) - R (Resources): Resource budget and consumption</p>"},{"location":"architecture/abstract-machine/#22-value-domain","title":"2.2 Value Domain","text":"<pre><code>Value v ::= n           (number)\n         | b           (boolean)\n         | null        (null)\n         | s           (string)\n         | [v\u2081,...,v\u2099] (list)\n         | {k:v,...}   (dictionary)\n         | \u27e8\u03bb,p,b,E\u27e9   (closure)\n</code></pre>"},{"location":"architecture/abstract-machine/#23-instruction-set","title":"2.3 Instruction Set","text":"<pre><code>Instruction i ::= v              (push value)\n                | x              (push variable)\n                | op             (binary operator)\n                | (op, n)        (n-ary operator)\n                | MARK           (stack marker)\n                | CALL n         (function call)\n                | RET            (return)\n</code></pre>"},{"location":"architecture/abstract-machine/#3-operational-semantics","title":"3. Operational Semantics","text":""},{"location":"architecture/abstract-machine/#31-basic-transitions","title":"3.1 Basic Transitions","text":""},{"location":"architecture/abstract-machine/#value-push","title":"Value Push","text":"<p><pre><code>    v is a literal value\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u27e8S, E, v\u00b7C, D, R\u27e9 \u2192 \u27e8v\u00b7S, E, C, D, R'\u27e9\n</code></pre> Where R' = R with gas decremented by 1.</p>"},{"location":"architecture/abstract-machine/#variable-lookup","title":"Variable Lookup","text":"<p><pre><code>    x \u2208 dom(E)    E(x) = v\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u27e8S, E, x\u00b7C, D, R\u27e9 \u2192 \u27e8v\u00b7S, E, C, D, R'\u27e9\n</code></pre> Where R' = R with gas decremented by 2.</p>"},{"location":"architecture/abstract-machine/#binary-operation","title":"Binary Operation","text":"<p><pre><code>    \u2295 is a binary operator\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u27e8v\u2082\u00b7v\u2081\u00b7S, E, \u2295\u00b7C, D, R\u27e9 \u2192 \u27e8(v\u2081\u2295v\u2082)\u00b7S, E, C, D, R'\u27e9\n</code></pre> Where R' = R with gas decremented by 3.</p>"},{"location":"architecture/abstract-machine/#n-ary-operation","title":"N-ary Operation","text":"<p><pre><code>    \u2295 is an n-ary operator    |S| \u2265 n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u27e8v\u2099\u00b7...\u00b7v\u2081\u00b7S, E, (\u2295,n)\u00b7C, D, R\u27e9 \u2192 \u27e8\u2295(v\u2081,...,v\u2099)\u00b7S, E, C, D, R'\u27e9\n</code></pre> Where R' = R with gas decremented by (3 + n).</p>"},{"location":"architecture/abstract-machine/#32-control-flow-future-extension","title":"3.2 Control Flow (Future Extension)","text":""},{"location":"architecture/abstract-machine/#function-call","title":"Function Call","text":"<pre><code>    v = \u27e8\u03bb,p\u2081...p\u2099,b,E'\u27e9    |S| \u2265 n\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u27e8v\u2099\u00b7...\u00b7v\u2081\u00b7v\u00b7S, E, CALL n\u00b7C, D, R\u27e9 \u2192 \n\u27e8[], E'[p\u2081\u21a6v\u2081,...,p\u2099\u21a6v\u2099], b, (S,E,C)\u00b7D, R'\u27e9\n</code></pre>"},{"location":"architecture/abstract-machine/#return","title":"Return","text":"<pre><code>    D = (S',E',C')\u00b7D'\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u27e8v\u00b7S, E, RET\u00b7C, D, R\u27e9 \u2192 \u27e8v\u00b7S', E', C', D', R\u27e9\n</code></pre>"},{"location":"architecture/abstract-machine/#33-error-states","title":"3.3 Error States","text":""},{"location":"architecture/abstract-machine/#stack-underflow","title":"Stack Underflow","text":"<pre><code>    |S| &lt; n    (\u2295,n) requires n arguments\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u27e8S, E, (\u2295,n)\u00b7C, D, R\u27e9 \u2192 ERROR: Stack underflow\n</code></pre>"},{"location":"architecture/abstract-machine/#undefined-variable","title":"Undefined Variable","text":"<pre><code>    x \u2209 dom(E)\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u27e8S, E, x\u00b7C, D, R\u27e9 \u2192 ERROR: Undefined variable x\n</code></pre>"},{"location":"architecture/abstract-machine/#resource-exhaustion","title":"Resource Exhaustion","text":"<pre><code>    R.gas \u2264 0\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u27e8S, E, C, D, R\u27e9 \u2192 PAUSE: \u27e8S, E, C, D, R\u27e9\n</code></pre>"},{"location":"architecture/abstract-machine/#4-execution-algorithm","title":"4. Execution Algorithm","text":""},{"location":"architecture/abstract-machine/#41-basic-execution-loop","title":"4.1 Basic Execution Loop","text":"<pre><code>def execute(code, env, resources):\n    S = []  # Stack\n    C = code  # Code pointer\n    E = env  # Environment\n    R = resources  # Resources\n\n    while C:\n        if R and R.gas &lt;= 0:\n            return PAUSE(S, E, C, R)\n\n        instr = C[0]\n        C = C[1:]\n\n        if is_value(instr):\n            S = [instr] + S\n            R.gas -= 1\n\n        elif is_variable(instr):\n            if instr in E:\n                S = [E[instr]] + S\n                R.gas -= 2\n            else:\n                return ERROR(f\"Undefined: {instr}\")\n\n        elif is_binary_op(instr):\n            if len(S) &lt; 2:\n                return ERROR(\"Stack underflow\")\n            v2, v1 = S[0], S[1]\n            S = [apply_binary(instr, v1, v2)] + S[2:]\n            R.gas -= 3\n\n        elif is_nary_op(instr):\n            op, n = instr\n            if len(S) &lt; n:\n                return ERROR(\"Stack underflow\")\n            args = S[:n]\n            S = [apply_nary(op, args)] + S[n:]\n            R.gas -= (3 + n)\n\n    if len(S) == 1:\n        return S[0]\n    else:\n        return ERROR(f\"Invalid final stack: {S}\")\n</code></pre>"},{"location":"architecture/abstract-machine/#42-resumable-execution","title":"4.2 Resumable Execution","text":"<pre><code>def execute_resumable(state_or_code, env=None):\n    if is_saved_state(state_or_code):\n        S, E, C, R = restore_state(state_or_code)\n    else:\n        S = []\n        E = env or {}\n        C = state_or_code\n        R = default_resources()\n\n    result = execute_step(S, E, C, R)\n\n    if is_pause(result):\n        return None, save_state(result)\n    else:\n        return result, None\n</code></pre>"},{"location":"architecture/abstract-machine/#5-resource-model","title":"5. Resource Model","text":""},{"location":"architecture/abstract-machine/#51-gas-costs","title":"5.1 Gas Costs","text":"Operation Gas Cost Rationale Push literal 1 Minimal cost Variable lookup 2 Environment search Binary operation 3 Computation N-ary operation 3+n Scales with arguments Function call 10 Context switch List creation 1+n Allocation Dictionary creation 1+2n Key-value pairs"},{"location":"architecture/abstract-machine/#52-memory-limits","title":"5.2 Memory Limits","text":"<pre><code>MemoryLimit = {\n    max_stack_depth: 10000,\n    max_collection_size: 1000000,\n    max_string_length: 1000000,\n    max_env_depth: 1000\n}\n</code></pre>"},{"location":"architecture/abstract-machine/#53-time-limits","title":"5.3 Time Limits","text":"<pre><code>def check_time_limit(start_time, limit):\n    if time.now() - start_time &gt; limit:\n        raise TimeExhausted()\n</code></pre>"},{"location":"architecture/abstract-machine/#6-optimization-opportunities","title":"6. Optimization Opportunities","text":""},{"location":"architecture/abstract-machine/#61-instruction-fusion","title":"6.1 Instruction Fusion","text":"<p>Combine common patterns: <pre><code>[2, 3, +] \u2192 [PUSH_ADD, 2, 3]\n[x, y, *] \u2192 [MUL_VARS, x, y]\n</code></pre></p>"},{"location":"architecture/abstract-machine/#62-constant-folding","title":"6.2 Constant Folding","text":"<p>Pre-compute constant expressions: <pre><code>[2, 3, +, 4, *] \u2192 [20]  ; Computed at compile time\n</code></pre></p>"},{"location":"architecture/abstract-machine/#63-stack-caching","title":"6.3 Stack Caching","text":"<p>Keep top stack values in registers: <pre><code>TOS (Top of Stack) \u2192 Register 0\nTOS-1 \u2192 Register 1\n</code></pre></p>"},{"location":"architecture/abstract-machine/#64-environment-optimization","title":"6.4 Environment Optimization","text":"<p>Cache frequently accessed variables: <pre><code>E_cache = LRU_cache(size=32)\n</code></pre></p>"},{"location":"architecture/abstract-machine/#7-implementation-strategies","title":"7. Implementation Strategies","text":""},{"location":"architecture/abstract-machine/#71-direct-threading","title":"7.1 Direct Threading","text":"<pre><code>typedef void (*instruction_fn)(Machine*);\n\ninstruction_fn dispatch_table[] = {\n    [OP_PUSH] = do_push,\n    [OP_ADD] = do_add,\n    [OP_MUL] = do_mul,\n    // ...\n};\n\nvoid execute(Machine* m) {\n    while (m-&gt;pc &lt; m-&gt;code_len) {\n        dispatch_table[m-&gt;code[m-&gt;pc++]](m);\n    }\n}\n</code></pre>"},{"location":"architecture/abstract-machine/#72-computed-goto-gcc","title":"7.2 Computed Goto (GCC)","text":"<pre><code>void* dispatch_table[] = {\n    &amp;&amp;do_push,\n    &amp;&amp;do_add,\n    &amp;&amp;do_mul,\n    // ...\n};\n\n#define DISPATCH() goto *dispatch_table[code[pc++]]\n\nexecute:\n    DISPATCH();\n\ndo_push:\n    stack[++sp] = code[pc++];\n    DISPATCH();\n\ndo_add:\n    sp--;\n    stack[sp] += stack[sp+1];\n    DISPATCH();\n</code></pre>"},{"location":"architecture/abstract-machine/#73-jit-compilation","title":"7.3 JIT Compilation","text":"<pre><code>def jit_compile(postfix):\n    \"\"\"Compile postfix to native code.\"\"\"\n    native_code = []\n\n    for instr in postfix:\n        if isinstance(instr, int):\n            native_code.append(f\"PUSH_IMM {instr}\")\n        elif instr == '+':\n            native_code.append(\"POP_ADD\")\n        # ...\n\n    return assemble(native_code)\n</code></pre>"},{"location":"architecture/abstract-machine/#8-debugging-support","title":"8. Debugging Support","text":""},{"location":"architecture/abstract-machine/#81-stack-trace","title":"8.1 Stack Trace","text":"<pre><code>Stack trace at pc=42:\n  [0] main: [+, x, [*, y, 2]]\n  [1] *: [*, y, 2]\n  Stack: [10, 3, 2]\n  Next: *\n</code></pre>"},{"location":"architecture/abstract-machine/#82-breakpoints","title":"8.2 Breakpoints","text":"<pre><code>breakpoints = {15, 27, 42}  # Instruction addresses\n\ndef execute_debug(code, env):\n    for pc, instr in enumerate(code):\n        if pc in breakpoints:\n            debug_prompt(stack, env, code, pc)\n        execute_instruction(instr)\n</code></pre>"},{"location":"architecture/abstract-machine/#83-state-inspection","title":"8.3 State Inspection","text":"<pre><code>def inspect_state(machine):\n    return {\n        'stack': machine.stack,\n        'env': machine.env,\n        'pc': machine.pc,\n        'gas_used': machine.initial_gas - machine.gas,\n        'next_instruction': machine.code[machine.pc]\n    }\n</code></pre>"},{"location":"architecture/abstract-machine/#9-comparison-with-other-vms","title":"9. Comparison with Other VMs","text":"Feature JSL VM JVM Python VM Lua VM Model Stack Stack Stack Register Bytecode JSON Binary Binary Binary Resumable Yes No No Yes (coroutines) Serializable Yes No Partial No Types Dynamic Static Dynamic Dynamic GC Host Yes Yes Yes"},{"location":"architecture/abstract-machine/#10-performance-characteristics","title":"10. Performance Characteristics","text":""},{"location":"architecture/abstract-machine/#101-time-complexity","title":"10.1 Time Complexity","text":"Operation Complexity Push O(1) Pop O(1) Binary op O(1) Variable lookup O(log n) average List creation O(n) Function call O(1)"},{"location":"architecture/abstract-machine/#102-space-complexity","title":"10.2 Space Complexity","text":"Structure Complexity Stack O(n) expressions Environment O(m) variables Code O(k) instructions Total O(n + m + k)"},{"location":"architecture/abstract-machine/#11-security-considerations","title":"11. Security Considerations","text":""},{"location":"architecture/abstract-machine/#111-resource-isolation","title":"11.1 Resource Isolation","text":"<p>Each execution has isolated resources: <pre><code>resources = ResourceBudget(\n    gas=10000,\n    memory=1_000_000,\n    time_limit=1.0\n)\n</code></pre></p>"},{"location":"architecture/abstract-machine/#112-capability-security","title":"11.2 Capability Security","text":"<p>No ambient authority - all effects through capabilities: <pre><code>capabilities = {\n    'file_read': FileReadCapability('/allowed/path'),\n    'network': NetworkCapability(['allowed.host'])\n}\n</code></pre></p>"},{"location":"architecture/abstract-machine/#113-sandboxing","title":"11.3 Sandboxing","text":"<pre><code>def sandbox_execute(untrusted_code):\n    sandbox = Sandbox(\n        max_stack=1000,\n        max_time=1.0,\n        no_host_access=True\n    )\n    return sandbox.execute(untrusted_code)\n</code></pre>"},{"location":"architecture/abstract-machine/#12-example-execution-traces","title":"12. Example Execution Traces","text":""},{"location":"architecture/abstract-machine/#121-simple-arithmetic","title":"12.1 Simple Arithmetic","text":"<p>Code: <code>[2, 3, +, 4, *]</code></p> <pre><code>Step | Stack | Code        | Action\n-----|-------|-------------|--------\n0    | []    | 2 3 + 4 *   | Initial\n1    | [2]   | 3 + 4 *     | Push 2\n2    | [2,3] | + 4 *       | Push 3\n3    | [5]   | 4 *         | Add\n4    | [5,4] | *           | Push 4\n5    | [20]  | \u03b5           | Multiply\n</code></pre>"},{"location":"architecture/abstract-machine/#122-with-variables","title":"12.2 With Variables","text":"<p>Code: <code>[x, y, +]</code> with env <code>{x: 10, y: 20}</code></p> <pre><code>Step | Stack    | Code  | Action\n-----|----------|-------|----------\n0    | []       | x y + | Initial\n1    | [10]     | y +   | Lookup x\n2    | [10,20]  | +     | Lookup y\n3    | [30]     | \u03b5     | Add\n</code></pre>"},{"location":"architecture/abstract-machine/#13-future-directions","title":"13. Future Directions","text":"<ol> <li>Tail Call Optimization: Reuse stack frames</li> <li>Lazy Evaluation: Thunks and promises</li> <li>Parallel Execution: Multiple stacks</li> <li>Native Code Generation: LLVM backend</li> <li>Persistent Data Structures: Immutable collections</li> </ol> <p>This specification defines the JSL Abstract Machine v1.0, providing a formal foundation for JSL execution.</p>"},{"location":"architecture/distributed/","title":"Distributed Computing with JSL","text":""},{"location":"architecture/distributed/#overview","title":"Overview","text":"<p>JSL's core design\u2014being homoiconic and having a robust, verifiable serialization model\u2014makes it an ideal language for building distributed systems. Because both code and state can be safely transmitted over the network, complex distributed patterns can be expressed with the same clarity as local computations.</p> <p>An Architectural Showcase: The following examples are an architectural showcase of what is possible. They are not a standard library reference. These patterns assume the host environment provides a rich set of networking primitives (e.g., <code>remote/execute</code>, <code>remote/call</code>). The purpose is to demonstrate how JSL can be used as the foundation for a powerful distributed computing framework.</p>"},{"location":"architecture/distributed/#core-patterns","title":"Core Patterns","text":""},{"location":"architecture/distributed/#1-remote-execution","title":"1. Remote Execution","text":"<p>The most fundamental pattern is executing a function on a remote node. JSL's serializable closures make this trivial. The closure packages its code and its environment, which can be sent to a remote host for evaluation.</p> <p>The host provides <code>remote/execute</code> which takes a node, a function, and arguments. <pre><code>[\"host\", \"remote/execute\", \"node-2\", \n  [\"lambda\", [\"x\"], [\"*\", \"x\", \"x\"]],\n  5]\n</code></pre></p>"},{"location":"architecture/distributed/#2-master-worker-pattern","title":"2. Master-Worker Pattern","text":"<p>A coordinator node can partition a workload and distribute it among a set of worker nodes. This pattern highlights how JSL's functional nature (<code>map</code>, <code>zip</code>) simplifies parallel processing logic. The worker function itself is passed as an argument, making this a flexible, higher-order function.</p> <pre><code>[\"def\", \"distribute_work\",\n  [\"lambda\", [\"work_items\", \"workers\", \"work_fn\"],\n    [\"do\",\n      [\"def\", \"chunks\", [\"partition\", \"work_items\", [\"length\", \"workers\"]]],\n      [\"def\", \"tasks\", [\"zip\", \"workers\", \"chunks\"]],\n      [\"map\", \n        [\"lambda\", [\"task\"],\n          [\"host\", \"remote/execute\", \n            [\"first\", \"task\"],\n            \"work_fn\",\n            [\"second\", \"task\"]]],\n        \"tasks\"]]]]\n</code></pre>"},{"location":"architecture/distributed/#3-fault-tolerance-via-retries","title":"3. Fault Tolerance via Retries","text":"<p>Handling network failures is critical. Because JSL code is data, we can easily write higher-order functions that wrap any remote call with a retry mechanism.</p> <p>This example defines a recursive inner function, <code>try_call</code>, to handle the retry loop. The <code>try</code> special form is used to catch failures, and the error handler recursively calls itself with one fewer attempt. <pre><code>[\"def\", \"reliable_remote_call\",\n  [\"lambda\", [\"node\", \"function\", \"args\", \"max_retries\"],\n    [\"do\",\n      [\"def\", \"try_call\",\n        [\"lambda\", [\"attempts_left\"],\n          [\"if\", [\"=\", \"attempts_left\", 0],\n            [\"error\", \"Max retries exceeded\"],\n            [\"try\",\n              [\"host\", \"remote/call\", \"node\", \"function\", \"args\"],\n              [\"lambda\", [\"error\"],\n                [\"do\",\n                  [\"host\", \"log/warn\", [\"@\", \"Retry attempt \", [\"-\", [\"+\", \"max_retries\", 1], \"attempts_left\"], \" failed. Retrying...\"]],\n                  [\"try_call\", [\"-\", \"attempts_left\", 1]]\n                ]\n              ]\n            ]\n          ]\n        ]\n      ],\n      [\"try_call\", \"max_retries\"]\n    ]\n  ]\n]\n</code></pre></p>"},{"location":"architecture/distributed/#advanced-patterns","title":"Advanced Patterns","text":"<p>JSL's composability allows these simple building blocks to be combined into sophisticated distributed algorithms.</p>"},{"location":"architecture/distributed/#mapreduce-implementation","title":"MapReduce Implementation","text":"<p>This example shows how a full MapReduce job can be expressed by composing the <code>distribute_work</code> function defined earlier.</p> <p>The process is broken down into three phases: 1.  MAP PHASE: Distribute the map function across the map nodes. 2.  SHUFFLE PHASE: Group the intermediate results by key. 3.  REDUCE PHASE: Distribute the reduce function across the reduce nodes to produce the final result. <pre><code>[\"def\", \"mapreduce\",\n  [\"lambda\", [\"map_fn\", \"reduce_fn\", \"data\", \"map_nodes\", \"reduce_nodes\"],\n    [\"do\",\n      [\"def\", \"map_results\", [\"distribute_work\", \"data\", \"map_nodes\", \"map_fn\"]],\n      [\"def\", \"grouped\", [\"group_by\", \"first\", [\"flatten\", \"map_results\"]]],\n      [\"def\", \"reduce_tasks\", [\"items\", \"grouped\"]],\n      [\"distribute_work\", \"reduce_tasks\", \"reduce_nodes\", \"reduce_fn\"]\n    ]\n  ]\n]\n</code></pre></p> <p>These examples illustrate that JSL provides the ideal substrate for building resilient, scalable systems while maintaining the simplicity and clarity of the language's core design principles.</p>"},{"location":"architecture/evaluator-parity/","title":"Evaluator Parity: Dual Implementation Architecture","text":"<p>This document describes JSL's dual evaluator architecture and the comprehensive work done to ensure both evaluators have identical semantics.</p>"},{"location":"architecture/evaluator-parity/#overview","title":"Overview","text":"<p>JSL implements two evaluators with different execution strategies but identical language semantics:</p> <ol> <li>Recursive Evaluator - Traditional tree-walking interpreter</li> <li>Stack Evaluator - Compiles to postfix notation for stack-based execution</li> </ol>"},{"location":"architecture/evaluator-parity/#why-two-evaluators","title":"Why Two Evaluators?","text":""},{"location":"architecture/evaluator-parity/#recursive-evaluator","title":"Recursive Evaluator","text":"<ul> <li>Purpose: Reference implementation and development</li> <li>Benefits:</li> <li>Simple, traditional tree-walking approach</li> <li>Natural recursion for nested expressions  </li> <li>Easy to understand and debug</li> <li>Good for development and testing</li> <li>Implementation: Uses <code>Closure</code> class objects</li> </ul>"},{"location":"architecture/evaluator-parity/#stack-evaluator","title":"Stack Evaluator","text":"<ul> <li>Purpose: Production implementation with advanced features</li> <li>Benefits:</li> <li>Compiles to JPN (JSL Postfix Notation)</li> <li>Resumable execution (can pause/restore state)</li> <li>Network-native (all state is JSON-serializable)</li> <li>No call stack depth limitations</li> <li>Better for distributed systems</li> <li>Implementation: Uses dict closures (JSON-serializable)</li> </ul>"},{"location":"architecture/evaluator-parity/#parity-achievement","title":"Parity Achievement","text":""},{"location":"architecture/evaluator-parity/#test-coverage","title":"Test Coverage","text":"<ul> <li>168 unified tests - Each test runs against both evaluators</li> <li>100% pass rate - Identical inputs produce identical outputs</li> <li>30 runner integration tests - All pass with both evaluators</li> </ul>"},{"location":"architecture/evaluator-parity/#language-features","title":"Language Features","text":""},{"location":"architecture/evaluator-parity/#core-operations","title":"Core Operations","text":"<ul> <li>\u2705 Arithmetic: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> with proper identity elements</li> <li>\u2705 Comparison: <code>=</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> </li> <li>\u2705 Logical: <code>and</code>, <code>or</code>, <code>not</code> with proper identity elements</li> <li>\u2705 Lists: <code>list</code>, <code>cons</code>, <code>first</code>, <code>rest</code>, <code>length</code>, <code>append</code></li> </ul>"},{"location":"architecture/evaluator-parity/#special-forms","title":"Special Forms","text":"<ul> <li>\u2705 <code>if</code> - Conditional evaluation</li> <li>\u2705 <code>let</code> - Local bindings (standardized format: <code>[\"let\", [[bindings]], body]</code>)</li> <li>\u2705 <code>lambda</code> - Function creation</li> <li>\u2705 <code>def</code> - Global definitions</li> <li>\u2705 <code>do</code> - Sequential evaluation</li> <li>\u2705 <code>quote</code> / <code>@</code> - Prevent evaluation</li> <li>\u2705 <code>try</code> - Error handling</li> <li>\u2705 <code>host</code> - Side effects</li> </ul>"},{"location":"architecture/evaluator-parity/#advanced-features","title":"Advanced Features","text":"<ul> <li>\u2705 Function application: <code>[[\"lambda\", [\"x\"], body], arg]</code></li> <li>\u2705 Recursive functions (fibonacci, factorial, etc.)</li> <li>\u2705 Higher-order functions (map, filter, reduce)</li> <li>\u2705 Closures with proper lexical scoping</li> <li>\u2705 Error handling with try/catch</li> </ul>"},{"location":"architecture/evaluator-parity/#implementation-details","title":"Implementation Details","text":""},{"location":"architecture/evaluator-parity/#function-application-design","title":"Function Application Design","text":"<p>When the first element of a list is itself an expression (not just a string), it's evaluated to get a function:</p> <pre><code>[[\"lambda\", [\"x\"], [\"*\", \"x\", 2]], 5]\n</code></pre> <p>The compiler detects this pattern and generates an <code>__apply__</code> operation: <pre><code>[5, &lt;lambda-closure&gt;, 1, \"__apply__\"]\n</code></pre></p>"},{"location":"architecture/evaluator-parity/#closure-representations","title":"Closure Representations","text":"<p>Recursive Evaluator: <pre><code>Closure(params=[\"x\"], body=[\"*\", \"x\", 2], env=Env(...))\n</code></pre></p> <p>Stack Evaluator: <pre><code>{\n  \"type\": \"closure\",\n  \"params\": [\"x\"],\n  \"body\": [\"*\", \"x\", 2],\n  \"env\": {...}\n}\n</code></pre></p>"},{"location":"architecture/evaluator-parity/#identity-elements","title":"Identity Elements","text":"<p>Operations return mathematically correct identity elements for 0-arity calls:</p> Operation 0-arity Result Rationale <code>(+)</code> 0 Addition identity <code>(*)</code> 1 Multiplication identity <code>(-)</code> 0 Consistent with addition <code>(and)</code> true All of empty set <code>(or)</code> false Any of empty set <code>(min)</code> +\u221e Upper bound <code>(max)</code> -\u221e Lower bound"},{"location":"architecture/evaluator-parity/#n-ary-subtraction","title":"N-ary Subtraction","text":"<p>Subtraction follows left-associative semantics: - <code>(-)</code> \u2192 0 (identity) - <code>(- x)</code> \u2192 -x (negation) - <code>(- a b c)</code> \u2192 ((a - b) - c) (left-associative)</p>"},{"location":"architecture/evaluator-parity/#testing-strategy","title":"Testing Strategy","text":""},{"location":"architecture/evaluator-parity/#unified-test-suite","title":"Unified Test Suite","text":"<p>The <code>tests/test_unified_evaluators.py</code> file contains comprehensive tests that run against both evaluators:</p> <pre><code>@pytest.fixture(params=[\n    RecursiveEvaluatorAdapter(),\n    StackEvaluatorAdapter(),\n    RunnerAdapter(use_recursive=True),\n    RunnerAdapter(use_recursive=False),\n])\ndef evaluator(request):\n    return request.param\n</code></pre> <p>Each test is automatically run 4 times to ensure consistency across all execution paths.</p>"},{"location":"architecture/evaluator-parity/#test-categories","title":"Test Categories","text":"<ol> <li>Literals - Numbers, booleans, null, strings</li> <li>Arithmetic - All operations with various arities</li> <li>Comparison - All comparison operators</li> <li>Logical - Boolean operations</li> <li>Lists - Creation and manipulation</li> <li>Special Forms - All language constructs</li> <li>Variables - Definition and lookup</li> <li>Complex Expressions - Recursive functions, nested expressions</li> <li>Edge Cases - Empty expressions, deeply nested structures</li> </ol>"},{"location":"architecture/evaluator-parity/#runner-integration","title":"Runner Integration","text":"<p>The <code>JSLRunner</code> class provides a unified interface that works seamlessly with either evaluator:</p> <pre><code># Use recursive evaluator\nrunner = JSLRunner(use_recursive_evaluator=True)\n\n# Use stack evaluator (default)\nrunner = JSLRunner(use_recursive_evaluator=False)\n\n# Both produce identical results\nresult = runner.execute([\"fibonacci\", 10])\n</code></pre>"},{"location":"architecture/evaluator-parity/#environment-management","title":"Environment Management","text":"<p>Both evaluators properly handle: - Environment extension for lexical scoping - Context managers for isolated execution - Variable definition and lookup - Host command dispatch</p>"},{"location":"architecture/evaluator-parity/#benefits-of-dual-implementation","title":"Benefits of Dual Implementation","text":"<ol> <li>Validation - Cross-checking ensures correctness</li> <li>Flexibility - Choose evaluator based on needs</li> <li>Documentation - Recursive serves as readable specification</li> <li>Innovation - Stack evaluator adds advanced features without breaking compatibility</li> <li>Testing - Natural A/B testing of implementations</li> </ol>"},{"location":"architecture/evaluator-parity/#future-work","title":"Future Work","text":"<p>While parity is complete, the stack evaluator can add features impossible with recursive evaluation:</p> <ul> <li>Execution state serialization</li> <li>Network distribution of computation</li> <li>Time-sliced execution</li> <li>Pauseable/resumable workflows</li> <li>Checkpoint/restore capabilities</li> </ul>"},{"location":"architecture/evaluator-parity/#conclusion","title":"Conclusion","text":"<p>JSL's dual evaluator architecture provides both simplicity and power while maintaining complete semantic consistency. The comprehensive test suite ensures that any program will produce identical results regardless of which evaluator is used, giving users confidence to choose the evaluator that best fits their needs.</p>"},{"location":"architecture/jpn-dictionary-format/","title":"JPN Dictionary Format Design","text":""},{"location":"architecture/jpn-dictionary-format/#overview","title":"Overview","text":"<p>This document defines the proper JPN (JSL Postfix Notation) format for dictionaries/objects in JSL. Currently, the compiler at <code>/home/spinoza/github/repos/jsl/jsl/compiler.py</code> handles dictionaries by pushing them as literal values, but this doesn't align with the postfix evaluation model and lacks the composability that other JSL constructs provide.</p>"},{"location":"architecture/jpn-dictionary-format/#current-state-analysis","title":"Current State Analysis","text":""},{"location":"architecture/jpn-dictionary-format/#how-jsl-currently-handles-dictionaries","title":"How JSL Currently Handles Dictionaries","text":"<ol> <li> <p>S-expression format: Dictionaries are JSON objects with <code>@</code> prefixed string literals    <pre><code>{\"@name\": \"@Alice\", \"@age\": 30}\n</code></pre></p> </li> <li> <p>Current compilation: The compiler simply pushes dictionary literals as-is    <pre><code>elif isinstance(e, dict):\n    # Dictionary literal - encode specially\n    # For now, just push as-is (needs more thought for proper JPN)\n    result.append(e)\n</code></pre></p> </li> <li> <p>Stack evaluator: Handles dictionaries as literals, consuming gas but not decomposing them    <pre><code>elif isinstance(instr, dict):\n    # Push dict literal\n    self._consume_gas(GasCost.DICT_CREATE + len(instr) * GasCost.DICT_PER_ITEM, \"dict literal\")\n    stack.append(instr)\n</code></pre></p> </li> </ol>"},{"location":"architecture/jpn-dictionary-format/#problems-with-current-approach","title":"Problems with Current Approach","text":"<ol> <li>Inconsistent with postfix model: Other constructs are decomposed into operations, but dictionaries remain monolithic</li> <li>No composability: Cannot construct dictionaries dynamically in JPN without escaping to S-expressions</li> <li>Evaluation limitations: Keys and values in dictionary literals must be pre-evaluated in S-expression form</li> <li>No intermediate representation: Cannot pause/resume dictionary construction in partial evaluation</li> </ol>"},{"location":"architecture/jpn-dictionary-format/#proposed-jpn-dictionary-format","title":"Proposed JPN Dictionary Format","text":""},{"location":"architecture/jpn-dictionary-format/#design-principles","title":"Design Principles","text":"<ol> <li>Consistency: Dictionary operations should follow the same arity-then-operator pattern as other JPN operations</li> <li>Composability: Should enable dynamic dictionary construction from stack values</li> <li>JSON compatibility: Result must remain valid JSON for network transmission</li> <li>Stack-friendly: Should work naturally with the stack evaluation model</li> </ol>"},{"location":"architecture/jpn-dictionary-format/#core-dictionary-operations","title":"Core Dictionary Operations","text":""},{"location":"architecture/jpn-dictionary-format/#1-dictionary-creation-dict","title":"1. Dictionary Creation: <code>dict</code>","text":"<p>Purpose: Create a dictionary from key-value pairs on the stack</p> <p>S-expression equivalent:  <pre><code>[\"dict\", \"key1\", \"value1\", \"key2\", \"value2\"]\n</code></pre></p> <p>JPN format: <pre><code>[\"@key1\", \"value1\", \"@key2\", \"value2\", 4, \"dict\"]\n</code></pre></p> <p>Stack behavior: - Pops <code>arity</code> items from stack (must be even number) - Pairs them as key-value (key1, value1, key2, value2, ...) - Creates dictionary <code>{\"key1\": \"value1\", \"key2\": \"value2\"}</code> - Pushes result dictionary onto stack</p> <p>Gas cost: <code>GasCost.DICT_CREATE + (arity/2) * GasCost.DICT_PER_ITEM</code></p>"},{"location":"architecture/jpn-dictionary-format/#2-empty-dictionary-dict-empty","title":"2. Empty Dictionary: <code>dict-empty</code>","text":"<p>Purpose: Create an empty dictionary</p> <p>S-expression equivalent: <pre><code>[\"dict-empty\"]\n</code></pre></p> <p>JPN format: <pre><code>[0, \"dict-empty\"]\n</code></pre></p> <p>Stack behavior: - Takes no arguments - Pushes empty dictionary <code>{}</code> onto stack</p>"},{"location":"architecture/jpn-dictionary-format/#dictionary-access-operations","title":"Dictionary Access Operations","text":"<p>These operations already exist in the prelude and work with both evaluators:</p>"},{"location":"architecture/jpn-dictionary-format/#3-get-value-get","title":"3. Get Value: <code>get</code>","text":"<ul> <li>S-expr: <code>[\"get\", dict_expr, \"key\", default_value?]</code></li> <li>JPN: <code>[dict_expr_jpn..., \"@key\", default_value?, arity, \"get\"]</code></li> </ul>"},{"location":"architecture/jpn-dictionary-format/#4-set-value-set","title":"4. Set Value: <code>set</code>","text":"<ul> <li>S-expr: <code>[\"set\", dict_expr, \"key\", new_value]</code></li> <li>JPN: <code>[dict_expr_jpn..., \"@key\", new_value, 3, \"set\"]</code></li> </ul>"},{"location":"architecture/jpn-dictionary-format/#5-check-key-has","title":"5. Check Key: <code>has</code>","text":"<ul> <li>S-expr: <code>[\"has\", dict_expr, \"key\"]</code></li> <li>JPN: <code>[dict_expr_jpn..., \"@key\", 2, \"has\"]</code></li> </ul>"},{"location":"architecture/jpn-dictionary-format/#6-get-keys-keys","title":"6. Get Keys: <code>keys</code>","text":"<ul> <li>S-expr: <code>[\"keys\", dict_expr]</code></li> <li>JPN: <code>[dict_expr_jpn..., 1, \"keys\"]</code></li> </ul>"},{"location":"architecture/jpn-dictionary-format/#7-get-values-values","title":"7. Get Values: <code>values</code>","text":"<ul> <li>S-expr: <code>[\"values\", dict_expr]</code></li> <li>JPN: <code>[dict_expr_jpn..., 1, \"values\"]</code></li> </ul>"},{"location":"architecture/jpn-dictionary-format/#8-merge-dictionaries-merge","title":"8. Merge Dictionaries: <code>merge</code>","text":"<ul> <li>S-expr: <code>[\"merge\", dict1, dict2, dict3, ...]</code></li> <li>JPN: <code>[dict1_jpn..., dict2_jpn..., dict3_jpn..., arity, \"merge\"]</code></li> </ul>"},{"location":"architecture/jpn-dictionary-format/#implementation-examples","title":"Implementation Examples","text":""},{"location":"architecture/jpn-dictionary-format/#example-1-simple-dictionary-creation","title":"Example 1: Simple Dictionary Creation","text":"<p>S-expression: <pre><code>[\"dict\", \"@name\", \"@Alice\", \"@age\", 30]\n</code></pre></p> <p>JPN compilation: <pre><code>[\"@name\", \"@Alice\", 30, 4, \"dict\"]\n</code></pre></p> <p>Stack trace: <pre><code>Initial: []\nPush \"@name\": [\"@name\"]\nPush \"@Alice\": [\"@name\", \"@Alice\"] \nPush 30: [\"@name\", \"@Alice\", 30]\nPush 4: [\"@name\", \"@Alice\", 30, 4]\nExecute \"dict\": [{\"name\": \"Alice\", \"age\": 30}]\n</code></pre></p>"},{"location":"architecture/jpn-dictionary-format/#example-2-nested-dictionary-with-dynamic-values","title":"Example 2: Nested Dictionary with Dynamic Values","text":"<p>S-expression: <pre><code>[\"dict\", \n  \"@user\", [\"dict\", \"@name\", \"@Alice\", \"@age\", 30],\n  \"@timestamp\", [\"+\", 1000, 500]\n]\n</code></pre></p> <p>JPN compilation: <pre><code>[\n  \"@user\", \n  \"@name\", \"@Alice\", 30, 4, \"dict\",\n  \"@timestamp\", \n  1000, 500, 2, \"+\",\n  4, \"dict\"\n]\n</code></pre></p> <p>Stack trace: <pre><code>Push \"@user\": [\"@user\"]\nPush \"@name\": [\"@user\", \"@name\"]\nPush \"@Alice\": [\"@user\", \"@name\", \"@Alice\"]\nPush 30: [\"@user\", \"@name\", \"@Alice\", 30]\nPush 4: [\"@user\", \"@name\", \"@Alice\", 30, 4]\nExecute \"dict\": [\"@user\", {\"name\": \"Alice\", \"age\": 30}]\nPush \"@timestamp\": [\"@user\", {\"name\": \"Alice\", \"age\": 30}, \"@timestamp\"]\nPush 1000: [\"@user\", {\"name\": \"Alice\", \"age\": 30}, \"@timestamp\", 1000]\nPush 500: [\"@user\", {\"name\": \"Alice\", \"age\": 30}, \"@timestamp\", 1000, 500]\nPush 2: [\"@user\", {\"name\": \"Alice\", \"age\": 30}, \"@timestamp\", 1000, 500, 2]\nExecute \"+\": [\"@user\", {\"name\": \"Alice\", \"age\": 30}, \"@timestamp\", 1500]\nPush 4: [\"@user\", {\"name\": \"Alice\", \"age\": 30}, \"@timestamp\", 1500, 4]\nExecute \"dict\": [{\"user\": {\"name\": \"Alice\", \"age\": 30}, \"timestamp\": 1500}]\n</code></pre></p>"},{"location":"architecture/jpn-dictionary-format/#example-3-dictionary-literals-in-current-format","title":"Example 3: Dictionary Literals in Current Format","text":"<p>Current S-expression literal: <pre><code>{\"@name\": \"@Alice\", \"@age\": 30}\n</code></pre></p> <p>Should compile to: <pre><code>[\"@name\", \"@Alice\", \"@age\", 30, 4, \"dict\"]\n</code></pre></p> <p>This maintains compatibility while providing the composability benefits of JPN.</p>"},{"location":"architecture/jpn-dictionary-format/#migration-strategy","title":"Migration Strategy","text":""},{"location":"architecture/jpn-dictionary-format/#phase-1-add-dictionary-operations-to-stack-evaluator","title":"Phase 1: Add Dictionary Operations to Stack Evaluator","text":"<ol> <li>Add <code>dict</code> and <code>dict-empty</code> operations to <code>StackEvaluator._setup_builtins()</code></li> <li>Update gas costs to handle these operations</li> <li>Add comprehensive tests for the new operations</li> </ol>"},{"location":"architecture/jpn-dictionary-format/#phase-2-update-compiler","title":"Phase 2: Update Compiler","text":"<ol> <li>Modify <code>compile_to_postfix()</code> to handle dictionary literals by converting them to <code>dict</code> operations</li> <li>Update <code>decompile_from_postfix()</code> to handle the new operations</li> <li>Ensure round-trip compilation works correctly</li> </ol>"},{"location":"architecture/jpn-dictionary-format/#phase-3-update-prelude-if-needed","title":"Phase 3: Update Prelude (if needed)","text":"<ol> <li>Add <code>dict</code> and <code>dict-empty</code> to prelude operations if they need to be available in S-expression form</li> <li>Ensure all existing dictionary operations work with both evaluation modes</li> </ol>"},{"location":"architecture/jpn-dictionary-format/#phase-4-update-documentation-and-examples","title":"Phase 4: Update Documentation and Examples","text":"<ol> <li>Update documentation to show JPN dictionary format</li> <li>Provide migration examples for existing code</li> <li>Update tutorials to demonstrate dictionary construction patterns</li> </ol>"},{"location":"architecture/jpn-dictionary-format/#key-design-decisions-and-rationale","title":"Key Design Decisions and Rationale","text":""},{"location":"architecture/jpn-dictionary-format/#1-arity-first-convention","title":"1. Arity-First Convention","text":"<p>Decision: Use the established <code>[args..., arity, operator]</code> pattern for <code>dict</code> operation.</p> <p>Rationale:  - Maintains consistency with other JPN operations - Enables the stack evaluator to know how many arguments to consume - Supports variable-arity dictionary construction</p>"},{"location":"architecture/jpn-dictionary-format/#2-even-arity-requirement","title":"2. Even Arity Requirement","text":"<p>Decision: The <code>dict</code> operation requires an even number of arguments (pairs of key-value).</p> <p>Rationale: - Dictionaries naturally require key-value pairs - Provides clear error semantics for malformed input - Simplifies implementation logic</p>"},{"location":"architecture/jpn-dictionary-format/#3-string-key-requirement","title":"3. String Key Requirement","text":"<p>Decision: Keys must be strings (enforced at evaluation time, not compilation time).</p> <p>Rationale: - Maintains JSON compatibility - Consistent with JSL's current dictionary semantics - Allows for dynamic key generation while preserving type safety</p>"},{"location":"architecture/jpn-dictionary-format/#4-separate-empty-dictionary-operation","title":"4. Separate Empty Dictionary Operation","text":"<p>Decision: Provide <code>dict-empty</code> as a separate zero-arity operation rather than allowing <code>[0, \"dict\"]</code>.</p> <p>Rationale: - Clearer semantics (empty dict vs. malformed dict) - Follows pattern of other JSL operations like <code>list</code> vs empty list - Enables specific gas costs for empty dictionary creation</p>"},{"location":"architecture/jpn-dictionary-format/#5-backward-compatibility","title":"5. Backward Compatibility","text":"<p>Decision: Convert existing dictionary literals to JPN format during compilation.</p> <p>Rationale: - Preserves existing JSL code - Provides gradual migration path - Maintains the same evaluation semantics</p>"},{"location":"architecture/jpn-dictionary-format/#error-handling","title":"Error Handling","text":""},{"location":"architecture/jpn-dictionary-format/#invalid-arity","title":"Invalid Arity","text":"<p><pre><code>[\"@key1\", \"value1\", \"@incomplete\", 3, \"dict\"]  // Odd number of args\n</code></pre> Error: \"Dictionary requires even number of arguments for key-value pairs\"</p>"},{"location":"architecture/jpn-dictionary-format/#non-string-keys","title":"Non-String Keys","text":"<p><pre><code>[123, \"value1\", \"@key2\", \"value2\", 4, \"dict\"]  // Numeric key\n</code></pre> Error: \"Dictionary key must be string, got number: 123\"</p>"},{"location":"architecture/jpn-dictionary-format/#stack-underflow","title":"Stack Underflow","text":"<p><pre><code>[2, \"dict\"]  // Not enough values on stack\n</code></pre> Error: \"Stack underflow: dict needs 2 args, have 0\"</p>"},{"location":"architecture/jpn-dictionary-format/#performance-considerations","title":"Performance Considerations","text":""},{"location":"architecture/jpn-dictionary-format/#gas-costs","title":"Gas Costs","text":"<ul> <li>dict: <code>GasCost.DICT_CREATE + (arity/2) * GasCost.DICT_PER_ITEM</code></li> <li>dict-empty: <code>GasCost.DICT_CREATE</code></li> </ul>"},{"location":"architecture/jpn-dictionary-format/#memory-tracking","title":"Memory Tracking","text":"<ul> <li>Dictionary size is tracked for resource budgets</li> <li>Each key-value pair contributes to memory usage calculations</li> </ul>"},{"location":"architecture/jpn-dictionary-format/#optimization-opportunities","title":"Optimization Opportunities","text":"<ol> <li>Pre-allocation: Could pre-allocate dictionary size if known</li> <li>Literal optimization: Simple literals could be optimized to avoid stack operations</li> <li>Common patterns: Frequent dictionary patterns could be cached</li> </ol>"},{"location":"architecture/jpn-dictionary-format/#testing-strategy","title":"Testing Strategy","text":""},{"location":"architecture/jpn-dictionary-format/#unit-tests-required","title":"Unit Tests Required","text":"<ol> <li>Basic Operations:</li> <li>Create empty dictionary</li> <li>Create dictionary with multiple key-value pairs</li> <li> <p>Verify correct gas consumption</p> </li> <li> <p>Error Cases:</p> </li> <li>Odd number of arguments</li> <li>Non-string keys</li> <li> <p>Stack underflow scenarios</p> </li> <li> <p>Integration Tests:</p> </li> <li>Nested dictionaries</li> <li>Dynamic key/value computation</li> <li> <p>Round-trip compilation/decompilation</p> </li> <li> <p>Compatibility Tests:</p> </li> <li>Existing dictionary literal code still works</li> <li>Both evaluators produce identical results</li> <li> <p>Serialization/deserialization works correctly</p> </li> <li> <p>Performance Tests:</p> </li> <li>Large dictionaries</li> <li>Deep nesting</li> <li>Resource budget compliance</li> </ol>"},{"location":"architecture/jpn-dictionary-format/#future-extensions","title":"Future Extensions","text":""},{"location":"architecture/jpn-dictionary-format/#potential-enhancements","title":"Potential Enhancements","text":"<ol> <li>Pattern Matching: Dictionary destructuring in let bindings</li> <li>Computed Keys: Support for computed key expressions in literals</li> <li>Dictionary Comprehensions: Map-like operations for dictionary construction</li> <li>Immutable Updates: Efficient nested dictionary updates</li> </ol>"},{"location":"architecture/jpn-dictionary-format/#considerations-for-network-usage","title":"Considerations for Network Usage","text":"<ol> <li>Bandwidth: JPN format may be more verbose than current literals for simple cases</li> <li>Caching: Common dictionary patterns could be cached to reduce transmission size</li> <li>Compression: Dictionary operations could be optimized for common network patterns</li> </ol>"},{"location":"architecture/jpn-dictionary-format/#conclusion","title":"Conclusion","text":"<p>This design provides a consistent, composable approach to dictionary handling in JPN while maintaining backward compatibility with existing JSL code. The postfix representation enables:</p> <ul> <li>Resumable evaluation: Dictionary construction can be paused and resumed</li> <li>Dynamic composition: Dictionaries can be built from computed values</li> <li>Resource tracking: Fine-grained gas and memory accounting</li> <li>Network efficiency: Structured representation suitable for distributed execution</li> </ul> <p>The implementation should be straightforward given the existing infrastructure, and the migration path provides a smooth transition for existing JSL programs.</p>"},{"location":"architecture/jpn-implementation/","title":"JPN Dictionary Format - Implementation Summary","text":""},{"location":"architecture/jpn-implementation/#problem-statement","title":"Problem Statement","text":"<p>The JSL compiler at <code>/home/spinoza/github/repos/jsl/jsl/compiler.py</code> currently handles dictionaries by pushing them as literal values rather than decomposing them into postfix operations. This approach is inconsistent with the stack-based evaluation model and lacks the composability benefits that other JSL constructs provide.</p>"},{"location":"architecture/jpn-implementation/#solution-overview","title":"Solution Overview","text":"<p>A comprehensive design for dictionary handling in JPN (JSL Postfix Notation) that introduces two new operations:</p> <ol> <li><code>dict</code> - Creates dictionaries from key-value pairs on the stack</li> <li><code>dict-empty</code> - Creates empty dictionaries</li> </ol>"},{"location":"architecture/jpn-implementation/#key-design-features","title":"Key Design Features","text":""},{"location":"architecture/jpn-implementation/#1-consistent-postfix-pattern","title":"1. Consistent Postfix Pattern","text":"<pre><code>// S-expression: [\"dict\", \"@name\", \"@Alice\", \"@age\", 30]\n// JPN format:   [\"@name\", \"@Alice\", \"@age\", 30, 4, \"dict\"]\n</code></pre>"},{"location":"architecture/jpn-implementation/#2-stack-based-construction","title":"2. Stack-Based Construction","text":"<ul> <li>Arguments are pushed to stack first</li> <li>Arity specifies number of arguments (must be even for <code>dict</code>)</li> <li>Operation consumes arguments and produces result</li> </ul>"},{"location":"architecture/jpn-implementation/#3-nested-dictionary-support","title":"3. Nested Dictionary Support","text":"<pre><code>// Nested: {\"user\": {\"name\": \"Alice\", \"age\": 30}, \"timestamp\": 1500}\n// JPN: [\"@user\", \"@name\", \"@Alice\", \"@age\", 30, 4, \"dict\", \"@timestamp\", 1500, 4, \"dict\"]\n</code></pre>"},{"location":"architecture/jpn-implementation/#4-error-handling","title":"4. Error Handling","text":"<ul> <li>Validates even number of arguments for key-value pairs</li> <li>Ensures keys are strings at evaluation time</li> <li>Provides clear error messages for invalid operations</li> </ul>"},{"location":"architecture/jpn-implementation/#implementation-status","title":"Implementation Status","text":""},{"location":"architecture/jpn-implementation/#completed-design-elements","title":"\u2705 Completed Design Elements","text":"<ol> <li>Comprehensive specification - Full design document with examples</li> <li>Validation framework - Working test suite demonstrating expected behavior</li> <li>Error handling - Defined error cases and validation logic</li> <li>Resource tracking - Gas consumption patterns defined</li> <li>Migration strategy - Clear path from current to new format</li> </ol>"},{"location":"architecture/jpn-implementation/#implementation-required","title":"\ud83d\udd27 Implementation Required","text":"<ol> <li>StackEvaluator updates - Add <code>dict</code> and <code>dict-empty</code> to built-in operations</li> <li>Compiler updates - Convert dictionary literals to JPN operations</li> <li>Decompiler updates - Handle reverse conversion for debugging</li> <li>Integration tests - Ensure both evaluators produce identical results</li> </ol>"},{"location":"architecture/jpn-implementation/#design-validation-results","title":"Design Validation Results","text":"<p>The validation test suite demonstrates:</p> <ul> <li>\u2705 Basic dictionary operations work correctly</li> <li>\u2705 Error cases are handled appropriately  </li> <li>\u2705 Nested dictionaries can be constructed</li> <li>\u2705 Dictionary literals compile to correct JPN format</li> <li>\u2705 Resource tracking operates as expected</li> <li>\u2705 All major patterns are validated</li> </ul>"},{"location":"architecture/jpn-implementation/#file-deliverables","title":"File Deliverables","text":""},{"location":"architecture/jpn-implementation/#1-design-document","title":"1. Design Document","text":"<p>Location: <code>/home/spinoza/github/repos/jsl/docs/JPN_DICTIONARY_FORMAT.md</code></p> <p>Complete specification including: - Current state analysis - Proposed operations and syntax - Detailed examples with stack traces - Error handling specifications - Performance considerations - Migration strategy</p>"},{"location":"architecture/jpn-implementation/#2-validation-test-suite","title":"2. Validation Test Suite","text":"<p>Location: <code>/home/spinoza/github/repos/jsl/test_jpn_dict_design.py</code></p> <p>Comprehensive test framework demonstrating: - Basic operations - Error cases - Nested construction - Compilation patterns - Resource tracking - Integration patterns</p>"},{"location":"architecture/jpn-implementation/#3-implementation-summary","title":"3. Implementation Summary","text":"<p>Location: <code>/home/spinoza/github/repos/jsl/docs/JPN_DICTIONARY_IMPLEMENTATION_SUMMARY.md</code> (this file)</p>"},{"location":"architecture/jpn-implementation/#next-steps-for-implementation","title":"Next Steps for Implementation","text":""},{"location":"architecture/jpn-implementation/#phase-1-core-operations-priority-high","title":"Phase 1: Core Operations (Priority: High)","text":"<pre><code># Add to StackEvaluator._setup_builtins()\nbuiltins.update({\n    'dict': self._dict_operation,\n    'dict-empty': self._dict_empty_operation,\n})\n</code></pre>"},{"location":"architecture/jpn-implementation/#phase-2-compiler-integration-priority-high","title":"Phase 2: Compiler Integration (Priority: High)","text":"<pre><code># Update compile_to_postfix() dictionary handling\nelif isinstance(e, dict):\n    if not e:\n        result.append(0)\n        result.append('dict-empty')\n    else:\n        for key, value in e.items():\n            compile_expr(key)\n            compile_expr(value)\n        result.append(len(e) * 2)\n        result.append('dict')\n</code></pre>"},{"location":"architecture/jpn-implementation/#phase-3-testing-and-validation-priority-medium","title":"Phase 3: Testing and Validation (Priority: Medium)","text":"<ul> <li>Convert validation tests to real implementation tests</li> <li>Add to main test suite</li> <li>Verify both evaluators produce identical results</li> <li>Performance benchmarking</li> </ul>"},{"location":"architecture/jpn-implementation/#phase-4-documentation-updates-priority-low","title":"Phase 4: Documentation Updates (Priority: Low)","text":"<ul> <li>Update API documentation</li> <li>Add tutorial examples</li> <li>Update language specification</li> </ul>"},{"location":"architecture/jpn-implementation/#benefits-of-this-design","title":"Benefits of This Design","text":"<ol> <li>Consistency - Aligns with JSL's postfix evaluation model</li> <li>Composability - Enables dynamic dictionary construction</li> <li>Resumability - Supports pause/resume of dictionary operations</li> <li>Resource Tracking - Fine-grained gas and memory accounting</li> <li>Network Efficiency - Structured representation for distributed execution</li> <li>Backward Compatibility - Preserves existing dictionary literal syntax</li> </ol>"},{"location":"architecture/jpn-implementation/#performance-characteristics","title":"Performance Characteristics","text":"<ul> <li>Gas Cost: <code>GasCost.DICT_CREATE + (pairs * GasCost.DICT_PER_ITEM)</code></li> <li>Memory: Tracked per key-value pair added</li> <li>Stack Usage: Temporary stack growth during construction</li> <li>Optimization Potential: Simple literals could be optimized to avoid stack operations</li> </ul>"},{"location":"architecture/jpn-implementation/#conclusion","title":"Conclusion","text":"<p>This design provides a robust, consistent approach to dictionary handling in JPN that maintains the benefits of JSL's postfix evaluation model while preserving compatibility with existing code. The comprehensive validation demonstrates that the design is sound and ready for implementation.</p>"},{"location":"architecture/json-manipulation-proposal/","title":"JSON Manipulation Features for JSL","text":"<p>Since JSL is JSON-native, it should excel at JSON data manipulation. Based on the dotsuite patterns, here are proposed features:</p>"},{"location":"architecture/json-manipulation-proposal/#1-deep-path-navigation","title":"1. Deep Path Navigation","text":""},{"location":"architecture/json-manipulation-proposal/#current-limitation","title":"Current Limitation","text":"<pre><code>// Currently need nested gets:\n[\"get\", [\"get\", [\"get\", user, \"@address\"], \"@city\"], \"@name\"]\n\n// Or define a function:\n[\"lambda\", [\"obj\"], \n  [\"get\", [\"get\", [\"get\", \"obj\", \"@address\"], \"@city\"], \"@name\"]]\n</code></pre>"},{"location":"architecture/json-manipulation-proposal/#proposed-get-path-operator","title":"Proposed: <code>get-path</code> operator","text":"<pre><code>// Direct path access\n[\"get-path\", user, \"@address.city.name\"]\n\n// With array indexing\n[\"get-path\", data, \"@items.0.price\"]\n\n// With wildcards\n[\"get-path\", data, \"@users.*.email\"]  // Returns all emails\n</code></pre>"},{"location":"architecture/json-manipulation-proposal/#implementation","title":"Implementation","text":"<pre><code>[\"def\", \"get-path\", [\"lambda\", [\"obj\", \"path\"],\n  [\"reduce\", \n    [\"lambda\", [\"acc\", \"key\"], [\"get\", \"acc\", \"key\"]],\n    [\"str-split\", \"path\", \"@.\"],\n    \"obj\"\n  ]\n]]\n</code></pre>"},{"location":"architecture/json-manipulation-proposal/#2-query-based-filtering","title":"2. Query-Based Filtering","text":""},{"location":"architecture/json-manipulation-proposal/#current-limitation_1","title":"Current Limitation","text":"<pre><code>// Currently need explicit lambdas:\n[\"filter\", \n  [\"lambda\", [\"user\"], \n    [\"and\", \n      [\"=\", [\"get\", \"user\", \"@role\"], \"@admin\"],\n      [\"get\", \"user\", \"@active\"]\n    ]\n  ],\n  users\n]\n</code></pre>"},{"location":"architecture/json-manipulation-proposal/#proposed-where-operator","title":"Proposed: <code>where</code> operator","text":"<pre><code>// Declarative filtering\n[\"where\", users, [\"@role\", \"=\", \"@admin\"]]\n\n// Compound conditions\n[\"where\", users, \n  [\"and\",\n    [\"@role\", \"=\", \"@admin\"],\n    [\"@active\", \"=\", true]\n  ]\n]\n\n// Nested paths\n[\"where\", users, [\"@address.country\", \"=\", \"@USA\"]]\n</code></pre>"},{"location":"architecture/json-manipulation-proposal/#query-operators","title":"Query Operators","text":"<ul> <li><code>[\"@field\", \"=\", value]</code> - Equality</li> <li><code>[\"@field\", \"!=\", value]</code> - Inequality  </li> <li><code>[\"@field\", \"&gt;\", value]</code> - Greater than</li> <li><code>[\"@field\", \"&lt;\", value]</code> - Less than</li> <li><code>[\"@field\", \"contains\", value]</code> - String/array contains</li> <li><code>[\"@field\", \"matches\", pattern]</code> - Regex match</li> </ul>"},{"location":"architecture/json-manipulation-proposal/#3-object-transformation-pipelines","title":"3. Object Transformation Pipelines","text":""},{"location":"architecture/json-manipulation-proposal/#current-limitation_2","title":"Current Limitation","text":"<pre><code>// Currently need multiple steps:\n[\"do\",\n  [\"def\", \"temp\", [\"get\", data, \"@user\"]],\n  [\"def\", \"temp\", [\"set\", \"temp\", \"@fullName\", \n    [\"str-concat\", [\"get\", \"temp\", \"@firstName\"], \"@ \", [\"get\", \"temp\", \"@lastName\"]]\n  ]],\n  [\"def\", \"result\", {\"@user\": \"temp\", \"@timestamp\": [\"now\"]}],\n  \"result\"\n]\n</code></pre>"},{"location":"architecture/json-manipulation-proposal/#proposed-transform-operator","title":"Proposed: <code>transform</code> operator","text":"<pre><code>// Pipeline transformations\n[\"transform\", data,\n  [\"assign\", \"@fullName\", [\"concat-path\", \"@firstName\", \"@ \", \"@lastName\"]],\n  [\"pick\", \"@id\", \"@fullName\", \"@email\"],\n  [\"rename\", \"@email\", \"@contact\"],\n  [\"default\", \"@status\", \"@active\"]\n]\n</code></pre>"},{"location":"architecture/json-manipulation-proposal/#transform-operations","title":"Transform Operations","text":"<ul> <li><code>[\"assign\", field, value]</code> - Add/update field</li> <li><code>[\"pick\", ...fields]</code> - Keep only specified fields</li> <li><code>[\"omit\", ...fields]</code> - Remove specified fields</li> <li><code>[\"rename\", old, new]</code> - Rename field</li> <li><code>[\"default\", field, value]</code> - Set if missing</li> <li><code>[\"apply\", field, function]</code> - Transform field value</li> </ul>"},{"location":"architecture/json-manipulation-proposal/#4-collection-operations","title":"4. Collection Operations","text":""},{"location":"architecture/json-manipulation-proposal/#proposed-enhanced-collection-operations","title":"Proposed: Enhanced collection operations","text":"<pre><code>// Group by\n[\"group-by\", users, \"@department\"]\n// Returns: {\"@engineering\": [...], \"@sales\": [...]}\n\n// Unique values\n[\"unique\", [\"get-path\", users, \"@*.email\"]]\n\n// Pluck single field\n[\"pluck\", users, \"@email\"]\n// Equivalent to: [\"map\", [\"lambda\", [\"x\"], [\"get\", \"x\", \"@email\"]], users]\n\n// Index by\n[\"index-by\", users, \"@id\"]\n// Returns: {\"@123\": {user1}, \"@456\": {user2}}\n</code></pre>"},{"location":"architecture/json-manipulation-proposal/#5-safe-navigation","title":"5. Safe Navigation","text":""},{"location":"architecture/json-manipulation-proposal/#proposed-get-safe-operator","title":"Proposed: <code>get-safe</code> operator","text":"<pre><code>// Returns null instead of error if path doesn't exist\n[\"get-safe\", user, \"@address.city.name\"]\n\n// With default value\n[\"get-default\", user, \"@address.city.name\", \"@Unknown\"]\n</code></pre>"},{"location":"architecture/json-manipulation-proposal/#implementation-strategy","title":"Implementation Strategy","text":"<p>These features could be implemented in phases:</p>"},{"location":"architecture/json-manipulation-proposal/#phase-1-core-path-operations","title":"Phase 1: Core Path Operations","text":"<ul> <li><code>get-path</code> - Deep path access</li> <li><code>set-path</code> - Deep path setting</li> <li><code>has-path</code> - Check if path exists</li> <li><code>get-safe</code> - Safe navigation</li> </ul>"},{"location":"architecture/json-manipulation-proposal/#phase-2-query-operations","title":"Phase 2: Query Operations","text":"<ul> <li><code>where</code> - Declarative filtering</li> <li>Query expression evaluation</li> </ul>"},{"location":"architecture/json-manipulation-proposal/#phase-3-transform-operations","title":"Phase 3: Transform Operations","text":"<ul> <li><code>transform</code> - Pipeline transformations</li> <li>Individual transform operations</li> </ul>"},{"location":"architecture/json-manipulation-proposal/#phase-4-advanced-collections","title":"Phase 4: Advanced Collections","text":"<ul> <li><code>group-by</code> - Group collection by field</li> <li><code>index-by</code> - Convert to keyed object</li> <li><code>pluck</code> - Extract single field</li> <li><code>unique</code> - Unique values</li> </ul>"},{"location":"architecture/json-manipulation-proposal/#benefits","title":"Benefits","text":"<ol> <li>More Intuitive: Declarative operations are easier to read/write than nested lambdas</li> <li>JSON-Native: Leverages JSL's JSON foundation</li> <li>Composable: Operations can be easily combined</li> <li>Network-Friendly: All operations remain serializable</li> <li>Performance: Can be optimized in the evaluator</li> </ol>"},{"location":"architecture/json-manipulation-proposal/#examples","title":"Examples","text":""},{"location":"architecture/json-manipulation-proposal/#before-current-jsl","title":"Before (Current JSL)","text":"<pre><code>[\"filter\",\n  [\"lambda\", [\"user\"],\n    [\"and\",\n      [\"=\", [\"get\", \"user\", \"@role\"], \"@admin\"],\n      [\"get\", \"user\", \"@active\"]\n    ]\n  ],\n  [\"map\",\n    [\"lambda\", [\"user\"],\n      {\"@id\": [\"get\", \"user\", \"@id\"],\n       \"@name\": [\"str-concat\", \n         [\"get\", \"user\", \"@firstName\"], \n         \"@ \", \n         [\"get\", \"user\", \"@lastName\"]\n       ],\n       \"@email\": [\"get\", \"user\", \"@email\"]}\n    ],\n    users\n  ]\n]\n</code></pre>"},{"location":"architecture/json-manipulation-proposal/#after-with-proposed-features","title":"After (With Proposed Features)","text":"<pre><code>[\"transform\",\n  [\"where\", users, \n    [\"and\", \n      [\"@role\", \"=\", \"@admin\"],\n      [\"@active\", \"=\", true]\n    ]\n  ],\n  [\"assign\", \"@name\", [\"concat-path\", \"@firstName\", \"@ \", \"@lastName\"]],\n  [\"pick\", \"@id\", \"@name\", \"@email\"]\n]\n</code></pre>"},{"location":"architecture/json-manipulation-proposal/#compatibility","title":"Compatibility","text":"<p>All proposed features can be implemented as: 1. Built-in functions in the prelude 2. Special forms in the evaluator 3. Macro expansions to existing operations</p> <p>This ensures backward compatibility while adding powerful JSON manipulation capabilities.</p>"},{"location":"architecture/json-operations-design/","title":"JSON Operations in JSL","text":""},{"location":"architecture/json-operations-design/#motivation","title":"Motivation","text":"<p>JSL's JSON manipulation features are inspired by dotsuite, a pedagogical approach to querying, transforming, and filtering JSON data. Since JSL is a JSON-native language where all programs and data are representable as standard JSON, providing powerful JSON manipulation primitives is essential.</p> <p>The dotsuite project demonstrates elegant patterns for working with JSON data through: - dotpath: Deep path navigation using dot notation - dotpipe/dotmod: Pipeline transformations on JSON objects - dotfilter: Declarative filtering of JSON collections</p> <p>JSL adapts these concepts to fit naturally within a Lisp-like functional programming paradigm, making JSON manipulation a first-class concern.</p>"},{"location":"architecture/json-operations-design/#core-operations","title":"Core Operations","text":""},{"location":"architecture/json-operations-design/#1-path-navigation-inspired-by-dotpath","title":"1. Path Navigation (inspired by dotpath)","text":"<p>Deep path access allows navigating nested JSON structures with simple path strings:</p> <pre><code>// Instead of nested gets:\n[\"get\", [\"get\", [\"get\", user, \"@address\"], \"@city\"], \"@name\"]\n\n// Use path navigation:\n[\"get-path\", user, \"@address.city.name\"]\n</code></pre> <p>Available functions: - <code>get-path</code> - Navigate to a value at a deep path - <code>set-path</code> - Set a value at a deep path (returns new object) - <code>has-path</code> - Check if a path exists - <code>get-safe</code> - Safe navigation with default values - <code>get-default</code> - Explicit default for missing paths</p> <p>Features: - Dot notation: <code>\"user.address.city\"</code> - Array indexing: <code>\"items.0.price\"</code> or <code>\"items[0].price\"</code> - Wildcards: <code>\"users.*.email\"</code> returns all email values</p>"},{"location":"architecture/json-operations-design/#2-declarative-filtering-inspired-by-dotfilter","title":"2. Declarative Filtering (inspired by dotfilter)","text":"<p>The <code>where</code> operator provides SQL-like declarative filtering without verbose lambda expressions:</p> <pre><code>// Traditional approach with lambda:\n[\"filter\", \n  [\"lambda\", [\"user\"], \n    [\"and\", \n      [\"=\", [\"get\", \"user\", \"@role\"], \"@admin\"],\n      [\"get\", \"user\", \"@active\"]\n    ]\n  ],\n  users\n]\n\n// Declarative approach with where:\n[\"where\", users, \n  [\"@and\",\n    [\"@role\", \"@=\", \"@admin\"],\n    [\"@active\", \"@=\", true]\n  ]\n]\n</code></pre> <p>Query operators: - Comparison: <code>=</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code> - String/array: <code>contains</code> - Pattern matching: <code>matches</code> (regex) - Logical: <code>and</code>, <code>or</code>, <code>not</code></p>"},{"location":"architecture/json-operations-design/#3-pipeline-transformations-inspired-by-dotpipedotmod","title":"3. Pipeline Transformations (inspired by dotpipe/dotmod)","text":"<p>The <code>transform</code> operator enables composable object transformations:</p> <pre><code>// Apply multiple transformations in sequence:\n[\"transform\", data,\n  [\"@assign\", \"@computed\", [\"*\", [\"get\", \"data\", \"@x\"], 2]],\n  [\"@pick\", \"@id\", \"@name\", \"@computed\"],\n  [\"@rename\", \"@computed\", \"@result\"],\n  [\"@default\", \"@status\", \"@pending\"]\n]\n</code></pre> <p>Transform operations: - <code>assign</code> - Add or update fields - <code>pick</code> - Keep only specified fields - <code>omit</code> - Remove specified fields - <code>rename</code> - Rename fields - <code>default</code> - Set values for missing fields - <code>apply</code> - Transform field values with functions</p>"},{"location":"architecture/json-operations-design/#4-collection-utilities","title":"4. Collection Utilities","text":"<p>Additional operations for working with JSON collections:</p> <pre><code>// Extract single field from each item:\n[\"pluck\", users, \"@email\"]\n// Returns: [\"alice@example.com\", \"bob@example.com\", ...]\n\n// Convert list to keyed object:\n[\"index-by\", users, \"@id\"]\n// Returns: {\"123\": {user1}, \"456\": {user2}, ...}\n\n// Group items by field value:\n[\"group-by\", users, \"@department\"]\n// Returns: {\"sales\": [...], \"engineering\": [...], ...}\n</code></pre>"},{"location":"architecture/json-operations-design/#design-philosophy","title":"Design Philosophy","text":"<p>Following dotsuite's pedagogical approach, these operations are designed to be:</p> <ol> <li>Intuitive: Operations mirror common data manipulation patterns</li> <li>Composable: Small operations combine into complex pipelines</li> <li>Declarative: Express what you want, not how to get it</li> <li>JSON-Native: Work naturally with JSON's structure</li> <li>Functional: All operations return new data, preserving immutability</li> </ol>"},{"location":"architecture/json-operations-design/#examples","title":"Examples","text":""},{"location":"architecture/json-operations-design/#example-1-query-and-transform-user-data","title":"Example 1: Query and Transform User Data","text":"<pre><code>// Find active admin users and prepare for API response\n[\"transform\",\n  [\"where\", users, \n    [\"@and\",\n      [\"@role\", \"@=\", \"@admin\"],\n      [\"@active\", \"@=\", true]\n    ]\n  ],\n  [\"@pick\", \"@id\", \"@name\", \"@email\"],\n  [\"@assign\", \"@type\", \"@admin_user\"]\n]\n</code></pre>"},{"location":"architecture/json-operations-design/#example-2-aggregate-nested-data","title":"Example 2: Aggregate Nested Data","text":"<pre><code>// Get total value of orders from VIP customers\n[\"reduce\",\n  [\"lambda\", [\"sum\", \"order\"], \n    [\"+\", \"sum\", [\"get-path\", \"order\", \"@total\"]]\n  ],\n  [\"where\", orders, [\"@customer.vip\", \"@=\", true]],\n  0\n]\n</code></pre>"},{"location":"architecture/json-operations-design/#example-3-complex-data-pipeline","title":"Example 3: Complex Data Pipeline","text":"<pre><code>// Process product catalog: filter, enrich, and index\n[\"index-by\",\n  [\"transform\",\n    [\"where\", products, \n      [\"@and\",\n        [\"@category\", \"@=\", \"@electronics\"],\n        [\"@price\", \"@&lt;\", 1000]\n      ]\n    ],\n    [\"@assign\", \"@discount\", 0.1],\n    [\"@apply\", \"@name\", [\"lambda\", [\"n\"], [\"str-upper\", \"n\"]]],\n    [\"@pick\", \"@id\", \"@name\", \"@price\", \"@discount\"]\n  ],\n  \"@id\"\n]\n</code></pre>"},{"location":"architecture/json-operations-design/#comparison-with-traditional-approaches","title":"Comparison with Traditional Approaches","text":""},{"location":"architecture/json-operations-design/#without-json-operations","title":"Without JSON Operations","text":"<pre><code>// Deeply nested, hard to read and maintain\n[\"map\",\n  [\"lambda\", [\"item\"],\n    [\"if\",\n      [\"and\",\n        [\"=\", [\"get\", [\"get\", \"item\", \"@metadata\"], \"@status\"], \"@active\"],\n        [\"&gt;\", [\"get\", \"item\", \"@score\"], 80]\n      ],\n      {\n        \"@id\": [\"get\", \"item\", \"@id\"],\n        \"@result\": [\"*\", [\"get\", \"item\", \"@score\"], 1.1]\n      },\n      null\n    ]\n  ],\n  [\"filter\", \n    [\"lambda\", [\"x\"], [\"not\", [\"is-null\", \"x\"]]],\n    items\n  ]\n]\n</code></pre>"},{"location":"architecture/json-operations-design/#with-json-operations","title":"With JSON Operations","text":"<pre><code>// Clear, maintainable, and expressive\n[\"transform\",\n  [\"where\", items,\n    [\"@and\",\n      [\"@metadata.status\", \"@=\", \"@active\"],\n      [\"@score\", \"@&gt;\", 80]\n    ]\n  ],\n  [\"@pick\", \"@id\", \"@score\"],\n  [\"@apply\", \"@score\", [\"lambda\", [\"s\"], [\"*\", \"s\", 1.1]]],\n  [\"@rename\", \"@score\", \"@result\"]\n]\n</code></pre>"},{"location":"architecture/json-operations-design/#integration-with-jsl","title":"Integration with JSL","text":"<p>These operations integrate seamlessly with JSL's existing features:</p> <ul> <li>Functional composition: Use with <code>map</code>, <code>filter</code>, <code>reduce</code></li> <li>Lambda expressions: Mix declarative and functional styles</li> <li>Immutability: All operations preserve JSL's immutable semantics</li> <li>Serialization: Operations and their results remain JSON-serializable</li> <li>Network-native: Perfect for distributed data processing</li> </ul>"},{"location":"architecture/json-operations-design/#references","title":"References","text":"<ul> <li>dotsuite - Original inspiration for these patterns</li> <li>jq - Command-line JSON processor</li> <li>JSONPath - XPath for JSON</li> <li>SQL/JSON - SQL extensions for JSON</li> </ul>"},{"location":"architecture/network/","title":"Network Transparency","text":""},{"location":"architecture/network/#overview","title":"Overview","text":"<p>Network transparency is one of JSL's defining characteristics - the ability to seamlessly transmit, store, and execute code across network boundaries with the same fidelity as local execution. This capability is fundamental to JSL's design and enables new patterns in distributed computing.</p>"},{"location":"architecture/network/#what-is-network-transparency","title":"What is Network Transparency?","text":"<p>Network transparency means that code can be:</p> <ol> <li>Serialized into a universal format (JSON)</li> <li>Transmitted over any network transport</li> <li>Stored in any JSON-compatible storage system</li> <li>Reconstructed in a different runtime environment</li> <li>Executed with identical behavior to the original</li> </ol> <p>This creates a programming model where the physical location of code execution becomes an implementation detail rather than a fundamental constraint.</p>"},{"location":"architecture/network/#technical-foundation","title":"Technical Foundation","text":""},{"location":"architecture/network/#json-as-universal-representation","title":"JSON as Universal Representation","text":"<p>JSL achieves network transparency by using JSON as the canonical representation for both code and data.</p> <pre><code>// This JSL function can be transmitted anywhere JSON is supported\n[\"lambda\", [\"x\"], [\"*\", \"x\", \"x\"]]\n</code></pre> <p>Advantages: - Universal parsing: Every major platform supports JSON - Human readable: Code can be inspected and understood - Schema validation: Structure can be verified - Version stable: JSON specification is stable and backward compatible</p>"},{"location":"architecture/network/#closure-serialization","title":"Closure Serialization","text":"<p>JSL's closure serialization ensures that functions retain their behavior across network boundaries.</p> <pre><code>// Original environment: x = 10\n[\"lambda\", [\"y\"], [\"+\", \"x\", \"y\"]]\n\n// Serialized with captured environment:\n{\n  \"type\": \"closure\",\n  \"params\": [\"y\"],\n  \"body\": [\"+\", \"x\", \"y\"],\n  \"env\": {\"x\": 10}\n}\n</code></pre>"},{"location":"architecture/network/#network-transport-patterns","title":"Network Transport Patterns","text":""},{"location":"architecture/network/#request-response-pattern","title":"Request-Response Pattern","text":"<pre><code>Client                    Server\n  |                         |\n  |------ JSL Function ----&gt;|\n  |                         |\n  |&lt;----- JSON Result ------|\n  |                         |\n</code></pre> <p>Example of sending a computation to a server:</p> <pre><code>{\n  \"code\": [\"map\", [\"lambda\", [\"x\"], [\"*\", \"x\", 2]], [1, 2, 3, 4]],\n  \"data\": {}\n}\n</code></pre> <p>And receiving the result:</p> <pre><code>{\"result\": [2, 4, 6, 8]}\n</code></pre>"},{"location":"architecture/network/#code-migration-pattern","title":"Code Migration Pattern","text":"<pre><code>Runtime A                 Runtime B\n  |                         |\n  |-- Serialize Closure ---&gt;|\n  |                         |\n  |                         |-- Execute --&gt;\n  |                         |\n  |&lt;-- Return Result -------|\n</code></pre>"},{"location":"architecture/network/#distributed-pipeline-pattern","title":"Distributed Pipeline Pattern","text":"<pre><code>Data Source -&gt; JSL Stage 1 -&gt; JSL Stage 2 -&gt; JSL Stage 3 -&gt; Result\n    |             |             |             |\n    |             |             |             |\nNetwork A     Network B     Network C     Network D\n</code></pre>"},{"location":"architecture/network/#storage-transparency","title":"Storage Transparency","text":"<p>JSL code can be stored in any system that supports JSON:</p>"},{"location":"architecture/network/#database-storage","title":"Database Storage","text":"<pre><code>-- Store JSL functions in database\nCREATE TABLE jsl_functions (\n  id SERIAL PRIMARY KEY,\n  name VARCHAR(255),\n  code JSONB,\n  created_at TIMESTAMP\n);\n\n-- Insert JSL function\nINSERT INTO jsl_functions (name, code) VALUES (\n  'square',\n  '[\"lambda\", [\"x\"], [\"*\", \"x\", \"x\"]]'::JSONB\n);\n</code></pre>"},{"location":"architecture/network/#file-system-storage","title":"File System Storage","text":"<pre><code>// functions/math.jsl\n{\n  \"square\": [\"lambda\", [\"x\"], [\"*\", \"x\", \"x\"]],\n  \"cube\": [\"lambda\", [\"x\"], [\"*\", \"x\", \"x\", \"x\"]],\n  \"factorial\": [\"lambda\", [\"n\"], \n    [\"if\", [\"&lt;=\", \"n\", 1], \n     1, \n     [\"*\", \"n\", [\"factorial\", [\"-\", \"n\", 1]]]]]\n}\n</code></pre>"},{"location":"architecture/network/#distributed-storage","title":"Distributed Storage","text":"<pre><code>// Configuration for distributed JSL library\n{\n  \"repositories\": [\n    \"https://jsllib.example.com/math\",\n    \"https://jsllib.example.com/string\",\n    \"https://jsllib.example.com/data\"\n  ],\n  \"cache\": {\n    \"local\": \"/tmp/jsl-cache\",\n    \"ttl\": 3600\n  }\n}\n</code></pre>"},{"location":"architecture/network/#implementation-strategies","title":"Implementation Strategies","text":""},{"location":"architecture/network/#eager-loading","title":"Eager Loading","text":"<pre><code>// Load all dependencies upfront\n{\n  \"main\": [\"do\", \n    [\"use\", \"math/statistics\"],\n    [\"mean\", [1, 2, 3, 4, 5]]\n  ],\n  \"dependencies\": {\n    \"math/statistics\": {\n      \"mean\": [\"lambda\", [\"xs\"], [\"quotient\", [\"sum\", \"xs\"], [\"length\", \"xs\"]]],\n      \"sum\": [\"lambda\", [\"xs\"], [\"reduce\", \"+\", 0, \"xs\"]]\n    }\n  }\n}\n</code></pre>"},{"location":"architecture/network/#lazy-loading","title":"Lazy Loading","text":"<pre><code>// Load dependencies on demand\n{\n  \"main\": [\"do\",\n    [\"import\", \"https://jsllib.com/math/statistics.jsl\"],\n    [\"mean\", [1, 2, 3, 4, 5]]\n  ]\n}\n</code></pre>"},{"location":"architecture/network/#caching-strategies","title":"Caching Strategies","text":"<pre><code>// Cache configuration\n{\n  \"cache_policy\": {\n    \"strategy\": \"content_hash\",\n    \"ttl\": 86400,\n    \"max_size\": \"100MB\",\n    \"locations\": [\n      \"memory\",\n      \"disk\",\n      \"distributed\"\n    ]\n  }\n}\n</code></pre>"},{"location":"architecture/network/#network-protocols","title":"Network Protocols","text":""},{"location":"architecture/network/#http-transport","title":"HTTP Transport","text":"<pre><code>POST /jsl/execute HTTP/1.1\nContent-Type: application/json\n\n{\n  \"code\": [\"host\", \"http/get\", \"https://api.example.com/data\"],\n  \"timeout\": 30000\n}\n</code></pre>"},{"location":"architecture/network/#websocket-transport","title":"WebSocket Transport","text":"<pre><code>// Real-time JSL execution\n{\n  \"type\": \"execute\",\n  \"id\": \"req-123\",\n  \"code\": [\"stream-map\", [\"lambda\", [\"x\"], [\"inc\", \"x\"]], \"input-stream\"]\n}\n</code></pre>"},{"location":"architecture/network/#message-queue-transport","title":"Message Queue Transport","text":"<pre><code>// Queue: jsl-tasks\n{\n  \"task_id\": \"task-456\",\n  \"code\": [\"batch-process\", \"data-batch-1\"],\n  \"priority\": \"high\",\n  \"retry_count\": 3\n}\n</code></pre>"},{"location":"architecture/network/#performance-considerations","title":"Performance Considerations","text":""},{"location":"architecture/network/#bandwidth-optimization","title":"Bandwidth Optimization","text":"<ol> <li>Code Compression</li> <li>JSON compression (gzip, brotli)</li> <li>Code minification (remove whitespace)</li> <li> <p>Delta compression (send only changes)</p> </li> <li> <p>Caching</p> </li> <li>Function memoization</li> <li>Code artifact caching</li> <li> <p>Network-level caching</p> </li> <li> <p>Batching</p> </li> <li>Multiple operations in single request</li> <li>Pipeline optimization</li> <li>Bulk data transfer</li> </ol>"},{"location":"architecture/network/#latency-optimization","title":"Latency Optimization","text":"<ol> <li>Preloading</li> <li>Predictive code loading</li> <li>Warm caches</li> <li> <p>Connection pooling</p> </li> <li> <p>Locality</p> </li> <li>Edge computing deployment</li> <li>Regional code distribution</li> <li>Data locality optimization</li> </ol>"},{"location":"architecture/network/#security-considerations","title":"Security Considerations","text":""},{"location":"architecture/network/#transport-security","title":"Transport Security","text":"<ul> <li>Encryption: TLS for all network transport</li> <li>Authentication: Verify code sources</li> <li>Integrity: Hash verification of transmitted code</li> </ul>"},{"location":"architecture/network/#code-validation","title":"Code Validation","text":"<ul> <li>Schema validation: Verify JSON structure</li> <li>Security scanning: Detect malicious patterns</li> <li>Resource limits: Prevent resource exhaustion</li> </ul>"},{"location":"architecture/network/#access-control","title":"Access Control","text":"<ul> <li>Code signing: Cryptographic verification</li> <li>Capability restrictions: Limit available operations</li> <li>Audit logging: Track all code execution</li> </ul>"},{"location":"architecture/network/#use-cases","title":"Use Cases","text":""},{"location":"architecture/network/#distributed-computing","title":"Distributed Computing","text":"<pre><code>// Send computation to data location\n{\n  \"target\": \"data-center-eu\",\n  \"code\": [\"analyze-user-behavior\", \"european-users\"],\n  \"resources\": {\"cpu\": \"4-cores\", \"memory\": \"8GB\"}\n}\n</code></pre>"},{"location":"architecture/network/#edge-computing","title":"Edge Computing","text":"<pre><code>// Deploy logic to edge devices\n{\n  \"targets\": [\"edge-device-*\"],\n  \"code\": [\"if\", [\"sensor-reading\", \"&gt;\", 100], \n    [\"alert\", \"temperature-high\"],\n    null\n  ]\n}\n</code></pre>"},{"location":"architecture/network/#database-functions","title":"Database Functions","text":"<pre><code>-- Execute JSL directly in database\nSELECT jsl_execute('[\"group-by\", \"status\", \"orders\"]', orders_table);\n</code></pre>"},{"location":"architecture/network/#microservice-communication","title":"Microservice Communication","text":"<pre><code>// Service A requests computation from Service B\n{\n  \"service\": \"analytics-service\",\n  \"function\": [\"lambda\", [\"data\"], [\"statistical-summary\", \"data\"]],\n  \"data\": {...}\n}\n</code></pre> <p>Network transparency fundamentally changes how we think about distributed computing, making code mobility as natural as data mobility and enabling new architectures that were previously impractical or impossible.</p>"},{"location":"architecture/performance/","title":"JSL Performance Philosophy","text":""},{"location":"architecture/performance/#the-spectrum-of-optimization","title":"The Spectrum of Optimization","text":"<p>JSL's postfix representation could be further optimized into raw primitives:</p> <pre><code>Current postfix:     [2, 3, \"+\", 4, \"*\"]\nCould become:        [PUSH_INT, 2, PUSH_INT, 3, ADD, PUSH_INT, 4, MUL]\nOr even:            [0x12, 0x02, 0x12, 0x03, 0x20, 0x12, 0x04, 0x21]\n</code></pre>"},{"location":"architecture/performance/#why-we-dont","title":"Why We Don't","text":"<p>We deliberately keep the postfix representation as JSON-compatible values rather than raw bytecode because:</p>"},{"location":"architecture/performance/#1-network-transparency","title":"1. Network Transparency","text":"<pre><code>// This can be sent over HTTP, stored in databases, inspected by humans\n[10, 20, \"+\", 100, 50, \"-\", \"*\"]\n\n// This is opaque binary data\n[0x0A, 0x14, 0x20, 0x64, 0x32, 0x22, 0x21]\n</code></pre>"},{"location":"architecture/performance/#2-debugging-introspection","title":"2. Debugging &amp; Introspection","text":"<p>Our postfix is self-documenting: <pre><code>[2, 3, \"+\"]  # Obviously: 2 + 3\n[0x02, 0x03, 0x20]  # What does this mean?\n</code></pre></p>"},{"location":"architecture/performance/#3-universal-serialization","title":"3. Universal Serialization","text":"<p>JSON works everywhere - browsers, databases, message queues, REST APIs. Binary formats require custom parsers and version management.</p>"},{"location":"architecture/performance/#4-the-real-bottleneck","title":"4. The Real Bottleneck","text":"<p>For 99% of distributed computing tasks, the bottleneck isn't instruction dispatch but: - Network latency (100,000x slower than CPU) - Database queries (10,000x slower) - Serialization/deserialization - Coordination overhead</p>"},{"location":"architecture/performance/#5-mobility-over-speed","title":"5. Mobility Over Speed","text":"<p>JSL prioritizes computation mobility over raw performance: <pre><code># This is our superpower - pause here, resume there\nstate = {\n    \"stack\": [30, 100],\n    \"code\": [50, \"-\", \"*\"],\n    \"pc\": 2\n}\n# Can be sent to any machine, stored, inspected, modified\n</code></pre></p>"},{"location":"architecture/performance/#when-you-need-real-speed","title":"When You Need Real Speed","text":"<p>If you need maximum performance:</p> <ol> <li>Wrong tool: JSL isn't for high-performance computing</li> <li>Use native code: C++, Rust, or assembly for hot paths</li> <li>JIT compilation: Compile hot JSL functions to native code</li> <li>Hybrid approach: JSL for coordination, native for computation</li> </ol> <pre><code># JSL for orchestration\n[\"parallel-map\", \n  [\"native-function\", \"fast_matrix_multiply\"],\n  large_dataset]\n\n# Where fast_matrix_multiply is implemented in C++\n</code></pre>"},{"location":"architecture/performance/#the-8020-rule","title":"The 80/20 Rule","text":"<p>80% of your code runs 20% of the time. JSL is perfect for that 80%: - Configuration - Orchestration - Business logic - Data transformation - API endpoints</p> <p>The other 20% that needs speed? Call out to native code.</p>"},{"location":"architecture/performance/#educational-value","title":"Educational Value","text":"<p>Showing the progression of representations teaches important lessons:</p> <pre><code>Mathematical:    (\u03bb (x) (\u00d7 x x))\n    \u2193\nS-expression:    (lambda (x) (* x x))\n    \u2193\nJSON:           [\"lambda\", [\"x\"], [\"*\", \"x\", \"x\"]]\n    \u2193\nPostfix:        [\"x\", \"x\", \"*\", (\"lambda\", 1)]\n    \u2193\nBytecode:       [LOAD_VAR, 0, LOAD_VAR, 0, MUL, MAKE_CLOSURE, 1]\n    \u2193\nAssembly:       mov eax, [ebp-4]; mov ebx, [ebp-4]; imul eax, ebx\n    \u2193\nMachine code:   8B 45 FC 8B 5D FC 0F AF C3\n</code></pre> <p>Each level trades human-readability for machine-efficiency. JSL stops at the postfix level because:</p> <ol> <li>It's still JSON - universally readable</li> <li>It's resumable - can pause/resume execution</li> <li>It's portable - works on any platform</li> <li>It's inspectable - can debug and understand</li> <li>It's fast enough - for distributed/networked computing</li> </ol>"},{"location":"architecture/performance/#the-jsl-philosophy","title":"The JSL Philosophy","text":"<p>\"Make it work, make it right, make it mobile.  If you still need to make it fast, you're using the wrong tool.\"</p> <p>JSL is about moving computation, not optimizing cycles. It's about expressing ideas clearly, not squeezing out nanoseconds. It's about universal computation, not platform-specific performance.</p>"},{"location":"architecture/performance/#conclusion","title":"Conclusion","text":"<p>Could we compile JSL to raw bytecode? Yes. Should we? No.</p> <p>The JSON-based postfix representation is the sweet spot: - Fast enough for real work - Clear enough for debugging - Portable enough for the network - Simple enough for implementation</p> <p>If you need more speed than JSL provides, you don't need a faster JSL - you need a different language for that component. JSL's job is to coordinate, not to compete with C++.</p> <p>Remember: Premature optimization is the root of all evil (Knuth), and in distributed systems, the network is the computer (Sun Microsystems). JSL embraces both principles.</p>"},{"location":"architecture/philosophy/","title":"Design Philosophy","text":""},{"location":"architecture/philosophy/#the-problem-with-traditional-code-mobility","title":"The Problem with Traditional Code Mobility","text":"<p>Modern distributed systems require seamless code mobility\u2014the ability to send executable code across network boundaries, store it in databases, and reconstruct it in different runtime environments. Traditional approaches face fundamental challenges:</p>"},{"location":"architecture/philosophy/#1-serialization-complexity","title":"1. Serialization Complexity","text":"<p>Most languages require complex serialization frameworks (e.g., pickle, protobuf) that are brittle, version-dependent, and often insecure.</p>"},{"location":"architecture/philosophy/#2-runtime-dependencies","title":"2. Runtime Dependencies","text":"<p>Serialized code often depends on specific runtime versions, libraries, or execution contexts that may not be available on the receiving end.</p>"},{"location":"architecture/philosophy/#3-security-vulnerabilities","title":"3. Security Vulnerabilities","text":"<p>Deserializing code can execute arbitrary instructions, creating significant attack vectors.</p>"},{"location":"architecture/philosophy/#4-platform-lock-in","title":"4. Platform Lock-in","text":"<p>Serialization formats are often language-specific, preventing cross-platform code sharing.</p>"},{"location":"architecture/philosophy/#the-jsl-solution","title":"The JSL Solution","text":"<p>JSL solves these problems by making JSON the native representation for both data and code. This design enables powerful properties for network-native programming. The core language is purely functional and safe, while interactions with the host system are reified as data and controlled through a programmable, capability-based environment model.</p>"},{"location":"architecture/philosophy/#theoretical-foundations","title":"Theoretical Foundations","text":""},{"location":"architecture/philosophy/#homoiconicity","title":"Homoiconicity","text":"<p>Like classic Lisps, JSL is homoiconic, meaning code and data share the same representation. However, instead of S-expressions, JSL uses JSON\u2014a universally supported and standardized format.</p> <p>Key Benefits:</p> <ul> <li>No Parsing Ambiguity: JSON has a precise, standardized grammar.</li> <li>Universal Tooling: Every major language and platform can handle JSON.</li> <li>Network Transparency: Valid JSON travels safely across all network protocols.</li> <li>Human Readability: Code can be inspected and modified with standard text tools.</li> </ul>"},{"location":"architecture/philosophy/#verifiable-serializable-state","title":"Verifiable, Serializable State","text":"<p>Handling closures (functions that capture their lexical environment) is a primary challenge in code mobility. JSL solves this with a content-addressable storage model that elegantly handles circular references and makes program state verifiable, efficient, and safely serializable.</p> <ul> <li>Content-Addressable Objects: Every complex object (closure or environment) is identified by a unique hash of its contents. Objects are stored in a hash table and referenced by their content hashes, naturally handling circular references.</li> <li>Serializable Closures: A closure is serialized as a JSON object containing its parameters, body, and a reference to its captured environment. The environment reference uses the content-addressable format <code>{\"__ref__\": \"hash\"}</code>.</li> <li>Efficient Sharing: Identical objects share the same hash, avoiding duplication and creating an efficient storage model for complex object graphs.</li> <li>Format Versioning: The serialized payload includes <code>__cas_version__</code> to enable format evolution while maintaining backward compatibility.</li> </ul> <p>This architecture ensures that a serialized JSL program can handle arbitrarily complex object relationships while remaining a verifiable, self-contained unit of computation.</p>"},{"location":"architecture/philosophy/#wire-format-transparency","title":"Wire-Format Transparency","text":"<p>Every JSL value can be serialized to JSON and reconstructed identically in any compliant runtime. This enables:</p> <ul> <li>Database Storage: Store executable code with ACID properties.</li> <li>HTTP Transmission: Send functions using standard web infrastructure.</li> <li>Cross-Language Interoperability: Leverage JSON's universal support.</li> <li>Audit Trails: Create reproducible records of code execution.</li> <li>Version Control: Use standard JSON diff/merge tools to manage code.</li> </ul>"},{"location":"architecture/philosophy/#practical-applications","title":"Practical Applications","text":""},{"location":"architecture/philosophy/#1-distributed-computing","title":"1. Distributed Computing","text":"<p>Send computations to where data resides, rather than moving data.</p> <pre><code>[\"lambda\", [\"data\"], \n  [\"filter\", \n    [\"lambda\", [\"record\"], [\"=\", [\"get\", \"record\", \"status\"], \"active\"]], \n    \"data\"]]\n</code></pre>"},{"location":"architecture/philosophy/#2-edge-computing","title":"2. Edge Computing","text":"<p>Deploy and update logic on edge devices dynamically.</p> <pre><code>[\"lambda\", [\"sensor_reading\"],\n  [\"if\", [\"&gt;\", \"sensor_reading\", 75],\n    [\"send-alert\", \"High temperature detected\"],\n    [\"log\", \"Normal reading:\", \"sensor_reading\"]]]\n</code></pre>"},{"location":"architecture/philosophy/#3-database-functions","title":"3. Database Functions","text":"<p>Store and execute business logic directly in databases.</p> <pre><code>[\"lambda\", [\"user_id\", \"new_status\"],\n  [\"host\", \"db/update\", \"users\", \n    {\"id\": \"user_id\"}, \n    {\"$set\": {\"status\": \"new_status\"}}]]\n</code></pre>"},{"location":"architecture/philosophy/#sicp-inspired-design","title":"SICP-Inspired Design","text":"<p>JSL follows the elegant principles outlined in \"Structure and Interpretation of Computer Programs\":</p> <ul> <li>Simplicity: Everything is built from a small set of primitives (atoms, lists, functions).</li> <li>Composability: Complex operations are created by combining simple ones.</li> <li>Abstraction: Higher-level concepts are built on lower-level foundations.</li> <li>Uniformity: A consistent evaluation model applies throughout the language.</li> <li>Extensibility: New capabilities are added through composition, not special cases.</li> </ul> <p>This approach creates a language that is both theoretically elegant and practically useful for distributed computing.</p>"},{"location":"architecture/runtime/","title":"Runtime Architecture","text":""},{"location":"architecture/runtime/#overview","title":"Overview","text":"<p>The JSL ecosystem is designed as a layered architecture that separates concerns and ensures both security and portability. Understanding these layers is crucial for implementing JSL systems and reasoning about code execution.</p>"},{"location":"architecture/runtime/#architecture-layers","title":"Architecture Layers","text":"<p>The JSL runtime can be conceptualized in six distinct layers:</p>"},{"location":"architecture/runtime/#1-wire-layer-json","title":"1. Wire Layer (JSON)","text":"<p>The universal representation for JSL programs, data, and serialized closures. This is what gets transmitted over networks or stored in databases.</p> <p>Characteristics: - Standard JSON format - Universal compatibility - Human-readable - Version-independent - Platform-agnostic</p>"},{"location":"architecture/runtime/#2-jsl-runtimeinterpreter","title":"2. JSL Runtime/Interpreter","text":"<p>The core execution engine that processes JSL code:</p>"},{"location":"architecture/runtime/#parser","title":"Parser","text":"<ul> <li>Converts JSON into internal JSL abstract syntax</li> <li>Validates JSON structure against JSL grammar</li> <li>Handles syntax errors and malformed input</li> </ul>"},{"location":"architecture/runtime/#evaluator","title":"Evaluator","text":"<ul> <li>Executes JSL code based on language semantics</li> <li>Handles special forms (<code>def</code>, <code>lambda</code>, <code>if</code>, <code>do</code>, <code>host</code>, etc.)</li> <li>Manages function applications and argument evaluation</li> <li>Implements lexical scoping rules</li> </ul>"},{"location":"architecture/runtime/#environment-manager","title":"Environment Manager","text":"<ul> <li>Manages lexical environments and scope resolution</li> <li>Handles variable binding and lookup</li> <li>Maintains environment chains for closures</li> <li>Supports environment serialization/deserialization</li> </ul>"},{"location":"architecture/runtime/#3-prelude-layer","title":"3. Prelude Layer","text":"<p>A foundational environment provided by the host runtime containing built-in functions and constants.</p> <p>Key Properties: - Contains essential computational primitives (arithmetic, logic, list operations) - Not serialized with user code - Expected to be available in any compliant JSL runtime - Can be customized or extended by host implementations - Serves as the computational foundation for user programs</p> <p>Examples: - Arithmetic operations: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> - Comparison operators: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>=</code> - List operations: <code>map</code>, <code>filter</code>, <code>reduce</code> - Type predicates: <code>null?</code>, <code>number?</code>, <code>string?</code></p>"},{"location":"architecture/runtime/#4-user-code-layer","title":"4. User Code Layer","text":"<p>JSL programs and libraries written by developers. These are fully serializable and portable.</p> <p>Characteristics: - Complete JSON serializability - Closure capture and reconstruction - Cross-runtime portability - Environment independence (beyond prelude)</p>"},{"location":"architecture/runtime/#5-host-interaction-layer-jhip","title":"5. Host Interaction Layer (JHIP)","text":"<p>When a JSL program evaluates a <code>[\"host\", ...]</code> form, it generates a JHIP (JSL Host Interaction Protocol) request. This layer manages the interface between pure JSL computation and external effects.</p> <p>Key Features: - Effect reification as data structures - Request-response protocol - Host authority over permitted operations - Audit trail capability - Security boundary</p>"},{"location":"architecture/runtime/#6-host-environment","title":"6. Host Environment","text":"<p>The runtime system that executes JSL code, manages resources, and enforces security policies.</p> <p>Responsibilities: - JSL interpreter hosting - JHIP request processing - Resource management - Security policy enforcement - Capability provisioning</p>"},{"location":"architecture/runtime/#serialization-architecture","title":"Serialization Architecture","text":"<p>A critical aspect of JSL's runtime architecture is its serialization system:</p>"},{"location":"architecture/runtime/#closure-serialization","title":"Closure Serialization","text":"<p>JSL <code>Closure</code> objects store: - Function parameters - Function body - Captured lexical environment (only user-defined variables)</p> <p>Serialization Process: 1. Identify free variables in closure body 2. Extract relevant bindings from lexical environment 3. Serialize environment chain (user bindings only) 4. Exclude prelude bindings (reconstructed at runtime)</p>"},{"location":"architecture/runtime/#environment-serialization","title":"Environment Serialization","text":"<p>Environments (<code>Env</code> objects) are serialized as: - Dictionary of name-to-value mappings - Parent environment reference (if applicable) - Only user-defined bindings included</p> <p>Reconstruction Process: 1. Recreate environment hierarchy 2. Restore user-defined bindings 3. Link to appropriate prelude environment 4. Validate binding completeness</p>"},{"location":"architecture/runtime/#security-model","title":"Security Model","text":"<p>JSL's architecture provides security through multiple layers:</p>"},{"location":"architecture/runtime/#capability-restriction","title":"Capability Restriction","text":"<ul> <li>All side effects must go through JHIP</li> <li>Host controls available operations</li> <li>Fine-grained permission model</li> </ul>"},{"location":"architecture/runtime/#code-safety","title":"Code Safety","text":"<ul> <li>No native code execution</li> <li>JSON-based representation prevents code injection</li> <li>Deterministic evaluation (in pure subset)</li> </ul>"},{"location":"architecture/runtime/#effect-reification","title":"Effect Reification","text":"<ul> <li>Side effects are described as data</li> <li>Host can inspect, audit, or modify requests</li> <li>Clear separation between computation and effects</li> </ul>"},{"location":"architecture/runtime/#sandboxing","title":"Sandboxing","text":"<ul> <li>JSL programs run within interpreter bounds</li> <li>No direct system access</li> <li>Host-mediated resource access only</li> </ul>"},{"location":"architecture/runtime/#implementation-considerations","title":"Implementation Considerations","text":""},{"location":"architecture/runtime/#performance","title":"Performance","text":"<ul> <li>JSON parsing overhead</li> <li>Environment lookup chains</li> <li>Closure reconstruction costs</li> <li>JHIP communication latency</li> </ul>"},{"location":"architecture/runtime/#memory-management","title":"Memory Management","text":"<ul> <li>Environment retention for closures</li> <li>Garbage collection of unused environments</li> <li>Serialization memory overhead</li> </ul>"},{"location":"architecture/runtime/#error-handling","title":"Error Handling","text":"<ul> <li>JSON parsing errors</li> <li>Runtime evaluation errors</li> <li>JHIP communication failures</li> <li>Host capability denials</li> </ul>"},{"location":"architecture/runtime/#deployment-patterns","title":"Deployment Patterns","text":""},{"location":"architecture/runtime/#distributed-computing","title":"Distributed Computing","text":"<pre><code>Client Runtime -&gt; JSON Code -&gt; Remote Runtime -&gt; Results\n</code></pre>"},{"location":"architecture/runtime/#database-functions","title":"Database Functions","text":"<pre><code>Application -&gt; Stored JSL -&gt; Database -&gt; Executed Results\n</code></pre>"},{"location":"architecture/runtime/#microservice-communication","title":"Microservice Communication","text":"<pre><code>Service A -&gt; JSL Function -&gt; Service B -&gt; Response\n</code></pre>"},{"location":"architecture/runtime/#edge-computing","title":"Edge Computing","text":"<pre><code>Central Control -&gt; JSL Logic -&gt; Edge Devices -&gt; Local Execution\n</code></pre> <p>This layered architecture ensures JSL maintains its core properties of safety, portability, and network-nativity while providing the flexibility needed for diverse deployment scenarios.</p>"},{"location":"architecture/security/","title":"Security Model","text":""},{"location":"architecture/security/#overview","title":"Overview","text":"<p>JSL's security model is built on the principle of effect reification and capability restriction. Unlike traditional languages where security is layered on top, JSL's design makes security an intrinsic property of the language itself.</p>"},{"location":"architecture/security/#core-security-principles","title":"Core Security Principles","text":"<ul> <li>No Arbitrary Code Execution: JSL code is data. This eliminates entire classes of vulnerabilities like buffer overflows and direct system calls.</li> <li>Effect Reification: All side effects are represented as data (e.g., <code>[\"host\", \"file/read\", ...]</code>). This makes them auditable, controllable, and transparent before execution.</li> <li>Host Authority: The host environment has complete control over what operations are permitted.</li> </ul>"},{"location":"architecture/security/#jsls-layered-security-model","title":"JSL's Layered Security Model","text":"<p>JSL provides two complementary models for managing security and side effects.</p>"},{"location":"architecture/security/#level-1-dispatcher-based-security-the-standard-model","title":"Level 1: Dispatcher-Based Security (The Standard Model)","text":"<p>This is the most direct security model. The host system implements a Host Command Dispatcher that is the ultimate gatekeeper for all side effects. It is simple to understand and makes all side effects syntactically obvious.</p>"},{"location":"architecture/security/#level-2-capability-based-security-the-advanced-model","title":"Level 2: Capability-Based Security (The Advanced Model)","text":"<p>This is a more advanced model for high-security applications. It uses the Environment Algebra and closures to create sandboxes that can restrict access to the <code>[\"host\", ...]</code> special form itself, providing a deeper layer of defense.</p>"},{"location":"architecture/security/#the-runtime-boundary","title":"The Runtime Boundary","text":"<p>JSL code always executes within the confines of the JSL runtime, which is itself controlled by the host system. All interactions with the outside world must cross this boundary through the JHIP protocol, giving the host the final say.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502             Host System             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502        JSL Runtime            \u2502  \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u2502\n\u2502  \u2502  \u2502     User JSL Code       \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502                         \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  All computation here   \u2502  \u2502  \u2502\n\u2502  \u2502  \u2502  is safe and contained  \u2502  \u2502  \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2502\n\u2502  \u2502                               \u2502  \u2502  \n\u2502  \u2502  Effects must go through JHIP \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                     \u2502\n\u2502  Host controls all external access  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/security/#security-best-practices","title":"Security Best Practices","text":""},{"location":"architecture/security/#for-host-implementations","title":"For Host Implementations","text":""},{"location":"architecture/security/#1-enforce-strict-resource-limits-the-gas-model","title":"1. Enforce Strict Resource Limits (The \"Gas\" Model)","text":"<p>Untrusted code can easily attempt to cause a Denial of Service. The host runtime must enforce resource limits.</p> <p>The most straightforward way to do this is to wrap every JSL evaluation in a strict timeout. This is the host's primary defense against infinite loops and other denial-of-service attacks.</p> <p>For more granular control, a host can implement a \"gas\" model, similar to those used in blockchain systems.</p> <ul> <li>How it works: The host assigns a \"gas cost\" to every JSL operation (e.g., <code>+</code> costs 1 gas, <code>map</code> costs 5 gas). A program is started with a finite amount of gas, which is consumed on each operation. If the gas runs out, execution halts.</li> <li>Benefits: This provides a predictable execution cost that is independent of machine speed.</li> </ul> <p>At a minimum, hosts should enforce simple timeouts and memory caps.</p>"},{"location":"architecture/security/#design-note-why-gas-is-a-host-level-concern","title":"Design Note: Why Gas is a Host-Level Concern","text":"<p>A natural question is why a \"gas\" model is not a mandatory, built-in part of the JSL language specification. This is a deliberate architectural decision based on JSL's core design philosophy.</p> <ul> <li> <p>To Maximize Simplicity and Portability: The primary goal of the JSL core is to be a simple, elegant, and easily embeddable evaluation engine. Forcing a complex gas accounting system into the language specification would dramatically increase the implementation burden. This would make it much harder to create compliant runtimes in different languages, undermining the goal of portability.</p> </li> <li> <p>To Maintain Flexibility: Different host environments have vastly different needs. A web server might manage resources via per-request timeouts, while a blockchain requires a strict, deterministic gas model. By defining gas as a host-level best practice rather than a language requirement, JSL remains flexible enough to be integrated naturally into any of these contexts without imposing a one-size-fits-all solution.</p> </li> </ul> <p>Keeping resource management at the host level preserves the simplicity of the core language while still providing a clear and robust pattern for building secure, production-ready systems.</p>"},{"location":"architecture/security/#2-implement-the-principle-of-least-capability","title":"2. Implement the Principle of Least Capability","text":"<p>When designing host commands, always expose the most specific, narrowly-scoped capability possible. Avoid creating general-purpose \"escape hatches.\"</p> <p>A good example is a specific, auditable capability for reading a config file: <pre><code>[\"def\", \"config\", [\"host\", \"file/read\", \"/app/data/config.json\"]]\n</code></pre></p> <p>A dangerous, overly broad capability would be: <pre><code>[\"def\", \"config\", [\"host\", \"shell\", \"cat /app/data/config.json\"]]\n</code></pre> A specific command like <code>file/read</code> can be easily secured and audited by the host dispatcher. A <code>shell</code> command is a black box that subverts JSL's security model.</p>"},{"location":"architecture/security/#3-maintain-detailed-audit-logs","title":"3. Maintain Detailed Audit Logs","text":"<p>Because all side effects are reified as data, the host can create a perfect audit trail. Every <code>[\"host\", ...]</code> request should be logged with a timestamp, the source of the code, the full request, and the outcome. This is invaluable for security analysis and incident response.</p>"},{"location":"architecture/security/#for-jsl-code-developers","title":"For JSL Code Developers","text":""},{"location":"architecture/security/#1-never-trust-input","title":"1. Never Trust Input","text":"<p>Just as in any other language, you must treat all data coming from an external source as untrusted.</p> <p>This example shows a function that expects a number for a calculation. It validates the input's type before using it. <pre><code>[\"def\", \"calculate\",\n  [\"lambda\", [\"input\"],\n    [\"if\", [\"is_num\", \"input\"],\n      [\"*\", \"input\", 10],\n      [\"error\", \"InvalidInput\", \"Expected a number\"]\n    ]\n  ]\n]\n</code></pre> Always validate the type and structure of data before using it in your logic.</p>"},{"location":"architecture/security/#2-handle-errors-gracefully","title":"2. Handle Errors Gracefully","text":"<p>Host commands can fail for many reasons. Robust JSL code should anticipate these failures using the <code>try</code> special form.</p> <p>This example attempts to read a configuration file, but returns a default value if it fails, logging the error as a warning. <pre><code>[\"try\",\n  [\"host\", \"file/read\", \"/app/config.json\"],\n  [\"lambda\", [\"err\"],\n    [\"do\",\n      [\"host\", \"log/warn\", [\"@\", \"Config not found, using default: \", [\"get\", \"err\", \"message\"]]],\n      { \"default_setting\": true }\n    ]\n  ]\n]\n</code></pre> This prevents unexpected host errors from crashing your entire program.</p>"},{"location":"architecture/serialization/","title":"Code and Data Serialization","text":"<p>For a conceptual overview of JSL environments and the operations you can perform on them, see the Environments language guide.</p>"},{"location":"architecture/serialization/#overview","title":"Overview","text":"<p>Serialization is fundamental to JSL's design philosophy. Since JSL code is JSON, any JSL program is already in a transmittable format. However, to capture the full, executable state of a program\u2014including functions with captured lexical environments (closures)\u2014JSL uses a content-addressable serialization format.</p> <p>This structure enables true code mobility, persistence, and robust distributed computing patterns while handling circular references elegantly.</p>"},{"location":"architecture/serialization/#content-addressable-serialization-format","title":"Content-Addressable Serialization Format","text":"<p>JSL uses a content-addressable serialization format where each unique object gets a deterministic hash based on its content. When a JSL value is serialized, the payload includes three key parts:</p> <ol> <li><code>__cas_version__</code>: Version number of the content-addressable serialization format (currently 1).</li> <li><code>objects</code>: A key-value map where each key is the content-hash of a complex object (closure or environment), and the value is the object itself. This is the \"object store.\"</li> <li><code>root</code>: The root value of the serialization. If it's a complex object, it will reference an object by its hash using <code>{\"__ref__\": \"hash\"}</code>.</li> </ol>"},{"location":"architecture/serialization/#complex-object-structure","title":"Complex Object Structure","text":"<p>Environment Objects represent scopes and have the structure: - <code>__type__</code>: Always <code>\"env\"</code> to identify the object type - <code>bindings</code>: A JSON object mapping variable names to their values (which may include references to other objects)</p> <p>Closure Objects represent functions and have the structure: - <code>__type__</code>: Always <code>\"closure\"</code> to identify the object type - <code>params</code>: List of parameter names - <code>body</code>: The function body as a JSL expression - <code>env</code>: Reference to the captured environment (may be <code>{\"__ref__\": \"hash\"}</code>)</p> <p>The hash of each object is calculated over its content, creating a stable identifier. Objects that reference each other use the <code>{\"__ref__\": \"hash\"}</code> format, which allows the deserializer to reconstruct the object graph correctly.</p>"},{"location":"architecture/serialization/#serialization-walkthrough","title":"Serialization Walkthrough","text":"<p>Consider this simple closure example: <pre><code>[\"do\",\n  [\"def\", \"base\", 100],\n  [\"lambda\", [\"x\"], [\"+\", \"x\", \"base\"]]\n]\n</code></pre></p> <p>When evaluated, this produces a closure that captures the <code>base</code> variable. The serialized payload might look like this: <pre><code>{\n  \"__cas_version__\": 1,\n  \"root\": {\"__ref__\": \"a1b2c3d4e5f6g7h8\"},\n  \"objects\": {\n    \"a1b2c3d4e5f6g7h8\": {\n      \"__type__\": \"closure\",\n      \"params\": [\"x\"],\n      \"body\": [\"+\", \"x\", \"base\"],\n      \"env\": {\"__ref__\": \"h8g7f6e5d4c3b2a1\"}\n    },\n    \"h8g7f6e5d4c3b2a1\": {\n      \"__type__\": \"env\",\n      \"bindings\": {\n        \"base\": 100\n      }\n    }\n  }\n}\n</code></pre></p> <p>For primitive values (numbers, strings, booleans, simple arrays/objects), the serialization is direct JSON without the CAS wrapper: <pre><code>// Simple values serialize directly\n42              \u2192 \"42\"\n[1, 2, 3]      \u2192 \"[1,2,3]\"\n{\"key\": \"val\"} \u2192 \"{\\\"key\\\":\\\"val\\\"}\"\n</code></pre></p> <p>This content-addressable model efficiently handles circular references, avoids data duplication, and correctly represents complex object relationships in a purely serializable way.</p>"},{"location":"architecture/serialization/#serialization-patterns","title":"Serialization Patterns","text":"<p>The following patterns demonstrate how the canonical serialized state payload can be used.</p>"},{"location":"architecture/serialization/#network-transmission","title":"Network Transmission","text":"<p>The serialized payload can be sent directly as the body of an HTTP request to a remote JSL node for execution.</p> <pre><code>POST /execute HTTP/1.1\nContent-Type: application/json\n\n{\n  \"__cas_version__\": 1,\n  \"root\": {\"__ref__\": \"a1b2c3d4e5f6g7h8\"},\n  \"objects\": {\n    \"a1b2c3d4e5f6g7h8\": {\n      \"__type__\": \"closure\",\n      \"params\": [\"x\"],\n      \"body\": [\"+\", \"x\", \"base\"],\n      \"env\": {\"__ref__\": \"h8g7f6e5d4c3b2a1\"}\n    },\n    \"h8g7f6e5d4c3b2a1\": {\n      \"__type__\": \"env\",\n      \"bindings\": {\"base\": 100}\n    }\n  }\n}\n</code></pre>"},{"location":"architecture/serialization/#code-storage","title":"Code Storage","text":"<p>The entire payload can be stored in a database (e.g., in a JSONB column) to persist a function, a user's workflow state, or a configuration template.</p> <pre><code>INSERT INTO jsl_functions (name, payload) VALUES (\n  'increment_function',\n  '{\n    \"__cas_version__\": 1,\n    \"root\": {\"__ref__\": \"a1b2c3d4e5f6g7h8\"},\n    \"objects\": {\n      \"a1b2c3d4e5f6g7h8\": {\n        \"__type__\": \"closure\",\n        \"params\": [\"x\"],\n        \"body\": [\"+\", \"x\", \"base\"],\n        \"env\": {\"__ref__\": \"h8g7f6e5d4c3b2a1\"}\n      },\n      \"h8g7f6e5d4c3b2a1\": {\n        \"__type__\": \"env\",\n        \"bindings\": {\"base\": 100}\n      }\n    }\n  }'::JSONB\n);\n</code></pre>"},{"location":"architecture/serialization/#object-serialization","title":"Object Serialization","text":"<p>JSON objects with embedded code serialize cleanly:</p> <pre><code>{\n  \"response_object\": {\n    \"@status\": \"@success\",\n    \"@user\": \"username\",\n    \"@computed_score\": [\"*\", \"base_score\", \"multiplier\"],\n    \"@timestamp\": [\"host\", \"time/now\"]\n  }\n}\n</code></pre> <p>When evaluated, this produces a pure JSON object with all expressions resolved.</p>"},{"location":"architecture/serialization/#conclusion","title":"Conclusion","text":"<p>JSL's serialization model is designed for simplicity, efficiency, and portability. By leveraging JSON as the underlying format, JSL ensures that code can be easily transmitted, stored, and executed across different environments without loss of fidelity or context.</p>"},{"location":"architecture/stack-evaluation/","title":"Stack-Based Evaluation in JSL","text":""},{"location":"architecture/stack-evaluation/#overview","title":"Overview","text":"<p>JSL now supports two evaluation strategies: 1. Recursive evaluation - Traditional tree-walking interpreter (simple but limited) 2. Stack-based evaluation - Compiles to postfix bytecode for efficient execution</p>"},{"location":"architecture/stack-evaluation/#why-stack-based-evaluation","title":"Why Stack-Based Evaluation?","text":""},{"location":"architecture/stack-evaluation/#limitations-of-recursive-evaluation","title":"Limitations of Recursive Evaluation","text":"<p>The recursive evaluator in <code>jsl/core.py</code> has several fundamental limitations:</p> <ol> <li> <p>No true resumption: When resources are exhausted mid-recursion, we can only capture the top-level expression. The computation restarts from the beginning, making no progress.</p> </li> <li> <p>Stack overflow risk: Deep recursion can exceed Python's call stack limit.</p> </li> <li> <p>Difficult optimization: Each node visit involves function calls and environment lookups.</p> </li> <li> <p>Imprecise resource tracking: Hard to track exact costs mid-recursion.</p> </li> </ol>"},{"location":"architecture/stack-evaluation/#advantages-of-stack-based-evaluation","title":"Advantages of Stack-Based Evaluation","text":"<ol> <li> <p>Perfect resumption: Save the stack and program counter, resume exactly where you left off.</p> </li> <li> <p>No recursion limits: Uses a data stack, not the call stack.</p> </li> <li> <p>Optimization opportunities: Postfix bytecode can be optimized, cached, and analyzed.</p> </li> <li> <p>Network-friendly: Postfix arrays are more compact than S-expressions for transmission.</p> </li> <li> <p>Clear execution model: Each instruction is atomic and predictable.</p> </li> <li> <p>JSON all the way down: Even the paused execution state (stack, PC, environment) is pure JSON - no binary formats, no special serialization.</p> </li> </ol>"},{"location":"architecture/stack-evaluation/#architecture","title":"Architecture","text":""},{"location":"architecture/stack-evaluation/#compilation-pipeline","title":"Compilation Pipeline","text":"<pre><code>S-Expression \u2192 Compiler \u2192 Postfix \u2192 Stack Evaluator \u2192 Result\n['+', 2, 3]  \u2192          \u2192 [2,3,'+'] \u2192               \u2192 5\n</code></pre>"},{"location":"architecture/stack-evaluation/#key-components","title":"Key Components","text":"<ul> <li><code>jsl/compiler.py</code>: Converts S-expressions to postfix notation</li> <li><code>jsl/stack_evaluator.py</code>: Executes postfix using a value stack</li> <li><code>jsl/eval_modes.py</code>: Unified interface for both evaluators</li> </ul>"},{"location":"architecture/stack-evaluation/#n-arity-handling","title":"N-Arity Handling","text":"<p>For operators with variable arity (0 \u2264 n &lt; \u221e), we encode arity explicitly:</p> <pre><code>['+']           \u2192 [('+', 0)]      # 0-arity: sum() = 0\n['+', 5]        \u2192 [5, ('+', 1)]    # 1-arity: 5\n['+', 1, 2, 3]  \u2192 [1, 2, 3, ('+', 3)]  # n-arity: 1+2+3\n</code></pre>"},{"location":"architecture/stack-evaluation/#usage-examples","title":"Usage Examples","text":""},{"location":"architecture/stack-evaluation/#basic-evaluation","title":"Basic Evaluation","text":"<pre><code>from jsl.compiler import compile_to_postfix\nfrom jsl.stack_evaluator import StackEvaluator\n\n# Compile S-expression to postfix\nexpr = ['*', ['+', 2, 3], 4]\npostfix = compile_to_postfix(expr)  # [2, 3, '+', 4, '*']\n\n# Evaluate\nevaluator = StackEvaluator()\nresult = evaluator.eval(postfix)  # 20\n</code></pre>"},{"location":"architecture/stack-evaluation/#resumable-evaluation","title":"Resumable Evaluation","text":"<pre><code># Execute with limited steps (simulating resource limits)\nexpr = ['*', ['+', 10, 20], ['-', 100, 50]]\npostfix = compile_to_postfix(expr)\n\nevaluator = StackEvaluator()\nresult, state = evaluator.eval_partial(postfix, max_steps=2)\n# result = None, state contains stack and pc\n\n# Resume later\nresult, state = evaluator.eval_partial(postfix, max_steps=10, state=state)\n# result = 1500, state = None (complete)\n</code></pre>"},{"location":"architecture/stack-evaluation/#unified-interface","title":"Unified Interface","text":"<pre><code>from jsl.eval_modes import JSLEvaluator, EvalMode\n\n# Use recursive evaluator (default)\neval1 = JSLEvaluator(mode=EvalMode.RECURSIVE)\nresult = eval1.eval(['+', 2, 3])  # 5\n\n# Use stack evaluator\neval2 = JSLEvaluator(mode=EvalMode.STACK)\nresult = eval2.eval(['+', 2, 3])  # 5\n\n# Both produce identical results!\n</code></pre>"},{"location":"architecture/stack-evaluation/#postfix-as-primary-representation","title":"Postfix as Primary Representation","text":"<p>In distributed/networked scenarios, postfix can become the primary code representation:</p> <pre><code># Instead of sharing S-expressions:\nsend_over_network(['+', [1, 2], [3, 4]])  # Nested structure\n\n# Share postfix directly:\nsend_over_network([1, 2, '+', 3, 4, '+', '+'])  # Flat array\n</code></pre> <p>Benefits: - More compact (flat array vs nested) - No parsing ambiguity - Direct execution without compilation - Trivial serialization</p>"},{"location":"architecture/stack-evaluation/#resumable-execution-state","title":"Resumable Execution State","text":"<p>The stack evaluator can pause and resume execution at any point. The paused state is pure JSON:</p> <pre><code>{\n  \"stack\": [10, 20],\n  \"pc\": 2,\n  \"instructions\": [10, 20, 2, \"+\", 5, 2, \"*\"],\n  \"resource_checkpoint\": {\n    \"gas_used\": 150,\n    \"steps_taken\": 2\n  },\n  \"user_env\": {\n    \"x\": 42,\n    \"my-func\": {\n      \"type\": \"closure\",\n      \"params\": [\"n\"],\n      \"body\": [\"*\", \"n\", \"x\"],\n      \"env\": {\"x\": 42}\n    }\n  }\n}\n</code></pre> <p>This represents: - stack: Current operand stack values - pc: Program counter (next instruction to execute) - instructions: The JPN bytecode being executed - resource_checkpoint: Optional resource tracking state - user_env: User-defined variables and functions (not the prelude)</p> <p>The separation between user environment and prelude means: - User-defined state travels with the paused execution - The prelude (built-in functions) exists on every JSL host - State can be stored, transmitted, and resumed anywhere - Everything remains pure JSON - no binary formats or special serialization</p> <p>Example resumable execution with user-defined functions: <pre><code># Define a user function\nevaluator.env['double'] = {\n    'type': 'closure',\n    'params': ['x'],\n    'body': ['*', 'x', 2],\n    'env': {}\n}\n\n# Compile program that uses it\njpn = compile_to_postfix(['double', 21])  # =&gt; [21, 1, 'double']\n\n# Start execution with limited steps\nresult, state = evaluator.eval_partial(jpn, max_steps=1)\n\nif state:  # Execution paused\n    # State includes user-defined 'double' function\n    # Everything is pure JSON - can be stored/transmitted\n    json_state = json.dumps(state.to_dict())\n\n    # Later, possibly on a different machine\n    # Create fresh evaluator with only prelude\n    fresh_evaluator = StackEvaluator(env=prelude.to_dict())\n\n    # Restore state (including user environment)\n    restored_state = StackState.from_dict(json.loads(json_state))\n\n    # Resume execution - 'double' function is available!\n    final_result, _ = fresh_evaluator.eval_partial(jpn, max_steps=100, state=restored_state)\n    # final_result = 42\n</code></pre></p> <p>No binary formats, no special protocols - just JSON! User-defined functions travel with the paused state.</p>"},{"location":"architecture/stack-evaluation/#testing","title":"Testing","text":"<p>The same test suite runs on both evaluators, proving functional equivalence:</p> <pre><code># tests/test_both_evaluators.py\n@pytest.fixture(params=[RecursiveEvaluator, StackEvaluator])\ndef evaluator(request):\n    return request.param()\n\ndef test_arithmetic(evaluator):\n    assert evaluator.eval(['+', 2, 3]) == 5\n    # This test runs twice - once per evaluator!\n</code></pre>"},{"location":"architecture/stack-evaluation/#future-work","title":"Future Work","text":"<ol> <li>Unify with recursive evaluator: Use the same Env and Closure classes for consistency</li> <li>Optimize postfix: Dead code elimination, constant folding</li> <li>JIT compilation: Compile hot paths to native code</li> <li>Streaming evaluation: Process postfix as it arrives over network</li> <li>Parallel execution: Some postfix sequences can run in parallel</li> <li>Tail call optimization: Detect and optimize tail-recursive calls</li> </ol>"},{"location":"architecture/stack-evaluation/#conclusion","title":"Conclusion","text":"<p>Stack-based evaluation provides a production-ready alternative to recursive evaluation, with better resumption, optimization opportunities, and network characteristics. The postfix representation can serve as JSL's \"bytecode\" - the actual computational format, with S-expressions as the human-friendly source language.</p>"},{"location":"examples/advanced/","title":"Advanced JSL Examples","text":""},{"location":"examples/advanced/#distributed-computing","title":"Distributed Computing","text":"<p>This example demonstrates a map-reduce implementation for word counting.</p> <pre><code>[\"let\", [\n  [\"map-reduce\",\n    [\"lambda\", [\"data\", \"map-fn\", \"reduce-fn\"],\n      [\"let\", [[\"mapped\", [\"map\", \"map-fn\", \"data\"]]],\n        [\"reduce\", \"reduce-fn\", {}, \"mapped\"]]]],\n\n  [\"word-count\",\n    [\"lambda\", [\"text\"],\n      [\"let\", [\n        [\"words\", [\"str-split\", [\"str-lower\", \"text\"], \"@ \"]],\n        [\"count-word\", \n          [\"lambda\", [\"acc\", \"word\"],\n            [\"set\", \"acc\", \"word\", \n              [\"+\", [\"get\", \"acc\", \"word\", 0], 1]]]]\n      ],\n        [\"reduce\", \"count-word\", {}, \"words\"]]]]\n],\n  [\"word-count\", \"@The quick brown fox jumps over the lazy dog\"]\n]\n</code></pre>"},{"location":"examples/advanced/#closure-serialization","title":"Closure Serialization","text":"<p>This example shows how a closure can be serialized to JSON, then deserialized and executed.</p> <pre><code>[\"let\", [\n  [\"create-adder\",\n    [\"lambda\", [\"n\"],\n      [\"lambda\", [\"x\"], [\"+\", \"x\", \"n\"]]]],\n\n  [\"add-five\", [\"create-adder\", 5]],\n  [\"serialized\", [\"serialize\", \"add-five\"]],\n  [\"restored\", [\"deserialize\", \"serialized\"]]\n],\n  [\"restored\", 10]\n]\n</code></pre> <p>Result: <code>15</code> - The closure maintains its captured environment even after serialization.</p>"},{"location":"examples/advanced/#dynamic-configuration-objects","title":"Dynamic Configuration Objects","text":"<p>Build configuration objects that adapt based on environment settings.</p> <pre><code>[\"let\", [\n  [\"env\", \"@production\"],\n  [\"is-prod\", [\"=\", \"env\", \"@production\"]],\n  [\"db-host\", [\"if\", \"is-prod\", \"@db.prod.example.com\", \"@localhost\"]]\n],\n  {\n    \"@database\": {\n      \"@host\": \"db-host\",\n      \"@port\": [\"if\", \"is-prod\", 5432, 5433],\n      \"@name\": [\"str-concat\", \"@myapp_\", \"env\"],\n      \"@ssl\": \"is-prod\",\n      \"@pool_size\": [\"if\", \"is-prod\", 20, 5]\n    },\n    \"@services\": {\n      \"@auth\": {\n        \"@url\": [\"str-concat\", \"@https://auth.\", \"env\", \"@.example.com\"],\n        \"@timeout\": [\"if\", \"is-prod\", 5000, 30000]\n      },\n      \"@cache\": {\n        \"@enabled\": \"is-prod\",\n        \"@ttl\": [\"if\", \"is-prod\", 3600, 300]\n      }\n    }\n  }\n]\n</code></pre>"},{"location":"examples/advanced/#memoization-pattern","title":"Memoization Pattern","text":"<p>Create a memoized version of expensive computations.</p> <pre><code>[\"let\", [\n  [\"memoize\",\n    [\"lambda\", [\"fn\"],\n      [\"let\", [[\"cache\", {}]],\n        [\"lambda\", [\"arg\"],\n          [\"let\", [[\"key\", [\"str\", \"arg\"]]],\n            [\"if\", [\"has\", \"cache\", \"key\"],\n              [\"get\", \"cache\", \"key\"],\n              [\"let\", [[\"result\", [\"fn\", \"arg\"]]],\n                [\"do\",\n                  [\"set\", \"cache\", \"key\", \"result\"],\n                  \"result\"]]]]]]]],\n\n  [\"fibonacci\",\n    [\"lambda\", [\"n\"],\n      [\"if\", [\"&lt;=\", \"n\", 1],\n        \"n\",\n        [\"+\", \n          [\"fibonacci\", [\"-\", \"n\", 1]], \n          [\"fibonacci\", [\"-\", \"n\", 2]]]]]],\n\n  [\"fast-fib\", [\"memoize\", \"fibonacci\"]]\n],\n  [\"map\", \"fast-fib\", [\"@\", [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]]\n]\n</code></pre>"},{"location":"examples/advanced/#pipeline-processing","title":"Pipeline Processing","text":"<p>Build a data processing pipeline with error handling.</p> <pre><code>[\"let\", [\n  [\"pipeline\",\n    [\"lambda\", [\"data\", \"transformations\"],\n      [\"reduce\",\n        [\"lambda\", [\"acc\", \"transform\"],\n          [\"try\",\n            [\"transform\", \"acc\"],\n            [\"lambda\", [\"err\"],\n              {\"@error\": true, \n               \"@message\": [\"get\", \"err\", \"@message\"],\n               \"@data\": \"acc\"}]]],\n        \"data\",\n        \"transformations\"]]],\n\n  [\"validate-user\",\n    [\"lambda\", [\"user\"],\n      [\"if\", [\"and\",\n              [\"has\", \"user\", \"@email\"],\n              [\"str-contains\", [\"get\", \"user\", \"@email\"], \"@@\"]],\n        \"user\",\n        [\"error\", \"@Invalid email\"]]]],\n\n  [\"enrich-user\",\n    [\"lambda\", [\"user\"],\n      [\"set\", \"user\", \"@id\", \n        [\"str-concat\", \"@user_\", [\"str\", [\"random-int\", 1000, 9999]]]]]],\n\n  [\"user-data\", {\"@name\": \"@Alice\", \"@email\": \"@alice@example.com\"}]\n],\n  [\"pipeline\", \"user-data\", [\"@\", [\"validate-user\", \"enrich-user\"]]]\n]\n</code></pre>"},{"location":"examples/advanced/#key-advanced-patterns","title":"Key Advanced Patterns","text":"<ol> <li>Map-Reduce - Process large datasets in a functional way</li> <li>Closure Serialization - Send functions with their context over the network</li> <li>Dynamic Objects - Build configuration that adapts to runtime conditions</li> <li>Memoization - Cache expensive computations transparently</li> <li>Pipeline Processing - Chain transformations with error handling</li> </ol>"},{"location":"examples/group-by/","title":"Group By Examples","text":"<p>This page demonstrates how to use JSL's <code>group-by</code> function for data aggregation and analysis.</p>"},{"location":"examples/group-by/#basic-grouping","title":"Basic Grouping","text":""},{"location":"examples/group-by/#group-by-single-field","title":"Group by Single Field","text":"<pre><code>(def sales [@\n  {\"product\": \"Laptop\", \"category\": \"Electronics\", \"amount\": 1200}\n  {\"product\": \"Phone\", \"category\": \"Electronics\", \"amount\": 800}\n  {\"product\": \"Shirt\", \"category\": \"Clothing\", \"amount\": 50}\n  {\"product\": \"Jeans\", \"category\": \"Clothing\", \"amount\": 80}\n])\n\n; Group by category\n(group-by sales \"@category\")\n; Result: [\n;   [{\"product\": \"Laptop\", \"category\": \"Electronics\", \"amount\": 1200},\n;    {\"product\": \"Phone\", \"category\": \"Electronics\", \"amount\": 800}],\n;   [{\"product\": \"Shirt\", \"category\": \"Clothing\", \"amount\": 50},\n;    {\"product\": \"Jeans\", \"category\": \"Clothing\", \"amount\": 80}]\n; ]\n</code></pre>"},{"location":"examples/group-by/#group-with-custom-key-function","title":"Group with Custom Key Function","text":"<pre><code>(def orders [@\n  {\"id\": 1, \"date\": \"2024-01-15\", \"total\": 150}\n  {\"id\": 2, \"date\": \"2024-01-15\", \"total\": 200}\n  {\"id\": 3, \"date\": \"2024-01-16\", \"total\": 100}\n])\n\n; Group by date\n(group-by orders \"@date\")\n\n; Group by price range\n(group-by orders \n  (lambda (order)\n    (if (&lt; (get order \"@total\") 150) \"@low\" \"@high\")))\n</code></pre>"},{"location":"examples/group-by/#aggregation-after-grouping","title":"Aggregation After Grouping","text":""},{"location":"examples/group-by/#calculate-group-statistics","title":"Calculate Group Statistics","text":"<pre><code>(def employees [@\n  {\"name\": \"Alice\", \"department\": \"Engineering\", \"salary\": 120000}\n  {\"name\": \"Bob\", \"department\": \"Engineering\", \"salary\": 110000}\n  {\"name\": \"Charlie\", \"department\": \"Sales\", \"salary\": 90000}\n  {\"name\": \"Diana\", \"department\": \"Sales\", \"salary\": 95000}\n])\n\n; Calculate average salary by department\n(map\n  (group-by employees \"@department\")\n  (lambda (group)\n    {\"@department\": (get (first group) \"@department\"),\n     \"@count\": (length group),\n     \"@avgSalary\": (/ (sum (pluck group \"@salary\")) (length group)),\n     \"@totalSalary\": (sum (pluck group \"@salary\"))}))\n\n; Result: [\n;   {\"department\": \"Engineering\", \"count\": 2, \"avgSalary\": 115000, \"totalSalary\": 230000},\n;   {\"department\": \"Sales\", \"count\": 2, \"avgSalary\": 92500, \"totalSalary\": 185000}\n; ]\n</code></pre>"},{"location":"examples/group-by/#find-group-extremes","title":"Find Group Extremes","text":"<pre><code>(def products [@\n  {\"name\": \"Product A\", \"category\": \"tools\", \"price\": 25, \"rating\": 4.5}\n  {\"name\": \"Product B\", \"category\": \"tools\", \"price\": 35, \"rating\": 4.8}\n  {\"name\": \"Product C\", \"category\": \"books\", \"price\": 15, \"rating\": 4.2}\n  {\"name\": \"Product D\", \"category\": \"books\", \"price\": 20, \"rating\": 4.9}\n])\n\n; Find best rated product in each category\n(map\n  (group-by products \"@category\")\n  (lambda (group)\n    (let (best (reduce \n                 (lambda (acc item)\n                   (if (&gt; (get item \"@rating\") (get acc \"@rating\"))\n                       item acc))\n                 (first group)\n                 (rest group)))\n      {\"@category\": (get best \"@category\"),\n       \"@bestProduct\": (get best \"@name\"),\n       \"@rating\": (get best \"@rating\")})))\n</code></pre>"},{"location":"examples/group-by/#complex-grouping-scenarios","title":"Complex Grouping Scenarios","text":""},{"location":"examples/group-by/#multi-level-grouping","title":"Multi-Level Grouping","text":"<pre><code>(def transactions [@\n  {\"date\": \"2024-01\", \"type\": \"income\", \"category\": \"salary\", \"amount\": 5000}\n  {\"date\": \"2024-01\", \"type\": \"expense\", \"category\": \"rent\", \"amount\": 1500}\n  {\"date\": \"2024-01\", \"type\": \"expense\", \"category\": \"food\", \"amount\": 500}\n  {\"date\": \"2024-02\", \"type\": \"income\", \"category\": \"salary\", \"amount\": 5000}\n  {\"date\": \"2024-02\", \"type\": \"expense\", \"category\": \"rent\", \"amount\": 1500}\n])\n\n; Group by month, then by type\n(map\n  (group-by transactions \"@date\")\n  (lambda (month-group)\n    {\"@month\": (get (first month-group) \"@date\"),\n     \"@types\": (map\n                 (group-by month-group \"@type\")\n                 (lambda (type-group)\n                   {\"@type\": (get (first type-group) \"@type\"),\n                    \"@total\": (sum (pluck type-group \"@amount\")),\n                    \"@count\": (length type-group)}))}))\n</code></pre>"},{"location":"examples/group-by/#grouping-with-filtering","title":"Grouping with Filtering","text":"<pre><code>(def orders [@\n  {\"customer\": \"Alice\", \"status\": \"completed\", \"total\": 150}\n  {\"customer\": \"Bob\", \"status\": \"pending\", \"total\": 200}\n  {\"customer\": \"Alice\", \"status\": \"completed\", \"total\": 100}\n  {\"customer\": \"Charlie\", \"status\": \"cancelled\", \"total\": 75}\n  {\"customer\": \"Bob\", \"status\": \"completed\", \"total\": 300}\n])\n\n; Group completed orders by customer\n(map\n  (group-by \n    (where orders (= status \"@completed\"))\n    \"@customer\")\n  (lambda (group)\n    {\"@customer\": (get (first group) \"@customer\"),\n     \"@orderCount\": (length group),\n     \"@totalSpent\": (sum (pluck group \"@total\"))}))\n</code></pre>"},{"location":"examples/group-by/#real-world-examples","title":"Real-World Examples","text":""},{"location":"examples/group-by/#sales-report","title":"Sales Report","text":"<pre><code>(def sales-data [@\n  {\"date\": \"2024-01-15\", \"product\": \"Widget\", \"quantity\": 5, \"price\": 20}\n  {\"date\": \"2024-01-15\", \"product\": \"Gadget\", \"quantity\": 3, \"price\": 50}\n  {\"date\": \"2024-01-16\", \"product\": \"Widget\", \"quantity\": 8, \"price\": 20}\n  {\"date\": \"2024-01-16\", \"product\": \"Gadget\", \"quantity\": 2, \"price\": 50}\n])\n\n; Daily sales summary\n(def daily-summary\n  (map\n    (group-by sales-data \"@date\")\n    (lambda (day-sales)\n      {\"@date\": (get (first day-sales) \"@date\"),\n       \"@totalRevenue\": (sum \n                          (map day-sales \n                            (lambda (s) (* (get s \"@quantity\") \n                                          (get s \"@price\")))))\n       \"@totalUnits\": (sum (pluck day-sales \"@quantity\")),\n       \"@uniqueProducts\": (length (unique (pluck day-sales \"@product\")))})))\n\n; Product performance\n(def product-summary\n  (map\n    (group-by sales-data \"@product\")\n    (lambda (product-sales)\n      {\"@product\": (get (first product-sales) \"@product\"),\n       \"@totalQuantity\": (sum (pluck product-sales \"@quantity\")),\n       \"@totalRevenue\": (sum \n                          (map product-sales\n                            (lambda (s) (* (get s \"@quantity\")\n                                          (get s \"@price\")))))\n       \"@avgQuantityPerSale\": (/ (sum (pluck product-sales \"@quantity\"))\n                                 (length product-sales))})))\n</code></pre>"},{"location":"examples/group-by/#user-activity-analysis","title":"User Activity Analysis","text":"<pre><code>(def activities [@\n  {\"user\": \"alice\", \"action\": \"login\", \"timestamp\": \"2024-01-15T09:00:00\"}\n  {\"user\": \"bob\", \"action\": \"login\", \"timestamp\": \"2024-01-15T09:30:00\"}\n  {\"user\": \"alice\", \"action\": \"purchase\", \"timestamp\": \"2024-01-15T10:00:00\"}\n  {\"user\": \"alice\", \"action\": \"logout\", \"timestamp\": \"2024-01-15T11:00:00\"}\n  {\"user\": \"bob\", \"action\": \"browse\", \"timestamp\": \"2024-01-15T10:00:00\"}\n])\n\n; User activity summary\n(map\n  (group-by activities \"@user\")\n  (lambda (user-activities)\n    {\"@user\": (get (first user-activities) \"@user\"),\n     \"@totalActions\": (length user-activities),\n     \"@actionTypes\": (unique (pluck user-activities \"@action\")),\n     \"@hasPurchased\": (any \n                        (map user-activities\n                          (lambda (a) (= (get a \"@action\") \"@purchase\"))))}))\n</code></pre>"},{"location":"examples/group-by/#error-log-analysis","title":"Error Log Analysis","text":"<pre><code>(def error-logs [@\n  {\"service\": \"api\", \"level\": \"ERROR\", \"code\": 500, \"message\": \"Internal error\"}\n  {\"service\": \"api\", \"level\": \"WARN\", \"code\": 429, \"message\": \"Rate limited\"}\n  {\"service\": \"db\", \"level\": \"ERROR\", \"code\": 1205, \"message\": \"Deadlock\"}\n  {\"service\": \"api\", \"level\": \"ERROR\", \"code\": 500, \"message\": \"Internal error\"}\n  {\"service\": \"auth\", \"level\": \"WARN\", \"code\": 401, \"message\": \"Invalid token\"}\n])\n\n; Error summary by service\n(map\n  (group-by \n    (where error-logs (= level \"@ERROR\"))\n    \"@service\")\n  (lambda (service-errors)\n    {\"@service\": (get (first service-errors) \"@service\"),\n     \"@errorCount\": (length service-errors),\n     \"@uniqueErrors\": (length (unique (pluck service-errors \"@code\"))),\n     \"@errorCodes\": (unique (pluck service-errors \"@code\"))}))\n</code></pre>"},{"location":"examples/group-by/#aggregation-functions","title":"Aggregation Functions","text":"<p>Common aggregation patterns with grouped data:</p> <pre><code>; Sum\n(sum (pluck group \"@amount\"))\n\n; Average\n(/ (sum (pluck group \"@value\")) (length group))\n\n; Min/Max\n(reduce min (first (pluck group \"@price\")) (rest (pluck group \"@price\")))\n(reduce max (first (pluck group \"@score\")) (rest (pluck group \"@score\")))\n\n; Count distinct\n(length (unique (pluck group \"@category\")))\n\n; Concatenate strings\n(str-join \", \" (pluck group \"@name\"))\n</code></pre>"},{"location":"examples/group-by/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Group Early: Group before complex transformations when possible</li> <li>Use Indexes: If available, group by indexed fields</li> <li>Aggregate Incrementally: For large groups, use <code>reduce</code> instead of collecting all values</li> <li>Memory Usage: Be aware that grouping creates sublists in memory</li> </ol>"},{"location":"examples/group-by/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"examples/group-by/#pivot-table","title":"Pivot Table","text":"<pre><code>(def pivot-table\n  (lambda (data row-key col-key value-key)\n    (let (rows (unique (pluck data row-key))\n          cols (unique (pluck data col-key)))\n      (map rows\n        (lambda (row)\n          (merge\n            {row-key: row}\n            (reduce\n              (lambda (acc col)\n                (assoc acc col\n                  (sum (pluck\n                    (where data\n                      (and (= (get it row-key) row)\n                           (= (get it col-key) col)))\n                    value-key))))\n              {}\n              cols)))))))\n\n; Example: Sales by product and month\n(pivot-table sales-data \"@product\" \"@month\" \"@revenue\")\n</code></pre>"},{"location":"examples/group-by/#see-also","title":"See Also","text":"<ul> <li>Query Operations - Filtering with <code>where</code></li> <li>Transform Operations - Data transformation</li> <li>Prelude Functions - Built-in aggregation functions</li> </ul>"},{"location":"examples/practical/","title":"Practical JSL Examples","text":"<p>These examples demonstrate core JSL patterns for real-world programming tasks.</p>"},{"location":"examples/practical/#data-processing","title":"Data Processing","text":""},{"location":"examples/practical/#filtering-and-transforming-lists","title":"Filtering and Transforming Lists","text":"<p>Extract email addresses from active users:</p> <pre><code>[\"let\", [\n  [\"users\", [\"@\", [\n    {\"@name\": \"@Alice\", \"@email\": \"@alice@example.com\", \"@active\": true},\n    {\"@name\": \"@Bob\", \"@email\": \"@bob@example.com\", \"@active\": false},\n    {\"@name\": \"@Charlie\", \"@email\": \"@charlie@example.com\", \"@active\": true}\n  ]]],\n  [\"active-emails\", \n    [\"map\",\n      [\"lambda\", [\"user\"], [\"get\", \"user\", \"@email\"]],\n      [\"filter\",\n        [\"lambda\", [\"user\"], [\"get\", \"user\", \"@active\"]],\n        \"users\"]]]\n],\n  \"active-emails\"\n]\n</code></pre> <p>Result: <code>[\"alice@example.com\", \"charlie@example.com\"]</code></p>"},{"location":"examples/practical/#file-operations","title":"File Operations","text":""},{"location":"examples/practical/#reading-and-processing-a-file","title":"Reading and Processing a File","text":"<p>Read a configuration file and parse it:</p> <pre><code>[\"let\", [\n  [\"config-path\", \"@/app/config.json\"],\n  [\"config\", [\"try\",\n    [\"json-parse\", [\"host\", \"file/read\", \"config-path\"]],\n    [\"lambda\", [\"err\"], \n      {\"@debug\": false, \"@timeout\": 30}]]]\n],\n  [\"get\", \"config\", \"@debug\", false]\n]\n</code></pre> <p>This safely reads a JSON config file with a fallback default if the file doesn't exist.</p>"},{"location":"examples/practical/#dynamic-configuration","title":"Dynamic Configuration","text":""},{"location":"examples/practical/#environment-based-settings","title":"Environment-Based Settings","text":"<p>Build configuration that adapts to the current environment:</p> <pre><code>[\"let\", [\n  [\"env\", \"@production\"],\n  [\"is-prod\", [\"=\", \"env\", \"@production\"]]\n],\n  {\n    \"@app\": \"@my-service\",\n    \"@database\": {\n      \"@host\": [\"if\", \"is-prod\", \"@db.prod.example.com\", \"@localhost\"],\n      \"@port\": 5432,\n      \"@pool_size\": [\"if\", \"is-prod\", 20, 5]\n    },\n    \"@logging\": {\n      \"@level\": [\"if\", \"is-prod\", \"@warn\", \"@debug\"],\n      \"@format\": \"@json\"\n    }\n  }\n]\n</code></pre>"},{"location":"examples/practical/#api-request-with-error-handling","title":"API Request with Error Handling","text":""},{"location":"examples/practical/#safe-http-request","title":"Safe HTTP Request","text":"<p>Fetch user data with proper error handling:</p> <pre><code>[\"let\", [\n  [\"fetch-user\",\n    [\"lambda\", [\"id\"],\n      [\"try\",\n        [\"host\", \"http/get\", [\"str-concat\", \"@/api/users/\", \"id\"]],\n        [\"lambda\", [\"err\"],\n          {\"@error\": true, \"@message\": [\"get\", \"err\", \"@message\"]}]]]]\n],\n  [\"fetch-user\", \"@12345\"]\n]\n</code></pre>"},{"location":"examples/practical/#key-patterns-demonstrated","title":"Key Patterns Demonstrated","text":"<ol> <li><code>let</code> for functional bindings - Clean variable scoping without mutation</li> <li>First-class objects - JSON objects as native data structures  </li> <li>Error handling with <code>try</code> - Graceful failure recovery</li> <li>Higher-order functions - <code>map</code> and <code>filter</code> for data transformation</li> <li>Dynamic values - Computing object properties with expressions</li> </ol>"},{"location":"examples/query-transform/","title":"Query and Transform Examples","text":"<p>This page demonstrates practical examples of using JSL's query and transform operations for data manipulation.</p>"},{"location":"examples/query-transform/#basic-filtering-with-where","title":"Basic Filtering with <code>where</code>","text":""},{"location":"examples/query-transform/#filter-by-single-field","title":"Filter by Single Field","text":"<pre><code>(def users [@\n  {\"name\": \"Alice\", \"age\": 30, \"role\": \"admin\"}\n  {\"name\": \"Bob\", \"age\": 25, \"role\": \"user\"}\n  {\"name\": \"Charlie\", \"age\": 35, \"role\": \"admin\"}\n])\n\n; Get all admins\n(where users (= role \"@admin\"))\n; Result: [{\"name\": \"Alice\", ...}, {\"name\": \"Charlie\", ...}]\n\n; Get users over 30\n(where users (&gt; age 30))\n; Result: [{\"name\": \"Charlie\", \"age\": 35, ...}]\n</code></pre>"},{"location":"examples/query-transform/#complex-conditions","title":"Complex Conditions","text":"<pre><code>; Combine conditions with AND\n(where users (and (= role \"@admin\") (&gt;= age 30)))\n\n; Combine with OR\n(where users (or (= role \"@admin\") (&lt; age 30)))\n\n; Nested conditions\n(where users \n  (and (&gt;= age 25)\n       (or (= role \"@admin\") \n           (= role \"@moderator\"))))\n</code></pre>"},{"location":"examples/query-transform/#data-transformation-with-transform","title":"Data Transformation with <code>transform</code>","text":""},{"location":"examples/query-transform/#reshaping-objects","title":"Reshaping Objects","text":"<pre><code>; Pick specific fields\n(transform users (pick \"@name\" \"@email\"))\n\n; Add computed fields\n(transform products \n  (assign \"@discount\" (* price 0.1)))\n\n; Remove sensitive data\n(transform users (omit \"@password\" \"@ssn\"))\n</code></pre>"},{"location":"examples/query-transform/#working-with-collections","title":"Working with Collections","text":"<pre><code>(def orders [@\n  {\"id\": 1, \"items\": 3, \"price\": 25.00}\n  {\"id\": 2, \"items\": 1, \"price\": 15.00}\n  {\"id\": 3, \"items\": 5, \"price\": 45.00}\n])\n\n; Add total to each order\n(transform orders \n  (assign \"@total\" (* items price)))\n\n; Add shipping cost based on total\n(transform orders\n  (assign \"@shipping\" \n    (if (&gt; (* items price) 30) 0 5)))\n</code></pre>"},{"location":"examples/query-transform/#combining-query-and-transform","title":"Combining Query and Transform","text":""},{"location":"examples/query-transform/#filter-then-transform-pipeline","title":"Filter then Transform Pipeline","text":"<pre><code>(def products [@\n  {\"name\": \"Laptop\", \"price\": 999, \"category\": \"electronics\"}\n  {\"name\": \"Shirt\", \"price\": 29, \"category\": \"clothing\"}\n  {\"name\": \"Phone\", \"price\": 599, \"category\": \"electronics\"}\n  {\"name\": \"Jeans\", \"price\": 59, \"category\": \"clothing\"}\n])\n\n; Get names and prices of expensive electronics\n(transform\n  (where products \n    (and (= category \"@electronics\") \n         (&gt; price 500)))\n  (pick \"@name\" \"@price\"))\n; Result: [{\"name\": \"Laptop\", \"price\": 999}, \n;          {\"name\": \"Phone\", \"price\": 599}]\n</code></pre>"},{"location":"examples/query-transform/#multi-step-pipeline","title":"Multi-Step Pipeline","text":"<pre><code>; 1. Filter active users\n; 2. Add full name field\n; 3. Pick relevant fields\n; 4. Sort by name\n\n(def pipeline\n  (lambda (users)\n    (sort-by\n      (transform\n        (transform\n          (where users (= active true))\n          (assign \"@fullName\" \n            (str-concat firstName \" \" lastName)))\n        (pick \"@fullName\" \"@email\" \"@role\"))\n      \"@fullName\")))\n\n(pipeline all-users)\n</code></pre>"},{"location":"examples/query-transform/#real-world-examples","title":"Real-World Examples","text":""},{"location":"examples/query-transform/#user-management-system","title":"User Management System","text":"<pre><code>; Get admin emails for notifications\n(pluck\n  (where users (and (= role \"@admin\") (= active true)))\n  \"@email\")\n\n; Prepare user data for API response\n(transform users\n  (do\n    (pick \"@id\" \"@username\" \"@email\" \"@created\")\n    (assign \"@type\" \"@user\")\n    (omit \"@internal_id\")))\n</code></pre>"},{"location":"examples/query-transform/#e-commerce-product-catalog","title":"E-Commerce Product Catalog","text":"<pre><code>(def products [@\n  {\"sku\": \"LAP001\", \"name\": \"Laptop Pro\", \"price\": 1299, \n   \"stock\": 5, \"category\": \"computers\"}\n  {\"sku\": \"PHN001\", \"name\": \"SmartPhone X\", \"price\": 899,\n   \"stock\": 0, \"category\": \"phones\"}\n  {\"sku\": \"TAB001\", \"name\": \"Tablet Plus\", \"price\": 599,\n   \"stock\": 12, \"category\": \"tablets\"}\n])\n\n; Get available products with discount\n(transform\n  (where products (&gt; stock 0))\n  (do\n    (assign \"@available\" true)\n    (assign \"@salePrice\" (* price 0.9))\n    (pick \"@sku\" \"@name\" \"@price\" \"@salePrice\" \"@available\")))\n\n; Group products by category with count\n(map\n  (group-by products \"@category\")\n  (lambda (group)\n    {\"@category\": (get (first group) \"@category\"),\n     \"@count\": (length group),\n     \"@totalValue\": (sum (pluck group \"@price\"))}))\n</code></pre>"},{"location":"examples/query-transform/#log-analysis","title":"Log Analysis","text":"<pre><code>(def logs [@\n  {\"timestamp\": \"2024-01-15T10:00:00\", \"level\": \"ERROR\", \n   \"service\": \"auth\", \"message\": \"Login failed\"}\n  {\"timestamp\": \"2024-01-15T10:01:00\", \"level\": \"INFO\",\n   \"service\": \"api\", \"message\": \"Request processed\"}\n  {\"timestamp\": \"2024-01-15T10:02:00\", \"level\": \"ERROR\",\n   \"service\": \"db\", \"message\": \"Connection timeout\"}\n])\n\n; Get error logs from specific services\n(where logs \n  (and (= level \"@ERROR\")\n       (or (= service \"@auth\") \n           (= service \"@db\"))))\n\n; Create error summary\n(transform\n  (where logs (= level \"@ERROR\"))\n  (pick \"@timestamp\" \"@service\" \"@message\"))\n</code></pre>"},{"location":"examples/query-transform/#data-migration","title":"Data Migration","text":"<pre><code>; Transform old format to new format\n(def migrate-user\n  (lambda (old-user)\n    (transform old-user\n      (do\n        ; Rename fields\n        (rename \"@username\" \"@login\")\n        (rename \"@full_name\" \"@displayName\")\n        ; Add new required fields\n        (assign \"@version\" 2)\n        (assign \"@migrated\" true)\n        (assign \"@migratedAt\" (now))\n        ; Remove deprecated fields\n        (omit \"@legacy_id\" \"@old_status\")))))\n\n; Migrate all users\n(map users migrate-user)\n</code></pre>"},{"location":"examples/query-transform/#performance-tips","title":"Performance Tips","text":"<ol> <li>Filter Early: Apply <code>where</code> before <code>transform</code> to reduce data size</li> <li>Combine Operations: Use <code>do</code> to batch multiple transformations</li> <li>Use Specific Picks: <code>pick</code> is faster than <code>omit</code> for selecting few fields</li> <li>Leverage Indexes: When available, filter on indexed fields first</li> </ol>"},{"location":"examples/query-transform/#common-patterns","title":"Common Patterns","text":""},{"location":"examples/query-transform/#pagination","title":"Pagination","text":"<pre><code>(def paginate\n  (lambda (data page size)\n    (let (start (* page size)\n          end (+ start size))\n      (slice data start end))))\n\n; Get page 2 with 10 items per page\n(paginate \n  (where products (= category \"@electronics\"))\n  2 10)\n</code></pre>"},{"location":"examples/query-transform/#search","title":"Search","text":"<pre><code>(def search-products\n  (lambda (products query)\n    (where products\n      (or (str-contains (str-lower name) (str-lower query))\n          (str-contains (str-lower description) (str-lower query))))))\n\n(search-products all-products \"@laptop\")\n</code></pre>"},{"location":"examples/query-transform/#validation","title":"Validation","text":"<pre><code>(def valid-users\n  (where users\n    (and (not (null email))\n         (str-matches email \"@^[\\\\w\\\\.-]+@[\\\\w\\\\.-]+\\\\.\\\\w+$\")\n         (&gt;= age 18)\n         (in role [\"@admin\" \"@user\" \"@guest\"]))))\n</code></pre>"},{"location":"examples/query-transform/#see-also","title":"See Also","text":"<ul> <li>Query Operations - Detailed <code>where</code> documentation</li> <li>Transform Operations - Detailed <code>transform</code> documentation</li> <li>Path Navigation - Deep JSON access</li> <li>Group By Examples - Grouping and aggregation</li> </ul>"},{"location":"examples/simple/","title":"Simple JSL Examples","text":""},{"location":"examples/simple/#basic-arithmetic","title":"Basic Arithmetic","text":"<pre><code>// Addition\n[\"+\", 5, 3]\n// Result: 8\n\n// Multiplication  \n[\"*\", 4, 6]\n// Result: 24\n\n// Nested operations\n[\"+\", [\"*\", 2, 3], [\"*\", 4, 5]]\n// Result: 26\n</code></pre>"},{"location":"examples/simple/#variables-and-functions","title":"Variables and Functions","text":"<pre><code>// Define and use variables with let\n[\"let\", [\n  [\"x\", 10],\n  [\"y\", 20]\n],\n  [\"+\", \"x\", \"y\"]\n]\n// Result: 30\n\n// Define and use a function\n[\"let\", [\n  [\"double\", [\"lambda\", [\"n\"], [\"*\", \"n\", 2]]]\n],\n  [\"double\", 5]\n]\n// Result: 10\n</code></pre>"},{"location":"examples/simple/#working-with-lists","title":"Working with Lists","text":"<pre><code>// Creating lists with quote\n[\"let\", [\n  [\"numbers\", [\"@\", [1, 2, 3, 4, 5]]],\n  [\"double\", [\"lambda\", [\"x\"], [\"*\", \"x\", 2]]]\n],\n  [\"map\", \"double\", \"numbers\"]\n]\n// Result: [2, 4, 6, 8, 10]\n\n// Creating lists with the list function\n[\"let\", [\n  [\"numbers\", [\"list\", 1, 2, 3, 4, 5]],\n  [\"is-even\", [\"lambda\", [\"x\"], [\"=\", [\"mod\", \"x\", 2], 0]]]\n],\n  [\"filter\", \"is-even\", \"numbers\"]\n]\n// Result: [2, 4]\n</code></pre>"},{"location":"examples/simple/#conditional-logic","title":"Conditional Logic","text":"<pre><code>// Simple if expression\n[\"if\", [\"&gt;\", 10, 5], \"@yes\", \"@no\"]\n// Result: \"yes\"\n\n// Function with conditional logic\n[\"let\", [\n  [\"check-age\", \n    [\"lambda\", [\"age\"],\n      [\"if\", [\"&gt;=\", \"age\", 18], \"@adult\", \"@minor\"]]]\n],\n  [\"list\",\n    [\"check-age\", 25],  // Result: \"adult\"\n    [\"check-age\", 15]   // Result: \"minor\"\n  ]\n]\n</code></pre>"},{"location":"examples/simple/#working-with-objects","title":"Working with Objects","text":"<pre><code>// Create an object with computed values\n[\"let\", [\n  [\"name\", \"@Alice\"],\n  [\"age\", 30]\n],\n  {\"@user\": \"name\", \n   \"@adult\": [\"&gt;=\", \"age\", 18]}\n]\n// Result: {\"user\": \"Alice\", \"adult\": true}\n\n// Access object properties\n[\"let\", [\n  [\"person\", {\"@name\": \"@Bob\", \"@age\": 25}]\n],\n  [\"get\", \"person\", \"@name\"]\n]\n// Result: \"Bob\"\n</code></pre>"},{"location":"jhip/host-commands/","title":"Host Commands","text":""},{"location":"jhip/host-commands/#overview","title":"Overview","text":"<p>JHIP defines the protocol structure for host interactions, but all commands are host-specific and defined by individual host implementations. Each JSL host chooses which commands to support based on their specific environment and use cases. This extensibility allows JSL to integrate with any system while maintaining the security and audit benefits of the JHIP protocol.</p> <p>There are no \"built-in\" or \"standard\" commands - JHIP is purely a communication protocol. However, community conventions have emerged for common operations.</p>"},{"location":"jhip/host-commands/#community-conventions","title":"Community Conventions","text":"<p>While hosts define their own command sets, these naming patterns are commonly used:</p>"},{"location":"jhip/host-commands/#file-system-operations","title":"File System Operations","text":"<pre><code>[\"host\", \"@file/read\", \"@/path/to/file\"]\n[\"host\", \"@file/write\", \"@/path/to/file\", \"@content\"]\n[\"host\", \"@file/exists\", \"@/path/to/file\"]\n[\"host\", \"@file/list\", \"@/path/to/directory\"]\n[\"host\", \"@file/delete\", \"@/path/to/file\"]\n</code></pre>"},{"location":"jhip/host-commands/#http-operations","title":"HTTP Operations","text":"<pre><code>[\"host\", \"@http/get\", \"@https://api.example.com/data\"]\n[\"host\", \"@http/post\", \"@https://api.example.com/submit\", {\"@key\": \"@value\"}]\n[\"host\", \"@http/put\", \"@https://api.example.com/update\", {\"@data\": \"@updated\"}]\n[\"host\", \"@http/delete\", \"@https://api.example.com/item/123\"]\n</code></pre>"},{"location":"jhip/host-commands/#logging-operations","title":"Logging Operations","text":"<pre><code>[\"host\", \"@log/debug\", \"@Debug message\", {\"@context\": \"@additional info\"}]\n[\"host\", \"@log/info\", \"@Application started successfully\"]\n[\"host\", \"@log/warn\", \"@Warning message\"]\n[\"host\", \"@log/error\", \"@Error occurred\", {\"@error_code\": 500}]\n</code></pre>"},{"location":"jhip/host-commands/#system-operations","title":"System Operations","text":"<pre><code>[\"host\", \"@env/get\", \"@PATH\"]\n[\"host\", \"@time/now\"]\n[\"host\", \"@time/format\", \"@2025-01-01T12:00:00Z\", \"@YYYY-MM-DD\"]\n[\"host\", \"@random/uuid\"]\n[\"host\", \"@process/exec\", \"@ls\", [\"@\", [\"@-la\", \"@/tmp\"]]]\n</code></pre>"},{"location":"jhip/host-commands/#database-operations","title":"Database Operations","text":"<pre><code>[\"host\", \"@db/query\", \"@SELECT * FROM users WHERE active = ?\", [\"@\", [true]]]\n[\"host\", \"@db/transaction\", [\"@\", [\n  [\"@INSERT INTO logs (message) VALUES (?)\", [\"@\", [\"@Log entry 1\"]]],\n  [\"@INSERT INTO logs (message) VALUES (?)\", [\"@\", [\"@Log entry 2\"]]]\n]]]\n</code></pre>"},{"location":"jhip/host-commands/#cryptographic-operations","title":"Cryptographic Operations","text":"<pre><code>[\"host\", \"@crypto/hash\", \"@sha256\", \"@data to hash\"]\n[\"host\", \"@crypto/random\", 32]\n</code></pre>"},{"location":"jhip/host-commands/#command-design-principles","title":"Command Design Principles","text":""},{"location":"jhip/host-commands/#naming-conventions","title":"Naming Conventions","text":"<p>Host commands should follow a hierarchical naming structure:</p> <pre><code>&lt;namespace&gt;/&lt;category&gt;/&lt;operation&gt;\n</code></pre> <p>Examples: - <code>myapp/user/create</code> - <code>aws/s3/upload</code> - <code>database/postgres/query</code> - <code>ml/tensorflow/predict</code></p>"},{"location":"jhip/host-commands/#command-categories","title":"Command Categories","text":""},{"location":"jhip/host-commands/#cloud-services","title":"Cloud Services","text":"<pre><code>[\"host\", \"@aws/s3/upload\", \"@bucket-name\", \"@key\", \"data\"]\n[\"host\", \"@gcp/storage/download\", \"@bucket\", \"@object\"]\n[\"host\", \"@azure/blob/delete\", \"@container\", \"@blob-name\"]\n</code></pre>"},{"location":"jhip/host-commands/#machine-learning","title":"Machine Learning","text":"<pre><code>[\"host\", \"@tensorflow/predict\", \"@model-id\", {\"@features\": [\"@\", [1, 2, 3]]}]\n[\"host\", \"@pytorch/train\", \"@model-config\", \"training-data\"]\n</code></pre>"},{"location":"jhip/host-commands/#business-logic","title":"Business Logic","text":"<pre><code>[\"host\", \"@ecommerce/order/create\", {\"@product\": \"@123\", \"@quantity\": 2}]\n[\"host\", \"@crm/contact/update\", \"@contact-id\", {\"@email\": \"@new@example.com\"}]\n</code></pre>"},{"location":"jhip/host-commands/#implementation-guidelines","title":"Implementation Guidelines","text":""},{"location":"jhip/host-commands/#command-handler-interface","title":"Command Handler Interface","text":"<pre><code>class HostCommandHandler:\n    def __init__(self, command_id: str):\n        self.command_id = command_id\n\n    def validate_args(self, args: list) -&gt; bool:\n        \"\"\"Validate command arguments\"\"\"\n        # Implement argument validation\n        pass\n\n    def execute(self, args: list) -&gt; any:\n        \"\"\"Execute the command and return result\"\"\"\n        # Implement command logic\n        pass\n\n    def get_permissions(self) -&gt; list:\n        \"\"\"Return required permissions for this command\"\"\"\n        # Return list of required permissions\n        pass\n</code></pre>"},{"location":"jhip/host-commands/#registration-pattern","title":"Registration Pattern","text":"<pre><code># Register host command handlers\njsl_host.register_command(\"file/read\", FileReadHandler())\njsl_host.register_command(\"http/get\", HttpGetHandler())\njsl_host.register_command(\"myapp/user/create\", UserCreateHandler())\n</code></pre>"},{"location":"jhip/host-commands/#error-handling","title":"Error Handling","text":"<p>All commands must return errors in standard JHIP format:</p> <pre><code>{\n  \"$jsl_error\": {\n    \"type\": \"CommandError\",\n    \"message\": \"File not found\",\n    \"details\": {\n      \"command\": \"file/read\",\n      \"path\": \"/nonexistent/file\"\n    }\n  }\n}\n</code></pre>"},{"location":"jhip/host-commands/#example-command-implementations","title":"Example Command Implementations","text":""},{"location":"jhip/host-commands/#file-read-command","title":"File Read Command","text":"<pre><code>class FileReadHandler(HostCommandHandler):\n    def validate_args(self, args: list) -&gt; bool:\n        return len(args) == 1 and isinstance(args[0], str)\n\n    def execute(self, args: list) -&gt; str:\n        path = args[0]\n        try:\n            with open(path, 'r') as file:\n                return file.read()\n        except FileNotFoundError:\n            return {\n                \"$jsl_error\": {\n                    \"type\": \"FileNotFound\",\n                    \"message\": f\"File does not exist: {path}\",\n                    \"details\": {\"path\": path, \"operation\": \"file/read\"}\n                }\n            }\n        except PermissionError:\n            return {\n                \"$jsl_error\": {\n                    \"type\": \"PermissionDenied\", \n                    \"message\": f\"Permission denied: {path}\",\n                    \"details\": {\"path\": path, \"operation\": \"file/read\"}\n                }\n            }\n\n    def get_permissions(self) -&gt; list:\n        return [\"file.read\"]\n</code></pre>"},{"location":"jhip/host-commands/#http-get-command","title":"HTTP GET Command","text":"<pre><code>import requests\n\nclass HttpGetHandler(HostCommandHandler):\n    def validate_args(self, args: list) -&gt; bool:\n        return len(args) &gt;= 1 and isinstance(args[0], str)\n\n    def execute(self, args: list) -&gt; dict:\n        url = args[0]\n        headers = args[1] if len(args) &gt; 1 else {}\n\n        try:\n            response = requests.get(url, headers=headers, timeout=30)\n            return {\n                \"status\": response.status_code,\n                \"headers\": dict(response.headers),\n                \"body\": response.text\n            }\n        except requests.exceptions.Timeout:\n            return {\n                \"$jsl_error\": {\n                    \"type\": \"NetworkError\",\n                    \"message\": \"Request timeout\",\n                    \"details\": {\"url\": url, \"timeout_ms\": 30000}\n                }\n            }\n        except requests.exceptions.ConnectionError:\n            return {\n                \"$jsl_error\": {\n                    \"type\": \"NetworkError\", \n                    \"message\": \"Connection failed\",\n                    \"details\": {\"url\": url}\n                }\n            }\n\n    def get_permissions(self) -&gt; list:\n        return [\"network.http\"]\n</code></pre>"},{"location":"jhip/host-commands/#custom-business-logic-command","title":"Custom Business Logic Command","text":"<pre><code>class UserCreateHandler(HostCommandHandler):\n    def validate_args(self, args: list) -&gt; bool:\n        if len(args) != 1 or not isinstance(args[0], dict):\n            return False\n\n        user_data = args[0]\n        required_fields = [\"email\", \"name\"]\n        return all(field in user_data for field in required_fields)\n\n    def execute(self, args: list) -&gt; dict:\n        user_data = args[0]\n\n        # Validate email format\n        import re\n        if not re.match(r\"[^@]+@[^@]+\\.[^@]+\", user_data[\"email\"]):\n            return {\n                \"$jsl_error\": {\n                    \"type\": \"ValidationError\",\n                    \"message\": \"Invalid email format\",\n                    \"details\": {\"field\": \"email\", \"value\": user_data[\"email\"]}\n                }\n            }\n\n        # Check for duplicate email\n        if self.email_exists(user_data[\"email\"]):\n            return {\n                \"$jsl_error\": {\n                    \"type\": \"DuplicateError\",\n                    \"message\": \"Email already exists\",\n                    \"details\": {\"field\": \"email\", \"value\": user_data[\"email\"]}\n                }\n            }\n\n        # Create user\n        user_id = self.create_user_in_database(user_data)\n\n        return {\n            \"user_id\": user_id,\n            \"email\": user_data[\"email\"],\n            \"created_at\": datetime.utcnow().isoformat()\n        }\n\n    def get_permissions(self) -&gt; list:\n        return [\"user.create\"]\n</code></pre>"},{"location":"jhip/host-commands/#security-considerations","title":"Security Considerations","text":""},{"location":"jhip/host-commands/#permission-system","title":"Permission System","text":"<pre><code>class PermissionChecker:\n    def check_command_permission(self, command_id: str, user_context: dict) -&gt; bool:\n        # Example permission logic\n        user_permissions = user_context.get(\"permissions\", [])\n\n        # Admin bypass\n        if \"admin\" in user_context.get(\"roles\", []):\n            return True\n\n        # Check specific command permissions\n        if command_id.startswith(\"file/\"):\n            return \"file.access\" in user_permissions\n\n        if command_id.startswith(\"http/\"):\n            return \"network.http\" in user_permissions\n\n        # Custom business logic permissions\n        if command_id.startswith(\"myapp/\"):\n            return f\"myapp.{command_id.split('/')[-1]}\" in user_permissions\n\n        return False\n</code></pre>"},{"location":"jhip/host-commands/#input-validation","title":"Input Validation","text":"<pre><code>def validate_command_args(command_id: str, args: list):\n    \"\"\"Validate arguments for security and correctness\"\"\"\n\n    if command_id == \"file/read\":\n        if len(args) != 1 or not isinstance(args[0], str):\n            raise ValueError(\"file/read requires exactly one string argument\")\n\n        # Prevent directory traversal\n        path = os.path.normpath(args[0])\n        if path.startswith(\"../\") or \"/../\" in path:\n            raise ValueError(\"Directory traversal not allowed\")\n\n    elif command_id == \"process/exec\":\n        if len(args) &lt; 1:\n            raise ValueError(\"process/exec requires at least one argument\")\n\n        # Whitelist allowed commands\n        allowed_commands = [\"ls\", \"cat\", \"echo\", \"date\"]\n        if args[0] not in allowed_commands:\n            raise ValueError(f\"Command not allowed: {args[0]}\")\n</code></pre>"},{"location":"jhip/host-commands/#resource-limits","title":"Resource Limits","text":"<pre><code>class ResourceLimiter:\n    def __init__(self):\n        self.limits = {\n            \"max_execution_time\": 30,  # seconds\n            \"max_memory_usage\": 100 * 1024 * 1024,  # 100MB\n            \"max_file_size\": 10 * 1024 * 1024,  # 10MB\n            \"max_network_requests_per_minute\": 60\n        }\n        self.usage_tracking = {}\n\n    def check_limits(self, command_id: str, user_id: str):\n        # Implement rate limiting and resource checking\n        current_time = time.time()\n\n        # Check rate limits\n        user_requests = self.usage_tracking.get(user_id, [])\n        recent_requests = [t for t in user_requests if current_time - t &lt; 60]\n\n        if len(recent_requests) &gt;= self.limits[\"max_network_requests_per_minute\"]:\n            raise Exception(\"Rate limit exceeded\")\n\n        # Track this request\n        self.usage_tracking[user_id] = recent_requests + [current_time]\n</code></pre>"},{"location":"jhip/host-commands/#testing-host-commands","title":"Testing Host Commands","text":""},{"location":"jhip/host-commands/#unit-testing","title":"Unit Testing","text":"<pre><code>def test_file_read_command():\n    handler = FileReadHandler()\n\n    # Test successful read\n    with tempfile.NamedTemporaryFile(mode='w', delete=False) as f:\n        f.write(\"test content\")\n        f.flush()\n\n        result = handler.execute([f.name])\n        assert result == \"test content\"\n\n    # Test file not found\n    result = handler.execute([\"/nonexistent/file\"])\n    assert \"$jsl_error\" in result\n    assert result[\"$jsl_error\"][\"type\"] == \"FileNotFound\"\n</code></pre>"},{"location":"jhip/host-commands/#integration-testing","title":"Integration Testing","text":"<pre><code>def test_command_through_jsl():\n    # Test command through JSL runtime\n    jsl_code = [\"host\", \"@file/read\", \"@/tmp/test.txt\"]\n\n    # Mock the host command\n    with patch('jsl_host.execute_command') as mock_execute:\n        mock_execute.return_value = \"mocked file content\"\n\n        result = jsl_runtime.evaluate(jsl_code)\n        assert result == \"mocked file content\"\n\n        mock_execute.assert_called_once_with(\"file/read\", [\"/tmp/test.txt\"])\n</code></pre>"},{"location":"jhip/host-commands/#documentation-template","title":"Documentation Template","text":"<p>Use this template when documenting host commands:</p> <p>Command: <code>myapp/user/create</code></p> <p>Description: Creates a new user account in the system.</p> <p>Parameters: - <code>user_data</code> (object): User information   - <code>email</code> (string, required): User's email address   - <code>name</code> (string, required): User's full name   - <code>role</code> (string, optional): User role, defaults to \"user\"</p> <p>Returns:  - <code>user_id</code> (string): Unique identifier for created user - <code>email</code> (string): Confirmed email address - <code>created_at</code> (string): ISO timestamp of creation</p> <p>Permissions Required: <code>user.create</code></p> <p>Example: <pre><code>[\"host\", \"@myapp/user/create\", {\n  \"@email\": \"@john@example.com\",\n  \"@name\": \"@John Doe\",\n  \"@role\": \"@editor\"\n}]\n</code></pre></p> <p>Error Types: - <code>DUPLICATE_EMAIL</code>: Email address already exists - <code>INVALID_EMAIL</code>: Email format is invalid - <code>PERMISSION_DENIED</code>: Insufficient permissions</p>"},{"location":"jhip/host-commands/#best-practices","title":"Best Practices","text":""},{"location":"jhip/host-commands/#design-guidelines","title":"Design Guidelines","text":"<ol> <li>Atomic Operations: Commands should perform single, well-defined operations</li> <li>Idempotency: Where possible, commands should be idempotent</li> <li>Error Transparency: Provide clear, actionable error messages</li> <li>Resource Efficiency: Minimize resource usage and implement proper cleanup</li> <li>Backward Compatibility: Maintain compatibility when updating commands</li> </ol>"},{"location":"jhip/host-commands/#performance-optimization","title":"Performance Optimization","text":"<ol> <li>Caching: Cache frequently accessed data</li> <li>Connection Pooling: Reuse database and network connections</li> <li>Async Operations: Use async patterns for I/O operations</li> <li>Batch Processing: Support batch operations where appropriate</li> </ol>"},{"location":"jhip/host-commands/#security-best-practices","title":"Security Best Practices","text":"<ol> <li>Input Sanitization: Always validate and sanitize inputs</li> <li>Principle of Least Privilege: Grant minimal required permissions</li> <li>Audit Logging: Log all command executions for security analysis</li> <li>Rate Limiting: Implement rate limits to prevent abuse</li> <li>Resource Limits: Set timeouts and size limits on operations</li> </ol> <p>Host commands are how JSL integrates with the real world while maintaining security, transparency, and auditability. By following these guidelines and community conventions, you can create robust, secure, and maintainable host command implementations that work well with the broader JSL ecosystem.</p>"},{"location":"jhip/protocol/","title":"JSL Host Interaction Protocol (JHIP) - Version 1.0","text":""},{"location":"jhip/protocol/#introduction","title":"Introduction","text":"<p>The JSL Host Interaction Protocol (JHIP) defines how JSL programs interact with the host environment for side effects. JSL's core philosophy is to reify effects as data - side effects are described as JSON messages rather than executed directly, allowing the host environment to control, audit, and secure all external interactions.</p>"},{"location":"jhip/protocol/#core-principles","title":"Core Principles","text":"<ul> <li>Effect Reification: Side effects are described as data, not executed directly</li> <li>Host Authority: The host controls what operations are permitted and how they execute</li> <li>JSON-Native: All messages are valid JSON for universal compatibility</li> <li>Synchronous Model: From JSL's perspective, host operations are synchronous</li> <li>Capability-Based Security: Hosts provide only the capabilities they choose to expose</li> </ul>"},{"location":"jhip/protocol/#request-structure","title":"Request Structure","text":"<p>JSL programs request host operations using the <code>host</code> special form:</p> <pre><code>[\"host\", \"command\", \"arg1\", \"arg2\", ...]\n</code></pre> <p>This creates a request message with the following structure:</p> <pre><code>{\n  \"command\": \"string\",\n  \"args\": [\"arg1\", \"arg2\", ...]\n}\n</code></pre>"},{"location":"jhip/protocol/#request-examples","title":"Request Examples","text":"<p>File Operations: <pre><code>// JSL code\n[\"host\", \"@file/read\", \"@/tmp/data.txt\"]\n\n// Request message\n{\n  \"command\": \"file/read\",\n  \"args\": [\"/tmp/data.txt\"]\n}\n</code></pre></p> <p>HTTP Requests: <pre><code>// JSL code\n[\"host\", \"@http/get\", \"@https://api.example.com/users\", {\"@Authorization\": \"@Bearer token\"}]\n\n// Request message\n{\n  \"command\": \"http/get\", \n  \"args\": [\"https://api.example.com/users\", {\"Authorization\": \"Bearer token\"}]\n}\n</code></pre></p> <p>Logging: <pre><code>// JSL code\n[\"host\", \"@log/info\", \"@User logged in\", {\"@user_id\": 123}]\n\n// Request message\n{\n  \"command\": \"log/info\",\n  \"args\": [\"User logged in\", {\"user_id\": 123}]\n}\n</code></pre></p>"},{"location":"jhip/protocol/#response-structure","title":"Response Structure","text":"<p>The host responds with either a success value or an error object.</p>"},{"location":"jhip/protocol/#success-response","title":"Success Response","text":"<p>Any valid JSON value represents success:</p> <pre><code>// File read success\n\"file content as string\"\n\n// HTTP response success\n{\n  \"status\": 200,\n  \"headers\": {\"content-type\": \"application/json\"},\n  \"body\": {\"users\": [...]}\n}\n\n// Operation with no return value\nnull\n</code></pre>"},{"location":"jhip/protocol/#error-response","title":"Error Response","text":"<p>Errors use a standard structure to distinguish them from successful <code>null</code>, <code>false</code>, or empty results:</p> <pre><code>{\n  \"$jsl_error\": {\n    \"type\": \"ErrorType\",\n    \"message\": \"Human readable description\",\n    \"details\": {}\n  }\n}\n</code></pre> <p>Error Fields: - <code>type</code>: Error category (e.g., \"FileNotFound\", \"NetworkError\", \"PermissionDenied\") - <code>message</code>: Clear description for developers - <code>details</code>: Additional structured information (optional)</p> <p>Error Examples:</p> <pre><code>// File not found\n{\n  \"$jsl_error\": {\n    \"type\": \"FileNotFound\",\n    \"message\": \"File does not exist\",\n    \"details\": {\n      \"path\": \"/tmp/missing.txt\",\n      \"operation\": \"file/read\"\n    }\n  }\n}\n\n// Permission denied\n{\n  \"$jsl_error\": {\n    \"type\": \"PermissionDenied\", \n    \"message\": \"Insufficient permissions for operation\",\n    \"details\": {\n      \"operation\": \"file/write\",\n      \"path\": \"/etc/passwd\",\n      \"required_permission\": \"root\"\n    }\n  }\n}\n\n// Network error\n{\n  \"$jsl_error\": {\n    \"type\": \"NetworkError\",\n    \"message\": \"Connection timeout\",\n    \"details\": {\n      \"url\": \"https://api.example.com\",\n      \"timeout_ms\": 5000\n    }\n  }\n}\n</code></pre>"},{"location":"jhip/protocol/#standard-commands","title":"Standard Commands","text":"<p>While hosts define their own command sets, these common patterns are recommended:</p>"},{"location":"jhip/protocol/#file-system","title":"File System","text":"<ul> <li><code>@file/read</code> - Read file content as string</li> <li><code>@file/write</code> - Write string to file  </li> <li><code>@file/exists</code> - Check if file exists</li> <li><code>@file/list</code> - List directory contents</li> <li><code>@file/delete</code> - Delete file or directory</li> </ul>"},{"location":"jhip/protocol/#http","title":"HTTP","text":"<ul> <li><code>@http/get</code> - GET request</li> <li><code>@http/post</code> - POST request</li> <li><code>@http/put</code> - PUT request</li> <li><code>@http/delete</code> - DELETE request</li> </ul>"},{"location":"jhip/protocol/#logging","title":"Logging","text":"<ul> <li><code>@log/debug</code> - Debug level log</li> <li><code>@log/info</code> - Info level log</li> <li><code>@log/warn</code> - Warning level log</li> <li><code>@log/error</code> - Error level log</li> </ul>"},{"location":"jhip/protocol/#system","title":"System","text":"<ul> <li><code>@env/get</code> - Get environment variable</li> <li><code>@time/now</code> - Current timestamp</li> <li><code>@random/uuid</code> - Generate UUID</li> <li><code>@process/exec</code> - Execute system command</li> </ul>"},{"location":"jhip/protocol/#protocol-flow","title":"Protocol Flow","text":"<ol> <li>JSL Evaluation: JSL encounters <code>[\"host\", \"command\", ...args]</code></li> <li>Argument Evaluation: All arguments are evaluated to JSON values</li> <li>Message Construction: Create request message with command and args</li> <li>Host Processing: Host validates, executes, and responds</li> <li>Response Handling: Success value returned or error thrown in JSL</li> </ol>"},{"location":"jhip/protocol/#security-model","title":"Security Model","text":"<p>JHIP implements capability-based security:</p> <ul> <li>Host Controls Access: Only commands explicitly enabled by the host are available</li> <li>Argument Validation: Host validates all arguments before execution</li> <li>Resource Limits: Host can impose limits on operations (file size, request timeouts, etc.)</li> <li>Audit Trail: All host interactions can be logged for security analysis</li> </ul>"},{"location":"jhip/protocol/#implementation-notes","title":"Implementation Notes","text":""},{"location":"jhip/protocol/#error-handling-in-jsl","title":"Error Handling in JSL","text":"<p>JSL implementations should convert JHIP error responses into JSL errors:</p> <pre><code>// If host returns error, JSL should throw\n[\"try\",\n  [\"host\", \"file/read\", \"/missing.txt\"],\n  [\"lambda\", [\"err\"], \n    [\"get\", \"err\", \"message\"]]]\n</code></pre>"},{"location":"jhip/protocol/#async-implementation","title":"Async Implementation","text":"<p>While JSL sees synchronous operations, hosts may implement async processing:</p> <ul> <li>Queue requests for batch processing</li> <li>Use connection pooling for HTTP requests</li> <li>Implement timeout and retry logic</li> <li>Cache results when appropriate</li> </ul>"},{"location":"jhip/protocol/#testing","title":"Testing","text":"<p>JHIP enables easy testing by mocking host responses:</p> <pre><code>// Mock successful file read\n{\"command\": \"file/read\", \"args\": [\"/data.txt\"]} \n\u2192 \"mocked file content\"\n\n// Mock error response  \n{\"command\": \"file/read\", \"args\": [\"/missing.txt\"]}\n\u2192 {\"$jsl_error\": {\"type\": \"FileNotFound\", \"message\": \"File not found\"}}\n</code></pre>"},{"location":"language/environments/","title":"Environments and Execution Contexts","text":""},{"location":"language/environments/#overview-the-scope-chain","title":"Overview: The Scope Chain","text":"<p>Environments are a fundamental concept in JSL, forming the backbone of its lexical scoping, security model, and module system. An environment is a data structure that maps variable names to their values. Every JSL expression is evaluated within an environment.</p> <p>When looking up a variable, the JSL runtime first checks the current environment. If the variable is not found, it proceeds to check the parent environment, and so on, creating a \"scope chain.\" This process continues until it reaches the root environment, which is the Prelude. The prelude provides all the built-in functions and is implicitly the ultimate parent of all user-defined environments.</p>"},{"location":"language/environments/#the-algebra-of-environments","title":"The Algebra of Environments","text":"<p>This algebra provides the foundation for JSL's Level 2 (Advanced) Capability-Based Security Model. While the standard security model relies on the host dispatcher to authorize requests (see Security Model), the environment algebra allows a trusted orchestrator to provision sandboxed execution contexts that cannot even attempt to call unauthorized host commands.</p> <p>By using operators like <code>remove</code> to withhold the raw <code>[\"host\", ...]</code> capability and <code>layer</code> to provide safe, pre-defined wrapper functions, a host can enforce security at the language level, before a request ever reaches the dispatcher.</p> <p>For a complete discussion of the layered security model, see the Security Model documentation.</p> <p>These operations are typically exposed to trusted code (e.g., via the Fluent Python API or a special host configuration) and are essential for creating custom execution contexts. They take one or more environment hashes as input and produce a new environment hash as output, never modifying the original environments.</p>"},{"location":"language/environments/#layer-union-additive-merge","title":"<code>layer</code> (Union / Additive Merge)","text":"<p>The <code>layer</code> operation creates a new environment by combining the bindings from one or more existing environments on top of a shared parent.</p> <ul> <li>Syntax: <code>[\"layer\", parent_env_hash, env_hash_1, env_hash_2, ...]</code></li> <li>Use Case: Module composition. You can load multiple modules (each represented by an environment) and <code>layer</code> them together to create a single, unified API scope for your application.</li> <li>Conflict Resolution: If multiple source environments define a binding with the same name, the one from the last environment in the argument list (\"last-write-wins\") is used.</li> </ul>"},{"location":"language/environments/#remove-subtraction-capability-reduction","title":"<code>remove</code> (Subtraction / Capability Reduction)","text":"<p>The <code>remove</code> operation creates a new, less-privileged environment by removing specified bindings.</p> <ul> <li>Syntax: <code>[\"remove\", env_hash, \"key_to_remove_1\", \"key_to_remove_2\", ...]</code></li> <li>Use Case: Sandboxing and security. If you have a powerful <code>file_system</code> module, you can use <code>remove</code> to create a \"read-only\" version of it for untrusted code by removing the <code>write</code> and <code>delete</code> bindings.</li> </ul>"},{"location":"language/environments/#intersect-intersection-of-capabilities","title":"<code>intersect</code> (Intersection of Capabilities)","text":"<p>The <code>intersect</code> operation creates a new environment containing only the bindings whose names exist in all of the provided environments.</p> <ul> <li>Syntax: <code>[\"intersect\", env_hash_1, env_hash_2, ...]</code></li> <li>Use Case: Enforcing an API interface. You can <code>intersect</code> two versions of a module to create an environment that is guaranteed to only contain the functions common to both, making your code more robust against API changes.</li> </ul>"},{"location":"language/environments/#difference-exclusive-capabilities","title":"<code>difference</code> (Exclusive Capabilities)","text":"<p>The <code>difference</code> operation creates a new environment containing only the bindings from a base environment whose names do not exist in another.</p> <ul> <li>Syntax: <code>[\"difference\", base_env_hash, env_to_subtract_hash]</code></li> <li>Use Case: Introspection and tooling. This can be used to identify new or deprecated features between two versions of a module.</li> </ul>"},{"location":"language/environments/#environments-and-serialization","title":"Environments and Serialization","text":"<p>While the concept of environments is part of the language specification, their representation for transport and storage is an architectural detail. For more information on how environments are serialized using content-addressable hashing, see Code and Data Serialization.</p>"},{"location":"language/objects/","title":"JSON Objects as First-Class Citizens","text":""},{"location":"language/objects/#overview","title":"Overview","text":"<p>JSL treats JSON objects as first-class data structures with native support for dynamic construction. Unlike arrays (which are interpreted as S-expressions), JSON objects in JSL are always treated as data structures, making them perfect for constructing pure JSON output without ambiguity.</p>"},{"location":"language/objects/#why-objects-are-special","title":"Why Objects Are Special","text":"<p>In JSL, there's an important distinction between arrays and objects:</p> <ul> <li>Arrays: <code>[\"+\", 1, 2]</code> are interpreted as function calls (S-expressions)</li> <li>Objects: <code>{\"name\": \"Alice\"}</code> are always treated as data structures</li> </ul> <p>This means objects provide a \"safe zone\" for pure data construction where you don't have to worry about the first element being interpreted as an operator.</p>"},{"location":"language/objects/#object-construction-syntax","title":"Object Construction Syntax","text":"<p>JSL objects use normal JSL evaluation rules for both keys and values:</p> <ul> <li>Keys must evaluate to strings</li> <li>Values can be any JSL expression</li> <li>Use <code>@</code> prefix for literal strings in both keys and values</li> </ul>"},{"location":"language/objects/#basic-examples","title":"Basic Examples","text":"<p>Literal Object: <pre><code>{\"@name\": \"@Alice\", \"@age\": 25}\n</code></pre> Result: <code>{\"name\": \"Alice\", \"age\": 25}</code></p> <p>Dynamic Values: <pre><code>[\"do\",\n  [\"def\", \"user_name\", \"@Bob\"],\n  [\"def\", \"user_age\", 30],\n  {\"@name\": \"user_name\", \"@age\": \"user_age\"}\n]\n</code></pre> Result: <code>{\"name\": \"Bob\", \"age\": 30}</code></p> <p>Dynamic Keys: <pre><code>[\"do\",\n  [\"def\", \"field_name\", \"@username\"],\n  {\"field_name\": \"@Alice\"}\n]\n</code></pre> Result: <code>{\"username\": \"Alice\"}</code></p>"},{"location":"language/objects/#string-construction-in-objects","title":"String Construction in Objects","text":"<p>For dynamic string construction, use JSL's string functions:</p> <p><pre><code>[\"do\",\n  [\"def\", \"name\", \"@Alice\"],\n  [\"def\", \"age\", 25],\n  {\n    \"@greeting\": [\"str-concat\", \"@Hello \", \"name\"],\n    \"@info\": [\"str-concat\", \"@Age: \", \"age\"],\n    \"@status\": [\"if\", [\"&gt;\", \"age\", 18], \"@adult\", \"@minor\"]\n  }\n]\n</code></pre> Result: <pre><code>{\n  \"greeting\": \"Hello Alice\",\n  \"info\": \"Age: 25\", \n  \"status\": \"adult\"\n}\n</code></pre></p>"},{"location":"language/objects/#nested-objects-and-complex-structures","title":"Nested Objects and Complex Structures","text":"<p>Objects can contain any JSL expressions, including nested objects and arrays:</p> <pre><code>[\"do\",\n  [\"def\", \"users\", [\"@\", [\"Alice\", \"Bob\", \"Carol\"]]],\n  {\n    \"@project\": \"@My Project\",\n    \"@team\": {\n      \"@lead\": [\"first\", \"users\"],\n      \"@members\": \"users\",\n      \"@size\": [\"length\", \"users\"]\n    },\n    \"@tags\": [\"@\", [\"web\", \"javascript\", \"api\"]]\n  }\n]\n</code></pre>"},{"location":"language/objects/#advantages-of-object-first-design","title":"Advantages of Object-First Design","text":"<ol> <li>No Operator Ambiguity: Objects are always data, never function calls</li> <li>Pure JSON Output: Objects naturally serialize to clean JSON</li> <li>Composable: Works seamlessly with JSL functions and variables</li> <li>Consistent Syntax: Uses the same <code>@</code> rules as the rest of JSL</li> <li>Type Safety: Keys are validated to be strings at runtime</li> </ol>"},{"location":"language/objects/#working-with-object-functions","title":"Working with Object Functions","text":"<p>JSL provides built-in functions for object manipulation:</p> <pre><code>[\"do\",\n  [\"def\", \"user\", {\"@name\": \"@Alice\", \"@role\": \"@admin\"}],\n\n  [\"get\", \"user\", \"@name\"],        // \u2192 \"Alice\"\n  [\"has\", \"user\", \"@email\"],       // \u2192 false\n  [\"keys\", \"user\"],                // \u2192 [\"name\", \"role\"]\n\n  [\"set\", \"user\", \"@email\", \"@alice@example.com\"]  // Add new field\n]\n</code></pre>"},{"location":"language/overview/","title":"JSL Language Overview","text":""},{"location":"language/overview/#what-is-jsl","title":"What is JSL?","text":"<p>JSL (JSON Serializable Language) is a powerful, functional programming language where every program is valid JSON. This unique design makes it perfect for network transmission, distributed computing, and safe, sandboxed execution.</p> <p>JSL is built on three core principles: 1.  Homoiconic: Code and data share the same structure (JSON). This means you can build and manipulate code as easily as you handle data. 2.  Functional: With features like immutability, first-class functions, and a rich library of higher-order functions, JSL encourages a clean, declarative style. 3.  Serializable: Every JSL value, including functions with their environments, can be perfectly serialized to a string, sent across a network, and safely executed on a remote machine.</p>"},{"location":"language/overview/#a-taste-of-jsl","title":"A Taste of JSL","text":"<p>Because JSL is JSON, operations use a simple prefix notation inside an array. This expression adds three numbers: <pre><code>[\"+\", 1, 2, 3]\n</code></pre> The evaluator understands that the first element, <code>\"+\"</code>, is a function to be applied to the rest of the elements, resulting in <code>6</code>.</p>"},{"location":"language/overview/#the-two-modes-of-jsl","title":"The Two Modes of JSL","text":"<p>JSL has a single, consistent evaluation model where:</p>"},{"location":"language/overview/#core-evaluation-rules","title":"Core Evaluation Rules","text":"<ol> <li>Strings without <code>@</code>: Variable lookups (e.g., <code>\"x\"</code> looks up the value of x)</li> <li>Strings with <code>@</code>: Literal strings (e.g., <code>\"@hello\"</code> is the string \"hello\")</li> <li>Arrays: Function calls in prefix notation (e.g., <code>[\"+\", 1, 2]</code>)</li> <li>Objects: Data structures with evaluated keys and values</li> <li>Other values: Self-evaluating (numbers, booleans, null)</li> </ol>"},{"location":"language/overview/#json-object-construction","title":"JSON Object Construction","text":"<p>JSL treats JSON objects as first-class data structures. Unlike arrays (which are interpreted as S-expressions), objects are always data structures, never function calls. This makes them perfect for constructing pure JSON output:</p> <pre><code>[\"do\",\n  [\"def\", \"user\", \"@Alice\"],\n  [\"def\", \"role\", \"@admin\"],\n  {\"@name\": \"user\", \"@role\": \"role\"}\n]\n// Result: {\"name\": \"Alice\", \"role\": \"admin\"}\n</code></pre> <p>For a complete guide, see JSON Objects as First-Class Citizens.</p>"},{"location":"language/overview/#key-language-features","title":"Key Language Features","text":"<ul> <li>Special Forms: A small set of core keywords like <code>if</code>, <code>def</code>, and <code>lambda</code> provide the foundation for control flow and variable bindings. See the Special Forms Guide.</li> <li>Rich Prelude: A comprehensive standard library of functions for math, logic, and data manipulation is available everywhere. See the Prelude Reference.</li> <li>Lexical Scoping: JSL uses lexical scoping, meaning functions (closures) capture the environment where they are defined, not where they are called. This provides a robust and predictable module system.</li> <li>Host Interaction: JSL interacts with the host system through a single, explicit special form, <code>[\"host\", ...]</code>, making all side effects transparent and auditable.</li> </ul>"},{"location":"language/overview/#a-complete-example","title":"A Complete Example","text":"<p>This example defines and calls a recursive factorial function, showcasing variable and function definition (<code>def</code>, <code>lambda</code>), conditional logic (<code>if</code>), and a sequence of operations (<code>do</code>).</p> <p><pre><code>[\"do\",\n  [\"def\", \"factorial\",\n    [\"lambda\", [\"n\"],\n      [\"if\", [\"&lt;=\", \"n\", 1],\n        1,\n        [\"*\", \"n\", [\"factorial\", [\"-\", \"n\", 1]]]\n      ]\n    ]\n  ],\n  [\"factorial\", 5]\n]\n</code></pre> The result of evaluating this expression is <code>120</code>.</p>"},{"location":"language/overview/#where-to-go-next","title":"Where to Go Next","text":"<ul> <li>JSL Syntax and Semantics: The definitive guide to writing and understanding core JSL.</li> <li>JSON Objects: Learn how to generate dynamic JSON objects.</li> <li>Special Forms: A detailed reference for all core language constructs.</li> <li>Prelude Functions: A complete catalog of all built-in functions</li> </ul>"},{"location":"language/path-navigation/","title":"Path Navigation","text":"<p>JSL provides powerful path navigation operations for accessing and manipulating deeply nested JSON structures. These operations are inspired by dotsuite's dotpath approach.</p>"},{"location":"language/path-navigation/#overview","title":"Overview","text":"<p>Path navigation allows you to access nested values using simple path strings instead of chaining multiple <code>get</code> operations.</p>"},{"location":"language/path-navigation/#path-navigation-functions","title":"Path Navigation Functions","text":""},{"location":"language/path-navigation/#get-path-navigate-to-a-value","title":"<code>get-path</code> - Navigate to a Value","text":"<p>Retrieves a value at a deep path:</p> <pre><code>(def user {\n  \"@name\": \"@John\",\n  \"@address\": {\n    \"@city\": \"@Boston\",\n    \"@zip\": \"@02134\"\n  }\n})\n\n; Instead of nested gets:\n(get (get user \"@address\") \"@city\")  ; \"@Boston\"\n\n; Use path navigation:\n(get-path user \"@address.city\")      ; \"@Boston\"\n</code></pre>"},{"location":"language/path-navigation/#set-path-set-a-value-at-path","title":"<code>set-path</code> - Set a Value at Path","text":"<p>Creates a new object with a value set at the specified path:</p> <pre><code>; Set a nested value\n(set-path user \"@address.country\" \"@USA\")\n\n; Creates intermediate objects if needed\n(set-path {} \"@user.profile.name\" \"@Alice\")\n; Returns: {\"user\": {\"profile\": {\"name\": \"Alice\"}}}\n</code></pre>"},{"location":"language/path-navigation/#has-path-check-path-existence","title":"<code>has-path</code> - Check Path Existence","text":"<p>Tests whether a path exists in an object:</p> <pre><code>(has-path user \"@address.city\")     ; true\n(has-path user \"@address.country\")  ; false\n(has-path user \"@phone.mobile\")     ; false\n</code></pre>"},{"location":"language/path-navigation/#update-path-update-value-at-path","title":"<code>update-path</code> - Update Value at Path","text":"<p>Updates a value at a path using a function:</p> <pre><code>; Increment a nested counter\n(update-path stats \"@views.total\" inc)\n\n; Transform a nested value\n(update-path user \"@address.zip\" \n  (lambda (z) (str-concat z \"-0000\")))\n</code></pre>"},{"location":"language/path-navigation/#get-safe-safe-navigation","title":"<code>get-safe</code> - Safe Navigation","text":"<p>Returns a default value if the path doesn't exist:</p> <pre><code>; Returns null if path missing\n(get-safe user \"@phone.mobile\")  ; null\n\n; With custom default\n(get-safe user \"@phone.mobile\" \"@unknown\")  ; \"@unknown\"\n</code></pre>"},{"location":"language/path-navigation/#path-syntax","title":"Path Syntax","text":""},{"location":"language/path-navigation/#basic-paths","title":"Basic Paths","text":"<p>Paths use dot notation to navigate through objects:</p> <pre><code>\"@field\"           ; Top-level field\n\"@field.subfield\"  ; Nested field\n\"@a.b.c.d\"        ; Deep nesting\n</code></pre>"},{"location":"language/path-navigation/#array-indexing","title":"Array Indexing","text":"<p>Access array elements by index:</p> <pre><code>(def data {\n  \"@items\": [@\n    {\"@id\": 1, \"@name\": \"@First\"}\n    {\"@id\": 2, \"@name\": \"@Second\"}\n  ]\n})\n\n(get-path data \"@items.0\")       ; {\"id\": 1, \"name\": \"First\"}\n(get-path data \"@items.0.name\")  ; \"@First\"\n(get-path data \"@items.1.id\")    ; 2\n</code></pre>"},{"location":"language/path-navigation/#alternative-array-syntax","title":"Alternative Array Syntax","text":"<p>Arrays can also use bracket notation:</p> <pre><code>(get-path data \"@items[0]\")       ; {\"id\": 1, \"name\": \"First\"}\n(get-path data \"@items[0].name\")  ; \"@First\"\n(get-path data \"@items[1].id\")    ; 2\n</code></pre>"},{"location":"language/path-navigation/#wildcards","title":"Wildcards","text":"<p>Use <code>*</code> to match all elements:</p> <pre><code>(def users [@\n  {\"@name\": \"@Alice\", \"@age\": 30}\n  {\"@name\": \"@Bob\", \"@age\": 25}\n])\n\n; Get all names\n(get-path {\"@users\": users} \"@users.*.name\")\n; Returns: [\"Alice\", \"Bob\"]\n\n; Get all ages\n(get-path {\"@users\": users} \"@users.*.age\")  \n; Returns: [30, 25]\n</code></pre>"},{"location":"language/path-navigation/#complex-examples","title":"Complex Examples","text":""},{"location":"language/path-navigation/#working-with-nested-data","title":"Working with Nested Data","text":"<pre><code>(def company {\n  \"@name\": \"@TechCorp\",\n  \"@departments\": [@\n    {\n      \"@name\": \"@Engineering\",\n      \"@employees\": [@\n        {\"@name\": \"@Alice\", \"@role\": \"@Lead\"}\n        {\"@name\": \"@Bob\", \"@role\": \"@Developer\"}\n      ]\n    }\n    {\n      \"@name\": \"@Sales\",\n      \"@employees\": [@\n        {\"@name\": \"@Charlie\", \"@role\": \"@Manager\"}\n      ]\n    }\n  ]\n})\n\n; Access specific employee\n(get-path company \"@departments.0.employees.1.name\")  ; \"@Bob\"\n\n; Get all department names\n(get-path company \"@departments.*.name\")  ; [\"Engineering\", \"Sales\"]\n\n; Get all employee names across departments\n(get-path company \"@departments.*.employees.*.name\")\n; Returns: [\"Alice\", \"Bob\", \"Charlie\"]\n</code></pre>"},{"location":"language/path-navigation/#building-complex-structures","title":"Building Complex Structures","text":"<pre><code>; Start with empty object\n(def config {})\n\n; Build configuration progressively\n(def config\n  (set-path config \"@database.host\" \"@localhost\"))\n(def config  \n  (set-path config \"@database.port\" 5432))\n(def config\n  (set-path config \"@database.credentials.user\" \"@admin\"))\n(def config\n  (set-path config \"@database.credentials.password\" \"@secret\"))\n\n; Result:\n; {\n;   \"database\": {\n;     \"host\": \"localhost\",\n;     \"port\": 5432,\n;     \"credentials\": {\n;       \"user\": \"admin\",\n;       \"password\": \"secret\"\n;     }\n;   }\n; }\n</code></pre>"},{"location":"language/path-navigation/#safe-data-extraction","title":"Safe Data Extraction","text":"<pre><code>(def response {\n  \"@data\": {\n    \"@user\": {\n      \"@profile\": {\n        \"@email\": \"@user@example.com\"\n      }\n    }\n  }\n})\n\n; Safe extraction with defaults\n(get-safe response \"@data.user.profile.email\" \"@no-email\")  ; \"@user@example.com\"\n(get-safe response \"@data.user.profile.phone\" \"@no-phone\")  ; \"@no-phone\"\n(get-safe response \"@data.user.address.city\" \"@unknown\")    ; \"@unknown\"\n</code></pre>"},{"location":"language/path-navigation/#integration-with-query-operations","title":"Integration with Query Operations","text":"<p>Path navigation works seamlessly with <code>where</code> and <code>transform</code>:</p> <pre><code>; Filter by nested field\n(where users (= (get-path it \"@address.city\") \"@Boston\"))\n\n; Transform nested fields\n(transform users \n  (assign \"@full_address\" \n    (str-concat \n      (get-path it \"@address.street\") \", \"\n      (get-path it \"@address.city\"))))\n\n; Update nested fields\n(transform orders\n  (update-path \"@shipping.status\" \n    (lambda (s) (if (= s \"@pending\") \"@processing\" s))))\n</code></pre>"},{"location":"language/path-navigation/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Path parsing is done once per operation</li> <li>Wildcards may traverse entire structures</li> <li><code>set-path</code> creates new objects (immutable)</li> <li><code>has-path</code> short-circuits on missing segments</li> </ul>"},{"location":"language/path-navigation/#error-handling","title":"Error Handling","text":"<p>Path operations handle missing paths gracefully:</p> <pre><code>(get-path {} \"@a.b.c\")       ; null (not an error)\n(has-path {} \"@a.b.c\")       ; false\n(set-path {} \"@a.b.c\" 123)   ; Creates full path\n(update-path {} \"@a.b.c\" inc) ; null (can't update non-existent)\n</code></pre>"},{"location":"language/path-navigation/#see-also","title":"See Also","text":"<ul> <li>Query Operations - Filtering with <code>where</code></li> <li>Transform Operations - Data transformation</li> <li>Objects - Working with JSL objects</li> </ul>"},{"location":"language/prelude/","title":"Prelude Functions","text":""},{"location":"language/prelude/#overview","title":"Overview","text":"<p>The JSL prelude provides the computational foundation for all JSL programs. These built-in functions are available in every JSL environment.</p> <p>For a guide to creating and managing execution contexts, see the Environments documentation.</p>"},{"location":"language/prelude/#special-forms-core-syntax","title":"Special Forms (Core Syntax)","text":"<p>While the prelude contains a library of standard functions, the core language is defined by a small set of special forms. These are syntactic constructs that do not follow the standard evaluation rule (i.e., they don't necessarily evaluate all of their arguments).</p> <p>The core special forms include <code>if</code>, <code>def</code>, <code>lambda</code>, <code>do</code>, <code>let</code>, and <code>try</code>. For a complete reference, please see the dedicated Special Forms documentation.</p>"},{"location":"language/prelude/#design-principles","title":"Design Principles","text":"<ul> <li>Immutable Operations: Functions return new values rather than modifying inputs</li> <li>N-arity Support: Mathematical and logical operations accept variable numbers of arguments</li> <li>Type Safety: Comprehensive type predicates and safe conversions</li> <li>Functional Composition: Higher-order functions that work seamlessly with JSL closures</li> <li>JSON Compatibility: All operations respect JSON's type system</li> </ul>"},{"location":"language/prelude/#data-constructors","title":"Data Constructors","text":""},{"location":"language/prelude/#list","title":"<code>list</code>","text":"<p><pre><code>[\"list\", 1, 2, 3]  // \u2192 [1, 2, 3]\n[\"list\"]           // \u2192 []\n</code></pre> Creates a list from the provided arguments.</p>"},{"location":"language/prelude/#list-operations","title":"List Operations","text":"<p>JSL provides comprehensive list manipulation functions following functional programming principles.</p>"},{"location":"language/prelude/#append","title":"<code>append</code>","text":"<p><pre><code>[\"append\", [1, 2, 3], 4]  // \u2192 [1, 2, 3, 4]\n[\"append\", [], 1]         // \u2192 [1]\n</code></pre> Returns a new list with the item appended to the end.</p>"},{"location":"language/prelude/#prepend","title":"<code>prepend</code>","text":"<p><pre><code>[\"prepend\", 0, [1, 2, 3]]  // \u2192 [0, 1, 2, 3]\n[\"prepend\", 1, []]         // \u2192 [1]\n</code></pre> Returns a new list with the item prepended to the beginning.</p>"},{"location":"language/prelude/#concat","title":"<code>concat</code>","text":"<p><pre><code>[\"concat\", [1, 2], [3, 4], [5]]  // \u2192 [1, 2, 3, 4, 5]\n[\"concat\", [1], [2]]             // \u2192 [1, 2]\n[\"concat\"]                       // \u2192 []\n</code></pre> Concatenates multiple lists into a single list.</p>"},{"location":"language/prelude/#first","title":"<code>first</code>","text":"<p><pre><code>[\"first\", [1, 2, 3]]  // \u2192 1\n[\"first\", []]         // \u2192 null\n</code></pre> Returns the first element of a list, or null if empty.</p>"},{"location":"language/prelude/#rest","title":"<code>rest</code>","text":"<p><pre><code>[\"rest\", [1, 2, 3]]  // \u2192 [2, 3]\n[\"rest\", [1]]        // \u2192 []\n[\"rest\", []]         // \u2192 []\n</code></pre> Returns all elements except the first, or empty list if insufficient elements.</p>"},{"location":"language/prelude/#nth","title":"<code>nth</code>","text":"<p><pre><code>[\"nth\", [10, 20, 30], 1]  // \u2192 20\n[\"nth\", [10, 20], 5]      // \u2192 null\n</code></pre> Returns the element at the specified index (0-based), or null if out of bounds.</p>"},{"location":"language/prelude/#length","title":"<code>length</code>","text":"<p><pre><code>[\"length\", [1, 2, 3]]  // \u2192 3\n[\"length\", []]         // \u2192 0\n[\"length\", \"hello\"]    // \u2192 5\n</code></pre> Returns the length of a list or string.</p>"},{"location":"language/prelude/#empty","title":"<code>empty?</code>","text":"<p><pre><code>[\"empty?\", []]      // \u2192 true\n[\"empty?\", [1]]     // \u2192 false\n[\"empty?\", \"\"]      // \u2192 true\n[\"empty?\", \"hi\"]    // \u2192 false\n</code></pre> Returns true if the collection is empty.</p>"},{"location":"language/prelude/#slice","title":"<code>slice</code>","text":"<p><pre><code>[\"slice\", [1, 2, 3, 4, 5], 1, 4]  // \u2192 [2, 3, 4]\n[\"slice\", [1, 2, 3], 1]           // \u2192 [2, 3]\n[\"slice\", \"hello\", 1, 4]          // \u2192 \"ell\"\n</code></pre> Returns a slice of the list or string from start to end (exclusive).</p>"},{"location":"language/prelude/#reverse","title":"<code>reverse</code>","text":"<p><pre><code>[\"reverse\", [1, 2, 3]]  // \u2192 [3, 2, 1]\n[\"reverse\", \"hello\"]    // \u2192 \"olleh\"\n</code></pre> Returns a reversed copy of the list or string.</p>"},{"location":"language/prelude/#contains","title":"<code>contains?</code>","text":"<p><pre><code>[\"contains?\", [1, 2, 3], 2]      // \u2192 true\n[\"contains?\", [1, 2, 3], 4]      // \u2192 false\n[\"contains?\", \"hello\", \"ell\"]    // \u2192 true\n</code></pre> Returns true if the collection contains the specified item.</p>"},{"location":"language/prelude/#index","title":"<code>index</code>","text":"<p><pre><code>[\"index\", [10, 20, 30], 20]  // \u2192 1\n[\"index\", [10, 20, 30], 40]  // \u2192 -1\n</code></pre> Returns the index of the first occurrence of item, or -1 if not found.</p>"},{"location":"language/prelude/#dictionary-operations","title":"Dictionary Operations","text":"<p>Immutable dictionary operations supporting functional programming patterns.</p>"},{"location":"language/prelude/#get","title":"<code>get</code>","text":"<p><pre><code>[\"get\", {\"name\": \"Alice\", \"age\": 30}, \"name\"]           // \u2192 \"Alice\"\n[\"get\", {\"name\": \"Alice\"}, \"age\", \"unknown\"]            // \u2192 \"unknown\"\n</code></pre> Gets a value from a dictionary with optional default.</p>"},{"location":"language/prelude/#set","title":"<code>set</code>","text":"<p><pre><code>[\"set\", {\"name\": \"Alice\"}, \"age\", 30]  // \u2192 {\"name\": \"Alice\", \"age\": 30}\n[\"set\", {}, \"key\", \"value\"]            // \u2192 {\"key\": \"value\"}\n</code></pre> Returns a new dictionary with the key-value pair set.</p>"},{"location":"language/prelude/#keys","title":"<code>keys</code>","text":"<p><pre><code>[\"keys\", {\"name\": \"Alice\", \"age\": 30}]  // \u2192 [\"name\", \"age\"]\n[\"keys\", {}]                            // \u2192 []\n</code></pre> Returns a list of all keys in the dictionary.</p>"},{"location":"language/prelude/#values","title":"<code>values</code>","text":"<p><pre><code>[\"values\", {\"name\": \"Alice\", \"age\": 30}]  // \u2192 [\"Alice\", 30]\n[\"values\", {}]                            // \u2192 []\n</code></pre> Returns a list of all values in the dictionary.</p>"},{"location":"language/prelude/#merge","title":"<code>merge</code>","text":"<p><pre><code>[\"merge\", {\"a\": 1}, {\"b\": 2}, {\"c\": 3}]  // \u2192 {\"a\": 1, \"b\": 2, \"c\": 3}\n[\"merge\", {\"a\": 1}, {\"a\": 2}]            // \u2192 {\"a\": 2}\n</code></pre> Merges multiple dictionaries, with later values overriding earlier ones.</p>"},{"location":"language/prelude/#has-key","title":"<code>has-key?</code>","text":"<p><pre><code>[\"has-key?\", {\"name\": \"Alice\"}, \"name\"]  // \u2192 true\n[\"has-key?\", {\"name\": \"Alice\"}, \"age\"]   // \u2192 false\n</code></pre> Returns true if the dictionary contains the specified key.</p>"},{"location":"language/prelude/#arithmetic-operations","title":"Arithmetic Operations","text":"<p>Mathematical operations with n-arity support for natural expression.</p>"},{"location":"language/prelude/#addition","title":"<code>+</code> (Addition)","text":"<p><pre><code>[\"+\", 1, 2, 3]    // \u2192 6\n[\"+\", 5]          // \u2192 5\n[\"+\"]             // \u2192 0\n</code></pre> Adds all arguments. With no arguments, returns 0.</p>"},{"location":"language/prelude/#-subtraction","title":"<code>-</code> (Subtraction)","text":"<p><pre><code>[\"-\", 10, 3, 2]   // \u2192 5 (10 - 3 - 2)\n[\"-\", 5]          // \u2192 -5 (negation)\n[\"-\"]             // \u2192 0\n</code></pre> Subtracts subsequent arguments from the first. With one argument, returns negation.</p>"},{"location":"language/prelude/#multiplication","title":"<code>*</code> (Multiplication)","text":"<p><pre><code>[\"*\", 2, 3, 4]    // \u2192 24\n[\"*\", 5]          // \u2192 5\n[\"*\"]             // \u2192 1\n</code></pre> Multiplies all arguments. With no arguments, returns 1.</p>"},{"location":"language/prelude/#division","title":"<code>/</code> (Division)","text":"<p><pre><code>[\"/\", 12, 3, 2]   // \u2192 2.0 (12 / 3 / 2)\n[\"/\", 5]          // \u2192 0.2 (1 / 5)\n</code></pre> Divides the first argument by all subsequent arguments. With one argument, returns reciprocal.</p>"},{"location":"language/prelude/#mod-modulo","title":"<code>mod</code> (Modulo)","text":"<p><pre><code>[\"mod\", 10, 3]    // \u2192 1\n[\"mod\", 7, 0]     // \u2192 0 (safe: returns 0 for division by zero)\n</code></pre> Returns the remainder of division.</p>"},{"location":"language/prelude/#pow-exponentiation","title":"<code>pow</code> (Exponentiation)","text":"<p><pre><code>[\"pow\", 2, 3]     // \u2192 8\n[\"pow\", 9, 0.5]   // \u2192 3.0\n</code></pre> Raises the first argument to the power of the second.</p>"},{"location":"language/prelude/#comparison-operations","title":"Comparison Operations","text":"<p>Chained comparisons supporting mathematical notation.</p>"},{"location":"language/prelude/#equality","title":"<code>=</code> (Equality)","text":"<p><pre><code>[\"=\", 1, 1, 1]        // \u2192 true\n[\"=\", 1, 2]           // \u2192 false\n[\"=\", \"a\", \"a\", \"a\"]  // \u2192 true\n</code></pre> Returns true if all arguments are equal.</p>"},{"location":"language/prelude/#less-than","title":"<code>&lt;</code> (Less Than)","text":"<p><pre><code>[\"&lt;\", 1, 2, 3]    // \u2192 true (1 &lt; 2 &lt; 3)\n[\"&lt;\", 1, 3, 2]    // \u2192 false\n</code></pre> Returns true if arguments form an ascending sequence.</p>"},{"location":"language/prelude/#greater-than","title":"<code>&gt;</code> (Greater Than)","text":"<p><pre><code>[\"&gt;\", 3, 2, 1]    // \u2192 true (3 &gt; 2 &gt; 1)\n[\"&gt;\", 3, 1, 2]    // \u2192 false\n</code></pre> Returns true if arguments form a descending sequence.</p>"},{"location":"language/prelude/#less-than-or-equal","title":"<code>&lt;=</code> (Less Than or Equal)","text":"<p><pre><code>[\"&lt;=\", 1, 2, 2, 3]  // \u2192 true\n[\"&lt;=\", 1, 3, 2]     // \u2192 false\n</code></pre> Returns true if arguments form a non-decreasing sequence.</p>"},{"location":"language/prelude/#greater-than-or-equal","title":"<code>&gt;=</code> (Greater Than or Equal)","text":"<p><pre><code>[\"&gt;=\", 3, 2, 2, 1]  // \u2192 true\n[\"&gt;=\", 3, 1, 2]     // \u2192 false\n</code></pre> Returns true if arguments form a non-increasing sequence.</p>"},{"location":"language/prelude/#logical-operations","title":"Logical Operations","text":"<p>Logical operations with n-arity support and short-circuiting.</p>"},{"location":"language/prelude/#and","title":"<code>and</code>","text":"<p><pre><code>[\"and\", true, true, true]   // \u2192 true\n[\"and\", true, false, true]  // \u2192 false\n[\"and\"]                     // \u2192 true\n</code></pre> Returns true if all arguments are truthy.</p>"},{"location":"language/prelude/#or","title":"<code>or</code>","text":"<p><pre><code>[\"or\", false, false, true]  // \u2192 true\n[\"or\", false, false]        // \u2192 false\n[\"or\"]                      // \u2192 false\n</code></pre> Returns true if any argument is truthy.</p>"},{"location":"language/prelude/#not","title":"<code>not</code>","text":"<p><pre><code>[\"not\", true]    // \u2192 false\n[\"not\", false]   // \u2192 true\n[\"not\", 0]       // \u2192 true\n[\"not\", \"\"]      // \u2192 true\n</code></pre> Returns the logical negation of the argument.</p>"},{"location":"language/prelude/#type-predicates","title":"Type Predicates","text":"<p>Essential for wire format validation and dynamic type checking.</p>"},{"location":"language/prelude/#null","title":"<code>null?</code>","text":"<p><pre><code>[\"null?\", null]    // \u2192 true\n[\"null?\", 0]       // \u2192 false\n[\"null?\", false]   // \u2192 false\n</code></pre> Returns true if the value is null.</p>"},{"location":"language/prelude/#bool","title":"<code>bool?</code>","text":"<p><pre><code>[\"bool?\", true]    // \u2192 true\n[\"bool?\", false]   // \u2192 true\n[\"bool?\", 0]       // \u2192 false\n</code></pre> Returns true if the value is a boolean.</p>"},{"location":"language/prelude/#number","title":"<code>number?</code>","text":"<p><pre><code>[\"number?\", 42]      // \u2192 true\n[\"number?\", 3.14]    // \u2192 true\n[\"number?\", \"42\"]    // \u2192 false\n</code></pre> Returns true if the value is a number (integer or float).</p>"},{"location":"language/prelude/#string","title":"<code>string?</code>","text":"<p><pre><code>[\"string?\", \"hello\"]  // \u2192 true\n[\"string?\", 42]       // \u2192 false\n</code></pre> Returns true if the value is a string.</p>"},{"location":"language/prelude/#list_1","title":"<code>list?</code>","text":"<p><pre><code>[\"list?\", [1, 2, 3]]  // \u2192 true\n[\"list?\", \"hello\"]    // \u2192 false\n</code></pre> Returns true if the value is a list.</p>"},{"location":"language/prelude/#dict","title":"<code>dict?</code>","text":"<p><pre><code>[\"dict?\", {\"a\": 1}]   // \u2192 true\n[\"dict?\", [1, 2]]     // \u2192 false\n</code></pre> Returns true if the value is a dictionary.</p>"},{"location":"language/prelude/#callable","title":"<code>callable?</code>","text":"<p><pre><code>[\"callable?\", [\"lambda\", [\"x\"], \"x\"]]  // \u2192 true (after evaluation)\n[\"callable?\", 42]                      // \u2192 false\n</code></pre> Returns true if the value is callable (function or closure).</p>"},{"location":"language/prelude/#string-operations","title":"String Operations","text":"<p>String manipulation functions for text processing.</p>"},{"location":"language/prelude/#str-concat","title":"<code>str-concat</code>","text":"<p><pre><code>[\"str-concat\", \"Hello\", \" \", \"World\"]  // \u2192 \"Hello World\"\n[\"str-concat\", \"Number: \", 42]         // \u2192 \"Number: 42\"\n</code></pre> Concatenates all arguments after converting them to strings.</p>"},{"location":"language/prelude/#str-split","title":"<code>str-split</code>","text":"<p><pre><code>[\"str-split\", \"a,b,c\", \",\"]     // \u2192 [\"a\", \"b\", \"c\"]\n[\"str-split\", \"hello world\"]    // \u2192 [\"hello\", \"world\"] (default: space)\n</code></pre> Splits a string by the specified separator.</p>"},{"location":"language/prelude/#str-join","title":"<code>str-join</code>","text":"<p><pre><code>[\"str-join\", [\"a\", \"b\", \"c\"], \",\"]    // \u2192 \"a,b,c\"\n[\"str-join\", [1, 2, 3], \"-\"]          // \u2192 \"1-2-3\"\n[\"str-join\", [\"a\", \"b\"]]              // \u2192 \"ab\" (default: empty string)\n</code></pre> Joins a list of values into a string with the specified separator.</p>"},{"location":"language/prelude/#str-length","title":"<code>str-length</code>","text":"<p><pre><code>[\"str-length\", \"hello\"]    // \u2192 5\n[\"str-length\", \"\"]         // \u2192 0\n</code></pre> Returns the length of a string.</p>"},{"location":"language/prelude/#str-upper","title":"<code>str-upper</code>","text":"<p><pre><code>[\"str-upper\", \"hello\"]     // \u2192 \"HELLO\"\n</code></pre> Converts a string to uppercase.</p>"},{"location":"language/prelude/#str-lower","title":"<code>str-lower</code>","text":"<p><pre><code>[\"str-lower\", \"HELLO\"]     // \u2192 \"hello\"\n</code></pre> Converts a string to lowercase.</p>"},{"location":"language/prelude/#higher-order-functions","title":"Higher-Order Functions","text":"<p>The cornerstone of functional programming, enabling composition and abstraction.</p>"},{"location":"language/prelude/#map","title":"<code>map</code>","text":"<p><pre><code>[\"map\", [\"lambda\", [\"x\"], [\"*\", \"x\", 2]], [1, 2, 3]]  // \u2192 [2, 4, 6]\n[\"map\", \"+\", [[1, 2], [3, 4]]]                        // \u2192 [3, 7]\n</code></pre> Applies a function to each element of a list, returning a new list of results.</p>"},{"location":"language/prelude/#filter","title":"<code>filter</code>","text":"<p><pre><code>[\"filter\", [\"lambda\", [\"x\"], [\"&gt;\", \"x\", 5]], [1, 6, 3, 8, 2]]  // \u2192 [6, 8]\n[\"filter\", \"even?\", [1, 2, 3, 4, 5, 6]]                        // \u2192 [2, 4, 6]\n</code></pre> Returns a new list containing only elements for which the predicate returns true.</p>"},{"location":"language/prelude/#reduce","title":"<code>reduce</code>","text":"<p><pre><code>[\"reduce\", \"+\", [1, 2, 3, 4]]           // \u2192 10\n[\"reduce\", \"*\", [1, 2, 3, 4], 1]        // \u2192 24 (with initial value)\n[\"reduce\", \"max\", [3, 1, 4, 1, 5]]      // \u2192 5\n</code></pre> Reduces a list to a single value by repeatedly applying a binary function.</p>"},{"location":"language/prelude/#apply","title":"<code>apply</code>","text":"<p><pre><code>[\"apply\", \"+\", [1, 2, 3]]                    // \u2192 6\n[\"apply\", [\"lambda\", [\"x\", \"y\"], [\"*\", \"x\", \"y\"]], [3, 4]]  // \u2192 12\n</code></pre> Applies a function to a list of arguments.</p>"},{"location":"language/prelude/#mathematical-functions","title":"Mathematical Functions","text":"<p>Extended mathematical operations for scientific computing.</p>"},{"location":"language/prelude/#min-max","title":"<code>min</code> / <code>max</code>","text":"<p><pre><code>[\"min\", 3, 1, 4, 1, 5]  // \u2192 1\n[\"max\", 3, 1, 4, 1, 5]  // \u2192 5\n</code></pre> Returns the minimum or maximum of the arguments.</p>"},{"location":"language/prelude/#abs","title":"<code>abs</code>","text":"<p><pre><code>[\"abs\", -5]    // \u2192 5\n[\"abs\", 3.14]  // \u2192 3.14\n</code></pre> Returns the absolute value.</p>"},{"location":"language/prelude/#round","title":"<code>round</code>","text":"<p><pre><code>[\"round\", 3.7]     // \u2192 4\n[\"round\", 3.14159, 2]  // \u2192 3.14\n</code></pre> Rounds to the nearest integer or specified decimal places.</p>"},{"location":"language/prelude/#trigonometric-functions","title":"Trigonometric Functions","text":"<p><pre><code>[\"sin\", 1.5708]    // \u2192 ~1.0 (\u03c0/2)\n[\"cos\", 0]         // \u2192 1.0\n[\"tan\", 0.7854]    // \u2192 ~1.0 (\u03c0/4)\n</code></pre> Standard trigonometric functions (arguments in radians).</p>"},{"location":"language/prelude/#sqrt","title":"<code>sqrt</code>","text":"<p><pre><code>[\"sqrt\", 16]   // \u2192 4.0\n[\"sqrt\", 2]    // \u2192 ~1.414\n</code></pre> Returns the square root.</p>"},{"location":"language/prelude/#log-exp","title":"<code>log</code> / <code>exp</code>","text":"<p><pre><code>[\"log\", 2.718]   // \u2192 ~1.0 (natural log)\n[\"exp\", 1]       // \u2192 ~2.718 (e^1)\n</code></pre> Natural logarithm and exponential functions.</p>"},{"location":"language/prelude/#type-conversion","title":"Type Conversion","text":"<p>Safe type conversion functions with reasonable defaults.</p>"},{"location":"language/prelude/#to-string","title":"<code>to-string</code>","text":"<p><pre><code>[\"to-string\", 42]     // \u2192 \"42\"\n[\"to-string\", true]   // \u2192 \"True\"\n[\"to-string\", [1,2]]  // \u2192 \"[1, 2]\"\n</code></pre> Converts any value to its string representation.</p>"},{"location":"language/prelude/#to-number","title":"<code>to-number</code>","text":"<p><pre><code>[\"to-number\", \"42\"]      // \u2192 42.0\n[\"to-number\", \"3.14\"]    // \u2192 3.14\n[\"to-number\", \"hello\"]   // \u2192 0 (safe default)\n</code></pre> Attempts to convert a value to a number, returning 0 for invalid inputs.</p>"},{"location":"language/prelude/#type-of","title":"<code>type-of</code>","text":"<p><pre><code>[\"type-of\", 42]        // \u2192 \"int\"\n[\"type-of\", \"hello\"]   // \u2192 \"str\"\n[\"type-of\", [1, 2]]    // \u2192 \"list\"\n</code></pre> Returns the type name of a value.</p>"},{"location":"language/prelude/#io-operations","title":"I/O Operations","text":"<p>Basic I/O functions (can be customized in sandboxed environments).</p>"},{"location":"language/prelude/#print","title":"<code>print</code>","text":"<p><pre><code>[\"print\", \"Hello, World!\"]  // Outputs: Hello, World!\n[\"print\", 42, \"is the answer\"]  // Outputs: 42 is the answer\n</code></pre> Prints values to standard output.</p>"},{"location":"language/prelude/#error","title":"<code>error</code>","text":"<p><pre><code>[\"error\", \"Something went wrong!\"]  // Raises RuntimeError\n</code></pre> Raises a runtime error with the specified message.</p>"},{"location":"language/prelude/#integration-with-jsl-closures","title":"Integration with JSL Closures","text":"<p>All higher-order functions in the prelude work seamlessly with JSL closures through the <code>eval_closure_or_builtin</code> integration layer. This ensures that:</p> <ol> <li>Lexical scoping is preserved - Closures maintain access to their captured environments</li> <li>Built-in access is guaranteed - All closures can access prelude functions</li> <li>Performance is optimized - Environment chains are linked efficiently at call time</li> <li>Serialization is safe - Only user bindings are serialized with closures</li> </ol> <p>This design enables powerful functional programming patterns while maintaining JSL's core promise of safe, network-transmissible code.</p>"},{"location":"language/query-operations/","title":"Query Operations","text":"<p>JSL provides powerful declarative operations for querying and filtering data, inspired by dotsuite's pedagogical approach to JSON manipulation.</p>"},{"location":"language/query-operations/#the-where-special-form","title":"The <code>where</code> Special Form","text":"<p>The <code>where</code> is a special form (not a function) that provides SQL-like declarative filtering. As a special form, it has special evaluation semantics that automatically bind item fields to the environment before evaluating the condition.</p>"},{"location":"language/query-operations/#basic-syntax","title":"Basic Syntax","text":"<pre><code>(where collection condition)\n</code></pre> <p>The condition is evaluated with each item's fields automatically bound to the environment.</p>"},{"location":"language/query-operations/#examples","title":"Examples","text":""},{"location":"language/query-operations/#simple-filtering","title":"Simple Filtering","text":"<pre><code>; Filter users by role\n(where users (= role \"admin\"))\n\n; Filter products by price\n(where products (&gt; price 100))\n</code></pre>"},{"location":"language/query-operations/#complex-conditions","title":"Complex Conditions","text":"<pre><code>; AND conditions\n(where users \n  (and (= role \"admin\") \n       active))\n\n; OR conditions  \n(where products\n  (or (= category \"electronics\")\n      (&lt; price 50)))\n\n; Nested conditions\n(where orders\n  (and (&gt;= total 100)\n       (or (= status \"pending\")\n           (= status \"processing\"))))\n</code></pre>"},{"location":"language/query-operations/#field-binding","title":"Field Binding","text":"<p>The <code>where</code> special form automatically extends the environment with each item's fields. For objects, all key-value pairs become available as variables. For non-objects, the item is bound to <code>it</code>:</p> <pre><code>(def users [@\n  {\"name\": \"Alice\", \"age\": 30, \"role\": \"admin\"}\n  {\"name\": \"Bob\", \"age\": 25, \"role\": \"user\"}\n])\n\n; 'role' and 'age' are automatically bound from each user\n(where users (and (= role \"admin\") (&gt; age 25)))\n; Returns: [{\"name\": \"Alice\", \"age\": 30, \"role\": \"admin\"}]\n</code></pre>"},{"location":"language/query-operations/#string-literals-vs-field-references","title":"String Literals vs Field References","text":"<ul> <li>Field names are symbols that get looked up: <code>role</code>, <code>age</code>, <code>name</code></li> <li>String literals use the @ prefix: <code>\"@admin\"</code>, <code>\"@user\"</code></li> </ul> <pre><code>(where users (= role \"@admin\"))  ; role field equals string \"admin\"\n(where users (= \"@role\" role))   ; string \"role\" equals role field (unusual)\n</code></pre>"},{"location":"language/query-operations/#query-composition","title":"Query Composition","text":"<p>Query operations compose naturally with other JSL operations:</p>"},{"location":"language/query-operations/#filter-then-transform","title":"Filter then Transform","text":"<pre><code>(transform\n  (where products (&gt; price 50))\n  (pick \"@name\" \"@price\"))\n</code></pre>"},{"location":"language/query-operations/#filter-then-pluck","title":"Filter then Pluck","text":"<pre><code>(pluck\n  (where users (= role \"@admin\"))\n  \"@email\")\n</code></pre>"},{"location":"language/query-operations/#multiple-filters","title":"Multiple Filters","text":"<pre><code>(where\n  (where products (= category \"@electronics\"))\n  (&gt; price 100))\n</code></pre>"},{"location":"language/query-operations/#implementation-details","title":"Implementation Details","text":"<p>As a special form, <code>where</code> is implemented directly in the evaluator (<code>_eval_where</code> in <code>core.py</code>), not as a prelude function. This allows it to: - Control evaluation order - Automatically bind fields without explicit lambda expressions - Integrate seamlessly with the JSL evaluation model - Work identically in both recursive and stack evaluators</p>"},{"location":"language/query-operations/#performance-considerations","title":"Performance Considerations","text":"<p>The <code>where</code> operator: - Uses the standard JSL evaluator for conditions - Extends the environment once per item - Short-circuits on false conditions - Maintains original collection order</p>"},{"location":"language/query-operations/#comparison-with-traditional-approaches","title":"Comparison with Traditional Approaches","text":""},{"location":"language/query-operations/#traditional-lambda-approach","title":"Traditional Lambda Approach","text":"<pre><code>(filter \n  (lambda (user) \n    (and (= (get user \"@role\") \"@admin\")\n         (get user \"@active\")))\n  users)\n</code></pre>"},{"location":"language/query-operations/#declarative-where-approach","title":"Declarative Where Approach","text":"<pre><code>(where users (and (= role \"@admin\") active))\n</code></pre> <p>The declarative approach is: - More concise and readable - Automatically handles field binding - Consistent with SQL-like query languages - Easier to compose with other operations</p>"},{"location":"language/query-operations/#integration-with-transform","title":"Integration with Transform","text":"<p><code>where</code> and <code>transform</code> work together for powerful data pipelines:</p> <pre><code>; Get names of active admins\n(pluck\n  (where users (and (= role \"@admin\") active))\n  \"@name\")\n\n; Add discount to expensive products\n(transform\n  (where products (&gt; price 100))\n  (assign \"@discounted\" (* price 0.9)))\n</code></pre>"},{"location":"language/query-operations/#see-also","title":"See Also","text":"<ul> <li>Transform Operations - Data transformation operations</li> <li>Path Navigation - Deep JSON path access</li> <li>Prelude Functions - Built-in collection functions</li> </ul>"},{"location":"language/semantics/","title":"Syntax and Semantics","text":""},{"location":"language/semantics/#overview","title":"Overview","text":"<p>JSL uses JSON as its native syntax, making it both human-readable and machine-parseable. Every JSL program is a valid JSON value, and this document describes how those values are interpreted and evaluated.</p>"},{"location":"language/semantics/#core-concepts","title":"Core Concepts","text":"<ol> <li>Homoiconicity: Code and data share the same fundamental representation (JSON).</li> <li>Evaluation Environments: Expressions are evaluated within a specific environment that holds variable bindings and links to a parent.</li> <li>Lisp-like Evaluation: The evaluation logic follows a pattern similar to Lisp, with prefix notation for function calls.</li> </ol>"},{"location":"language/semantics/#syntax-and-evaluation-rules","title":"Syntax and Evaluation Rules","text":""},{"location":"language/semantics/#1-literals-self-evaluating-values","title":"1. Literals (Self-Evaluating Values)","text":"<p>Most JSON primitives are literals; they evaluate to themselves.</p> <ul> <li>Numbers: <code>42</code> \u2192 <code>42</code></li> <li>Booleans: <code>true</code> \u2192 <code>true</code></li> <li>Null: <code>null</code> \u2192 <code>null</code></li> <li>Objects: <code>{\"key\": \"value\"}</code> \u2192 <code>{\"key\": \"value\"}</code></li> </ul>"},{"location":"language/semantics/#2-strings-literals-vs-variables","title":"2. Strings: Literals vs. Variables","text":"<p>The interpretation of a string depends on its syntax.</p> <ul> <li>Variable Reference: A standard string is treated as a variable lookup. The evaluator will search the current environment for its value.<ul> <li><code>\"x\"</code> \u2192 The value bound to the name <code>x</code>.</li> </ul> </li> <li>String Literal: A string prefixed with <code>@</code> is treated as a literal value.<ul> <li><code>\"@hello\"</code> \u2192 The string <code>\"hello\"</code>.</li> </ul> </li> </ul>"},{"location":"language/semantics/#3-arrays-function-calls-and-special-forms","title":"3. Arrays: Function Calls and Special Forms","text":"<p>Arrays are the primary mechanism for computation in JSL. An array is evaluated by inspecting its first element.</p> <ul> <li>Empty Array: An empty array <code>[]</code> evaluates to itself, representing an empty list.</li> <li> <p>Function Call: If the first element is not a special form, the array represents a function call.</p> <ol> <li>All elements of the array (the operator and all arguments) are evaluated in order.</li> <li>The result of the first element (which must be a function) is applied to the results of the remaining elements.</li> <li><code>[\"+\", 1, \"x\"]</code> \u2192 Evaluates <code>+</code>, <code>1</code>, and <code>x</code>, then applies the addition function to the results.</li> </ol> </li> <li> <p>Special Forms: If the first element is a special form, a unique evaluation rule is applied. These forms provide the core control flow and structural logic of the language. Not all arguments are necessarily evaluated.</p> </li> </ul> Form Syntax Description <code>def</code> <code>[\"def\", \"name\", expr]</code> Binds the result of <code>expr</code> to <code>name</code> in the current environment. <code>lambda</code> <code>[\"lambda\", [params], body]</code> Creates a function (closure). Does not evaluate the body. <code>if</code> <code>[\"if\", cond, then, else]</code> Evaluates <code>cond</code>. If truthy, evaluates <code>then</code>, otherwise evaluates <code>else</code>. <code>do</code> <code>[\"do\", expr1, expr2, ...]</code> Evaluates expressions in sequence, returning the result of the last one. <code>quote</code> / <code>@</code> <code>[\"quote\", expr]</code> or <code>[\"@\", expr]</code> Returns <code>expr</code> as literal data without evaluating it. <code>try</code> <code>[\"try\", body, handler]</code> Evaluates <code>body</code>. If an error occurs, evaluates <code>handler</code> with the error. <code>host</code> <code>[\"host\", cmd, ...]</code> Sends a request to the host environment."},{"location":"language/semantics/#complete-example","title":"Complete Example","text":"<p>This expression calculates the factorial of 5, demonstrating variable definition (<code>def</code>), function creation (<code>lambda</code>), conditional logic (<code>if</code>), and recursive function calls.</p> <pre><code>[\"do\",\n  [\"def\", \"factorial\", \n    [\"lambda\", [\"n\"], \n      [\"if\", [\"&lt;=\", \"n\", 1], \n        1, \n        [\"*\", \"n\", [\"factorial\", [\"-\", \"n\", 1]]]\n      ]\n    ]\n  ],\n  [\"factorial\", 5]\n]\n</code></pre>"},{"location":"language/semantics/#jsl-for-data-construction-json-objects-as-first-class-citizens","title":"JSL for Data Construction: JSON Objects as First-Class Citizens","text":"<p>While the semantics described above define JSL as a general-purpose computation language, JSL also treats JSON objects as first-class data structures with special properties that make them ideal for data construction.</p> <p>Unlike arrays (which are interpreted as S-expressions), JSON objects are always treated as data structures: - Objects are never function calls: <code>{\"name\": \"Alice\"}</code> is always a data structure - Keys and values are evaluated: Both use normal JSL evaluation rules - Keys must be strings: Runtime type checking ensures valid JSON output - No operator ambiguity: Objects provide a \"safe zone\" for pure data construction</p> <p>This design makes JSL particularly well-suited for generating clean JSON output without worrying about the first element being interpreted as an operator.</p> <p>For a complete guide on object construction, see the JSON Objects documentation.</p>"},{"location":"language/special-forms/","title":"JSL Special Forms","text":""},{"location":"language/special-forms/#overview","title":"Overview","text":"<p>Special forms are the fundamental building blocks of JSL that have special evaluation rules. Unlike regular function calls, special forms control how their arguments are evaluated and provide the core language constructs for variable binding, control flow, and meta-programming.</p>"},{"location":"language/special-forms/#core-special-forms","title":"Core Special Forms","text":""},{"location":"language/special-forms/#variable-definition-def","title":"Variable Definition - <code>def</code>","text":"<p>Binds a value to a variable name in the current environment.</p> <pre><code>[\"def\", \"variable_name\", value_expression]\n</code></pre> <p>Evaluation Rules: 1. Evaluate <code>value_expression</code>  2. Bind the result to <code>variable_name</code> in current environment 3. Return the bound value</p> <p>Examples:</p> <pre><code>// Simple value binding\n[\"def\", \"x\", 42]\n// Result: 42, x is now bound to 42\n\n// Expression binding\n[\"def\", \"doubled\", [\"*\", \"x\", 2]]\n// Result: 84, doubled is now bound to 84\n\n// Function binding\n[\"def\", \"square\", [\"lambda\", [\"n\"], [\"*\", \"n\", \"n\"]]]\n// Result: &lt;function&gt;, square is now bound to the function\n</code></pre>"},{"location":"language/special-forms/#function-definition-lambda","title":"Function Definition - <code>lambda</code>","text":"<p>Creates anonymous functions (closures) that capture their lexical environment.</p> <pre><code>[\"lambda\", [\"param1\", \"param2\", ...], body_expression]\n</code></pre> <p>Evaluation Rules: 1. Do NOT evaluate parameters (they are binding names) 2. Do NOT evaluate body (it's evaluated when function is called) 3. Capture current environment as closure environment 4. Return function object</p> <p>Examples:</p> <pre><code>// Simple function\n[\"lambda\", [\"x\"], [\"*\", \"x\", \"x\"]]\n// Result: &lt;function: x -&gt; x * x&gt;\n\n// Multi-parameter function\n[\"lambda\", [\"a\", \"b\"], [\"+\", \"a\", \"b\"]]\n// Result: &lt;function: (a, b) -&gt; a + b&gt;\n\n// Function with closure\n[\"do\",\n  [\"def\", \"multiplier\", 10],\n  [\"lambda\", [\"x\"], [\"*\", \"x\", \"multiplier\"]]]\n// Result: &lt;function: x -&gt; x * 10&gt; (captures multiplier=10)\n\n// Higher-order function\n[\"lambda\", [\"f\", \"x\"], [\"f\", [\"f\", \"x\"]]]\n// Result: &lt;function: (f, x) -&gt; f(f(x))&gt;\n</code></pre>"},{"location":"language/special-forms/#conditional-evaluation-if","title":"Conditional Evaluation - <code>if</code>","text":"<p>Provides conditional branching with lazy evaluation of branches.</p> <pre><code>[\"if\", condition_expression, then_expression, else_expression]\n</code></pre> <p>Evaluation Rules: 1. Evaluate <code>condition_expression</code> 2. If truthy, evaluate and return <code>then_expression</code> 3. If falsy, evaluate and return <code>else_expression</code> 4. Only one branch is evaluated (lazy evaluation)</p> <p>Examples:</p> <pre><code>// Basic conditional\n[\"if\", [\"&gt;\", \"x\", 0], \"positive\", \"non-positive\"]\n\n// Nested conditionals\n[\"if\", [\"=\", \"status\", \"admin\"],\n  \"full_access\",\n  [\"if\", [\"=\", \"status\", \"user\"], \"limited_access\", \"no_access\"]]\n\n// With side effects (only one branch executes)\n[\"if\", \"debug_mode\",\n  [\"host\", \"log\", \"Debug information\"],\n  [\"host\", \"log\", \"Production mode\"]]\n</code></pre>"},{"location":"language/special-forms/#local-bindings-let","title":"Local Bindings - <code>let</code>","text":"<p>Creates temporary, local variable bindings for use within a single expression. This is a cornerstone of functional programming as it avoids mutating the parent environment.</p> <pre><code>[\"let\", [[\"var1\", val1_expr], [\"var2\", val2_expr]], body_expr]\n</code></pre> <p>Evaluation Rules: 1. Create a new, temporary environment that extends the current one. 2. Evaluate all <code>val_expr</code>s in the original environment. 3. Bind the results to the <code>var</code> names in the new temporary environment. 4. Evaluate <code>body_expr</code> in the new environment. 5. Return the result of <code>body_expr</code>. The temporary environment is then discarded.</p> <p>Example: <pre><code>// Calculate area of a circle without polluting the environment\n[\"let\", [[\"pi\", 3.14159], [\"r\", 10]],\n  [\"*\", \"pi\", [\"*\", \"r\", \"r\"]]]\n// Result: 314.159 (pi and r are not defined afterwards)\n</code></pre></p>"},{"location":"language/special-forms/#error-handling-try","title":"Error Handling - <code>try</code>","text":"<p>Provides a mechanism to catch and handle errors that occur during evaluation.</p> <pre><code>[\"try\", body_expression, handler_expression]\n</code></pre> <p>Evaluation Rules: 1. Evaluate <code>body_expression</code>. 2. If evaluation succeeds, its result is the result of the <code>try</code> expression. The <code>handler_expression</code> is not evaluated. 3. If an error occurs during the evaluation of <code>body_expression</code>, the <code>handler_expression</code> is evaluated. The handler should be a function that accepts the error object as its argument. The result of the handler becomes the result of the entire <code>try</code> expression.</p> <p>Example: <pre><code>// Safe file reading with a fallback default\n[\"try\",\n  [\"host\", \"file/read\", \"/app/config.json\"],\n  [\"lambda\", [\"err\"],\n    [\"do\",\n      [\"host\", \"log/warn\", [\"str-concat\", \"Config not found, using default: \", [\"get\", \"err\", \"message\"]]],\n      { \"default_setting\": true }\n    ]\n  ]\n]\n</code></pre></p>"},{"location":"language/special-forms/#sequential-evaluation-do","title":"Sequential Evaluation - <code>do</code>","text":"<p>Evaluates multiple expressions in sequence and returns the result of the final expression.</p> <p>While JSL encourages a functional style using <code>let</code> and function composition, <code>do</code> is provided as a pragmatic tool for imperative-style sequencing, especially when dealing with multiple side-effects.</p> <p>Design Note: Why is there no <code>for</code> or <code>while</code> loop?</p> <p>JSL intentionally omits traditional <code>for</code> or <code>while</code> loop special forms. This is a core design decision to encourage a functional approach to collection processing. Instead of imperative looping, you should use the powerful higher-order functions provided in the prelude: - <code>map</code>: To transform each element in a list. - <code>filter</code>: To select elements from a list. - <code>reduce</code>: To aggregate a list into a single value. - <code>for_each</code>: To perform a side-effect for each element in a list.</p> <p>These functions are safer, more declarative, and more composable than manual loops.</p>"},{"location":"language/special-forms/#quotation-quote-and","title":"Quotation - <code>quote</code> and <code>@</code>","text":"<p>Prevents evaluation of expressions, returning them as literal data.</p> <pre><code>[\"quote\", expression]\n[\"@\", expression]  // Shorthand syntax\n</code></pre> <p>There  is also a syntactic sugar for quoting simple expressions:</p> <p><pre><code>[\"quote\", \"hello\"]  // Result: \"hello\"\n\"@hello\"// Result: \"hello\" (same as above)\n</code></pre> It is only useful for simple values, as it does not allow for complex expressions, such as: <code>[\"@\", [\"+\", 1, 2]]</code>.</p> <p>Evaluation Rules: 1. Do NOT evaluate the argument 2. Return the argument as literal data 3. Preserves structure without interpretation</p> <p>Examples:</p> <pre><code>// Quote simple values\n[\"quote\", \"hello\"]     // Result: \"hello\"\n[\"@\", \"hello\"]         // Result: \"hello\" (same as above)\n\n// Quote expressions\n[\"quote\", [\"+\", 1, 2]]  // Result: [\"+\", 1, 2] (not 3)\n[\"@\", [\"+\", 1, 2]]      // Result: [\"+\", 1, 2]\n\n// Quote for data structure creation\n[\"@\", {\"name\": \"Alice\", \"age\": 30}]\n// Result: {\"name\": \"Alice\", \"age\": 30}\n\n// Compare quoted vs unquoted\n[\"def\", \"expr\", [\"@\", [\"+\", \"x\", \"y\"]]]  // Store expression as data\n[\"def\", \"result\", [\"+\", \"x\", \"y\"]]       // Store computed result\n</code></pre>"},{"location":"language/special-forms/#host-interaction-host","title":"Host Interaction - <code>host</code>","text":"<p>Provides controlled interaction with the host environment through JHIP.</p> <pre><code>[\"host\", command_id_expression, arg1_expression, ...]\n</code></pre> <p>Evaluation Rules: 1. Evaluate <code>command_id_expression</code> to get command identifier 2. Evaluate all argument expressions 3. Send JHIP request to host with command and arguments 4. Return host response</p> <p>Examples:</p> <pre><code>// File operations\n[\"host\", \"file/read\", \"/path/to/file.txt\"]\n[\"host\", \"file/write\", \"/path/to/output.txt\", \"content\"]\n\n// System commands\n[\"host\", \"system/exec\", \"ls\", [\"-la\"]]\n\n// Network requests\n[\"host\", \"http/get\", \"https://api.example.com/data\"]\n\n// Time operations\n[\"host\", \"time/now\"]\n[\"host\", \"time/format\", \"2023-12-01T10:30:00Z\", \"ISO\"]\n</code></pre>"},{"location":"language/special-forms/#special-form-properties","title":"Special Form Properties","text":""},{"location":"language/special-forms/#argument-evaluation-control","title":"Argument Evaluation Control","text":"<p>Unlike regular functions, special forms control when and if their arguments are evaluated:</p> Special Form Evaluation Pattern <code>def</code> Evaluate value, don't evaluate variable name <code>lambda</code> Don't evaluate parameters or body <code>if</code> Evaluate condition, then only one branch <code>let</code> Evaluate bindings, then body in new scope <code>try</code> Evaluate body, then handler only on error <code>do</code> Evaluate all arguments in sequence <code>quote</code>/<code>@</code> Don't evaluate argument at all <code>host</code> Evaluate all arguments"},{"location":"language/special-forms/#environment-interaction","title":"Environment Interaction","text":"<p>Special forms interact with the environment in specific ways:</p> <pre><code>// def modifies environment\n[\"do\",\n  [\"def\", \"x\", 10],        // Adds x=10 to environment\n  [\"def\", \"y\", [\"*\", \"x\", 2]], // Uses x from environment, adds y=20\n  [\"+\", \"x\", \"y\"]]         // Uses both x and y: result 30\n\n// lambda captures environment\n[\"do\",\n  [\"def\", \"base\", 100],\n  [\"def\", \"adder\", [\"lambda\", [\"n\"], [\"+\", \"n\", \"base\"]]],\n  [\"adder\", 23]]           // Result: 123 (uses captured base=100)\n</code></pre>"},{"location":"language/special-forms/#meta-programming-with-special-forms","title":"Meta-Programming with Special Forms","text":""},{"location":"language/special-forms/#code-generation","title":"Code Generation","text":"<pre><code>// Generate conditional code\n[\"def\", \"make_comparator\", \n  [\"lambda\", [\"op\"], \n    [\"@\", [\"lambda\", [\"a\", \"b\"], [\"op\", \"a\", \"b\"]]]]]\n\n// Usage\n[\"def\", \"greater_than\", [\"make_comparator\", \"&gt;\"]]\n[\"greater_than\", 5, 3]  // Result: true\n</code></pre>"},{"location":"language/special-forms/#dynamic-function-creation","title":"Dynamic Function Creation","text":"<pre><code>// Create functions with varying parameter counts\n[\"def\", \"make_n_ary_function\",\n  [\"lambda\", [\"params\", \"body\"],\n    [\"list\", \"@lambda\", \"params\", \"body\"]]]\n\n[\"def\", \"triple_add\", \n  [\"make_n_ary_function\", \n    [\"@\", [\"a\", \"b\", \"c\"]], \n    [\"@\", [\"+\", [\"+\", \"a\", \"b\"], \"c\"]]]]\n</code></pre>"},{"location":"language/special-forms/#macro-like-patterns","title":"Macro-like Patterns","text":"<pre><code>// Define a \"when\" macro-like construct\n[\"def\", \"when\",\n  [\"lambda\", [\"condition\", \"action\"],\n    [\"if\", \"condition\", \"action\", null]]]\n\n// Usage\n[\"when\", [\"&gt;\", \"temperature\", 30], \n  [\"host\", \"log\", \"@It's hot outside!\"]]\n</code></pre>"},{"location":"language/special-forms/#advanced-special-form-usage","title":"Advanced Special Form Usage","text":""},{"location":"language/special-forms/#combining-special-forms","title":"Combining Special Forms","text":"<pre><code>// Complex initialization pattern\n[\"do\",\n  [\"def\", \"config\", [\"host\", \"file/read\", \"config.json\"]],\n  [\"def\", \"database\", \n    [\"if\", [\"get\", \"config\", \"use_database\"],\n      [\"host\", \"db/connect\", [\"get\", \"config\", \"db_url\"]],\n      null]],\n  [\"def\", \"processor\",\n    [\"lambda\", [\"data\"],\n      [\"if\", \"database\",\n        [\"host\", \"db/store\", \"database\", \"data\"],\n        [\"host\", \"log\", \"@No database configured\"]]]],\n  \"processor\"]\n</code></pre>"},{"location":"language/special-forms/#error-handling-patterns","title":"Error Handling Patterns","text":"<pre><code>// Safe evaluation with fallback\n[\"def\", \"safe_eval\",\n  [\"lambda\", [\"expr\", \"fallback\"],\n    [\"if\", [\"try\", \"expr\"],\n      \"expr\",\n      \"fallback\"]]]\n\n// Conditional resource acquisition\n[\"def\", \"with_resource\",\n  [\"lambda\", [\"resource_id\", \"action\"],\n    [\"do\",\n      [\"def\", \"resource\", [\"host\", \"resource/acquire\", \"resource_id\"]],\n      [\"if\", \"resource\",\n        [\"do\",\n          [\"def\", \"result\", [\"action\", \"resource\"]],\n          [\"host\", \"resource/release\", \"resource\"],\n          \"result\"],\n        null]]]]\n</code></pre>"},{"location":"language/special-forms/#special-forms-vs-functions","title":"Special Forms vs Functions","text":""},{"location":"language/special-forms/#key-differences","title":"Key Differences","text":"Aspect Special Forms Functions Argument Evaluation Controlled by form All arguments evaluated Environment Access Can modify environment Read-only environment access Evaluation Order Form-specific rules Standard left-to-right Meta-Programming Enable code generation Operate on values only Syntax Extension Can create new syntax Cannot extend syntax"},{"location":"language/special-forms/#when-to-use-each","title":"When to Use Each","text":"<p>Use Special Forms for: - Control flow (<code>if</code>, <code>do</code>) - Variable binding (<code>def</code>, <code>let</code>) - Function creation (<code>lambda</code>) - Meta-programming (<code>quote</code>) - Host interaction (<code>host</code>) - Error handling (<code>try</code>)</p> <p>Use Functions for: - Data transformation - Mathematical operations - String processing - Collection manipulation - Business logic - JSON object construction (using JSL's first-class object support)</p>"},{"location":"language/special-forms/#implementation-notes","title":"Implementation Notes","text":""},{"location":"language/special-forms/#evaluation-context","title":"Evaluation Context","text":"<p>Special forms are evaluated in the context of JSL's evaluator, which maintains:</p> <ol> <li>Environment Stack: For variable resolution and binding</li> <li>Continuation Stack: For function calls and returns</li> <li>Host Interface: For JHIP command execution</li> <li>Error Handling: For exception propagation</li> </ol>"},{"location":"language/special-forms/#performance-considerations","title":"Performance Considerations","text":"<ul> <li><code>def</code>: O(1) environment binding</li> <li><code>let</code>: O(1) local binding</li> <li><code>try</code>: O(n) body evaluation, O(m) handler evaluation on error</li> <li><code>lambda</code>: O(1) closure creation, O(e) environment capture</li> <li><code>if</code>: O(1) branch selection, avoids evaluating unused branch  </li> <li><code>do</code>: O(n) sequential evaluation</li> <li><code>quote</code>: O(1) literal return</li> <li><code>host</code>: O(h) depends on host operation complexity</li> </ul> <p>Special forms are the foundation of JSL's expressiveness, providing the essential building blocks for all higher-level language constructs while maintaining the language's homoiconic JSON-based structure.</p>"},{"location":"language/special-forms/#special-form-details","title":"Special Form Details","text":""},{"location":"language/special-forms/#host","title":"<code>host</code>","text":"<p>The <code>host</code> special form is the gateway for all side effects and interactions with the host system.</p> <ul> <li>Syntax: <code>[\"host\", command_expr, arg1_expr, ...]</code></li> <li>Evaluation: All arguments are evaluated. The results are packaged into a JHIP request and yielded to the host runtime.</li> </ul>"},{"location":"language/special-forms/#json-objects-as-first-class-citizens","title":"JSON Objects as First-Class Citizens","text":"<p>JSL provides powerful support for JSON object construction through its first-class object syntax. Objects in JSL:</p> <ul> <li>Are always treated as data structures (never function calls)</li> <li>Use normal JSL evaluation rules for both keys and values</li> <li>Require keys to evaluate to strings</li> <li>Support dynamic construction with variables and expressions</li> </ul> <p>For example: <pre><code>[\"do\",\n  [\"def\", \"name\", \"@Alice\"],\n  [\"def\", \"age\", 30],\n  {\"@greeting\": [\"str-concat\", \"@Hello \", \"name\"],\n   \"@info\": {\"@name\": \"name\", \"@age\": \"age\"}}\n]\n</code></pre></p> <p>For more details, see JSON Objects as First-Class Citizens.</p>"},{"location":"language/specification/","title":"JSL Language Specification v1.0","text":""},{"location":"language/specification/#1-introduction","title":"1. Introduction","text":"<p>JSL (JSON Serializable Language) is a functional programming language where all programs and data are representable as valid JSON. The language has two representations:</p> <ol> <li>Source Language (S-expressions): Human-readable JSON arrays</li> <li>Target Language (JPN - JSL Postfix Notation): Stack-based format for execution</li> </ol>"},{"location":"language/specification/#2-formal-grammar","title":"2. Formal Grammar","text":""},{"location":"language/specification/#21-source-language-s-expressions","title":"2.1 Source Language (S-expressions)","text":"<pre><code>&lt;expr&gt; ::= &lt;literal&gt;\n         | &lt;variable&gt;\n         | &lt;list-expr&gt;\n\n&lt;literal&gt; ::= &lt;number&gt; | &lt;boolean&gt; | &lt;null&gt; | &lt;string-literal&gt;\n\n&lt;number&gt; ::= JSON number\n&lt;boolean&gt; ::= true | false\n&lt;null&gt; ::= null\n&lt;string-literal&gt; ::= \"@\" &lt;string&gt;  ; String starting with @ is literal\n\n&lt;variable&gt; ::= &lt;string&gt;  ; String without @ prefix\n\n&lt;list-expr&gt; ::= \"[\" &lt;operator&gt; &lt;expr&gt;* \"]\"\n\n&lt;operator&gt; ::= &lt;string&gt;\n\n&lt;string&gt; ::= JSON string\n</code></pre>"},{"location":"language/specification/#22-target-language-jpn-jsl-postfix-notation","title":"2.2 Target Language (JPN - JSL Postfix Notation)","text":"<pre><code>&lt;jpn-program&gt; ::= &lt;instruction&gt;*\n\n&lt;instruction&gt; ::= &lt;literal&gt;\n                | &lt;variable&gt;\n                | &lt;arity&gt; &lt;operator&gt;\n\n&lt;arity&gt; ::= non-negative integer\n&lt;operator&gt; ::= &lt;string&gt;\n</code></pre> <p>Key Design Decision: JPN always encodes arity before the operator as two consecutive elements <code>[arity, operator]</code>. This provides: - JSON compatibility (no tuples, only arrays) - Consistent parsing (always look ahead for operator after seeing integer) - Efficient execution (know exactly how many values to pop) - Support for identity elements (0-arity operations)</p> <p>Note on Further Compilation: The JPN representation could be compiled to raw bytecode (e.g., <code>[PUSH_INT, 2, ADD]</code> or <code>[0x12, 0x02, 0x20]</code>), but JSL deliberately maintains JSON compatibility for network transparency, debuggability, and universal portability. See Performance Philosophy for rationale.</p>"},{"location":"language/specification/#3-compilation-rules","title":"3. Compilation Rules","text":"<p>The compilation from S-expressions to JPN follows these rules:</p>"},{"location":"language/specification/#31-literals","title":"3.1 Literals","text":"<pre><code>compile(n) = [n]           where n is number/boolean/null\ncompile(\"@s\") = [\"@s\"]     where s is a string\n</code></pre>"},{"location":"language/specification/#32-variables","title":"3.2 Variables","text":"<pre><code>compile(\"x\") = [\"x\"]       where x doesn't start with @\n</code></pre>"},{"location":"language/specification/#33-list-expressions","title":"3.3 List Expressions","text":"<pre><code>compile([op, e\u2081, ..., e\u2099]) = compile(e\u2081) ++ ... ++ compile(e\u2099) ++ [n, op]\n\nwhere:\n  n is the arity (number of arguments)\n  ++ denotes list concatenation\n</code></pre>"},{"location":"language/specification/#34-special-cases","title":"3.4 Special Cases","text":"<pre><code>compile([]) = [0, \"__empty_list__\"]\n</code></pre>"},{"location":"language/specification/#35-examples","title":"3.5 Examples","text":"<pre><code>compile(['+', 2, 3])        = [2, 3, 2, '+']\ncompile(['+'])              = [0, '+']\ncompile(['*', 2, 3, 4])     = [2, 3, 4, 3, '*']\ncompile(['list', 1, 2, 3])  = [1, 2, 3, 3, 'list']\n</code></pre>"},{"location":"language/specification/#4-abstract-machine","title":"4. Abstract Machine","text":"<p>The JSL abstract machine is a stack-based architecture with the following components:</p>"},{"location":"language/specification/#41-machine-state","title":"4.1 Machine State","text":"<pre><code>State = {\n  stack: Value[],        // Value stack\n  pc: Int,              // Program counter\n  code: Instruction[],  // Postfix instructions\n  env: Map&lt;String, Value&gt;, // Environment for variables\n  resources: ResourceBudget  // Optional resource limits\n}\n</code></pre>"},{"location":"language/specification/#42-operational-semantics","title":"4.2 Operational Semantics","text":"<p>The machine executes according to these transition rules:</p>"},{"location":"language/specification/#literal-push","title":"Literal Push","text":"<pre><code>\u27e8S, pc, code[pc] = v, E\u27e9 \u2192 \u27e8S\u00b7v, pc+1, code, E\u27e9\n  where v is a literal value\n</code></pre>"},{"location":"language/specification/#variable-lookup","title":"Variable Lookup","text":"<pre><code>\u27e8S, pc, code[pc] = x, E\u27e9 \u2192 \u27e8S\u00b7E(x), pc+1, code, E\u27e9\n  where x is a variable name and E(x) is defined\n</code></pre>"},{"location":"language/specification/#arity-operator-pair","title":"Arity-Operator Pair","text":"<pre><code>\u27e8S\u00b7v\u2099\u00b7...\u00b7v\u2081, pc, code[pc] = n, code[pc+1] = op, E\u27e9 \u2192 \u27e8S\u00b7op(v\u2081,...,v\u2099), pc+2, code, E\u27e9\n  where n is the arity and op is the operator\n</code></pre>"},{"location":"language/specification/#termination","title":"Termination","text":"<pre><code>\u27e8[v], pc, code\u27e9 \u2192 v\n  where pc \u2265 |code|\n</code></pre>"},{"location":"language/specification/#43-notation","title":"4.3 Notation","text":"<ul> <li><code>S\u00b7v</code> denotes pushing value v onto stack S</li> <li><code>E(x)</code> denotes looking up variable x in environment E</li> <li><code>|code|</code> denotes the length of the code array</li> </ul>"},{"location":"language/specification/#5-built-in-operators","title":"5. Built-in Operators","text":""},{"location":"language/specification/#51-arithmetic-operators","title":"5.1 Arithmetic Operators","text":"Operator Arity Semantics Example <code>+</code> 0 Sum identity: 0 <code>[+]</code> \u2192 0 <code>+</code> 1 Identity <code>[+, 5]</code> \u2192 5 <code>+</code> 2 Addition <code>[+, 2, 3]</code> \u2192 5 <code>+</code> n Sum <code>[+, 1, 2, 3]</code> \u2192 6 <code>-</code> 1 Negation <code>[-, 5]</code> \u2192 -5 <code>-</code> 2 Subtraction <code>[-, 10, 3]</code> \u2192 7 <code>*</code> 0 Product identity: 1 <code>[*]</code> \u2192 1 <code>*</code> 2 Multiplication <code>[*, 3, 4]</code> \u2192 12 <code>*</code> n Product <code>[*, 2, 3, 4]</code> \u2192 24 <code>/</code> 2 Division <code>[/, 10, 2]</code> \u2192 5 <code>%</code> 2 Modulo <code>[%, 10, 3]</code> \u2192 1"},{"location":"language/specification/#52-comparison-operators","title":"5.2 Comparison Operators","text":"Operator Arity Semantics <code>=</code> 2 Equality <code>!=</code> 2 Inequality <code>&lt;</code> 2 Less than <code>&gt;</code> 2 Greater than <code>&lt;=</code> 2 Less or equal <code>&gt;=</code> 2 Greater or equal"},{"location":"language/specification/#53-logical-operators","title":"5.3 Logical Operators","text":"Operator Arity Semantics <code>not</code> 1 Logical negation <code>and</code> 2 Logical AND <code>or</code> 2 Logical OR"},{"location":"language/specification/#54-list-operators","title":"5.4 List Operators","text":"Operator Arity Semantics Example <code>list</code> n Create list <code>[list, 1, 2, 3]</code> \u2192 [1,2,3] <code>cons</code> 2 Prepend element <code>[cons, 1, [2, 3]]</code> \u2192 [1,2,3] <code>first</code> 1 Get first element <code>[first, [1, 2]]</code> \u2192 1 <code>rest</code> 1 Get tail <code>[rest, [1, 2, 3]]</code> \u2192 [2,3] <code>append</code> 2 Append element <code>[append, [1, 2], 3]</code> \u2192 [1,2,3] <code>length</code> 1 List length <code>[length, [1, 2]]</code> \u2192 2"},{"location":"language/specification/#6-special-forms","title":"6. Special Forms","text":"<p>Special forms have unique evaluation rules and are not compiled to postfix in the current implementation:</p>"},{"location":"language/specification/#61-conditional","title":"6.1 Conditional","text":"<p><pre><code>[if, condition, then-expr, else-expr]\n</code></pre> Evaluates <code>condition</code>, then evaluates either <code>then-expr</code> or <code>else-expr</code>.</p>"},{"location":"language/specification/#62-let-binding","title":"6.2 Let Binding","text":"<p><pre><code>[let, [var, value], body]\n</code></pre> Evaluates <code>value</code>, binds it to <code>var</code>, then evaluates <code>body</code> in extended environment.</p>"},{"location":"language/specification/#63-lambda","title":"6.3 Lambda","text":"<p><pre><code>[lambda, [param\u2081, ..., param\u2099], body]\n</code></pre> Creates a closure capturing current environment.</p>"},{"location":"language/specification/#64-definition","title":"6.4 Definition","text":"<p><pre><code>[def, var, value]\n</code></pre> Evaluates <code>value</code> and binds it to <code>var</code> in current environment.</p>"},{"location":"language/specification/#65-sequencing","title":"6.5 Sequencing","text":"<p><pre><code>[do, expr\u2081, ..., expr\u2099]\n</code></pre> Evaluates expressions in sequence, returns last value.</p>"},{"location":"language/specification/#66-quote","title":"6.6 Quote","text":"<p><pre><code>[quote, expr] or [@, expr]\n</code></pre> Returns <code>expr</code> without evaluation.</p>"},{"location":"language/specification/#7-type-system","title":"7. Type System","text":"<p>JSL is dynamically typed with the following value types:</p> <pre><code>Value = Number\n      | Boolean\n      | Null\n      | String\n      | List&lt;Value&gt;\n      | Closure\n      | Dict&lt;String, Value&gt;\n</code></pre>"},{"location":"language/specification/#8-memory-model","title":"8. Memory Model","text":""},{"location":"language/specification/#81-environment-chain","title":"8.1 Environment Chain","text":"<p>Environments form a linked chain for lexical scoping: <pre><code>Env = {\n  bindings: Map&lt;String, Value&gt;,\n  parent: Env | null\n}\n</code></pre></p>"},{"location":"language/specification/#82-closure-representation","title":"8.2 Closure Representation","text":"<pre><code>Closure = {\n  params: String[],\n  body: Expr,\n  env: Env\n}\n</code></pre>"},{"location":"language/specification/#9-resource-management","title":"9. Resource Management","text":"<p>The abstract machine can enforce resource limits:</p> <pre><code>ResourceBudget = {\n  gas: Int,           // Computational steps\n  memory: Int,        // Memory usage\n  time_limit: Time,   // Wall-clock time\n  collection_limit: Int  // Max collection size\n}\n</code></pre> <p>Each instruction consumes gas: - Literals: 1 gas - Variable lookup: 2 gas - Binary operation: 3 gas - Function call: 10 gas</p>"},{"location":"language/specification/#10-serialization","title":"10. Serialization","text":"<p>All JSL values must be JSON-serializable:</p>"},{"location":"language/specification/#101-primitive-serialization","title":"10.1 Primitive Serialization","text":"<pre><code>serialize(n: Number) = n\nserialize(b: Boolean) = b\nserialize(null) = null\nserialize(s: String) = s\n</code></pre>"},{"location":"language/specification/#102-compound-serialization","title":"10.2 Compound Serialization","text":"<pre><code>serialize([v\u2081, ..., v\u2099]) = [serialize(v\u2081), ..., serialize(v\u2099)]\nserialize({k\u2081: v\u2081, ..., k\u2099: v\u2099}) = {k\u2081: serialize(v\u2081), ..., k\u2099: serialize(v\u2099)}\n</code></pre>"},{"location":"language/specification/#103-closure-serialization","title":"10.3 Closure Serialization","text":"<pre><code>serialize(Closure{params, body, env}) = {\n  \"type\": \"closure\",\n  \"params\": params,\n  \"body\": serialize(body),\n  \"env\": serialize_env(env)\n}\n</code></pre>"},{"location":"language/specification/#11-decompilation","title":"11. Decompilation","text":"<p>The decompilation from postfix to S-expressions follows these rules:</p>"},{"location":"language/specification/#111-stack-based-decompilation-algorithm","title":"11.1 Stack-Based Decompilation Algorithm","text":"<pre><code>decompile(postfix):\n  stack = []\n  for instruction in postfix:\n    if instruction is literal or variable:\n      stack.push(instruction)\n    elif instruction is (op, arity):\n      args = []\n      for i in 1..arity:\n        args.prepend(stack.pop())\n      stack.push([op] + args)\n    elif instruction is binary_op:\n      right = stack.pop()\n      left = stack.pop()\n      stack.push([op, left, right])\n  return stack[0]\n</code></pre>"},{"location":"language/specification/#12-formal-properties","title":"12. Formal Properties","text":""},{"location":"language/specification/#121-compilation-correctness","title":"12.1 Compilation Correctness","text":"<p>For any valid S-expression <code>e</code> and environment <code>E</code>: <pre><code>eval(e, E) = exec(compile(e), E)\n</code></pre></p>"},{"location":"language/specification/#122-roundtrip-property","title":"12.2 Roundtrip Property","text":"<p>For any valid S-expression <code>e</code>: <pre><code>decompile(compile(e)) \u2261 e\n</code></pre> Where \u2261 denotes structural equivalence.</p>"},{"location":"language/specification/#123-serialization-safety","title":"12.3 Serialization Safety","text":"<p>For any JSL value <code>v</code>: <pre><code>deserialize(serialize(v)) = v\n</code></pre></p>"},{"location":"language/specification/#124-resumption-safety","title":"12.4 Resumption Safety","text":"<p>For any partial execution state <code>S</code>: <pre><code>exec_partial(code, S) = exec_complete(code)\n</code></pre> When given sufficient resources.</p>"},{"location":"language/specification/#13-examples","title":"13. Examples","text":""},{"location":"language/specification/#131-arithmetic-expression","title":"13.1 Arithmetic Expression","text":"<p>Source: <pre><code>[\"*\", [\"+\", 2, 3], [\"-\", 10, 6]]\n</code></pre></p> <p>Postfix: <pre><code>[2, 3, \"+\", 10, 6, \"-\", \"*\"]\n</code></pre></p> <p>Execution trace: <pre><code>[]          | 2 3 + 10 6 - *  ; Initial\n[2]         | 3 + 10 6 - *    ; Push 2\n[2,3]       | + 10 6 - *      ; Push 3\n[5]         | 10 6 - *        ; Apply +\n[5,10]      | 6 - *           ; Push 10\n[5,10,6]    | - *             ; Push 6\n[5,4]       | *               ; Apply -\n[20]        |                 ; Apply *\n</code></pre></p>"},{"location":"language/specification/#132-variable-expression","title":"13.2 Variable Expression","text":"<p>Source: <pre><code>[\"+\", \"x\", [\"*\", \"y\", 2]]\n</code></pre></p> <p>Postfix (with environment <code>{x: 10, y: 3}</code>): <pre><code>[\"x\", \"y\", 2, \"*\", \"+\"]\n</code></pre></p> <p>Execution: <pre><code>[]          | x y 2 * +  ; Initial\n[10]        | y 2 * +    ; Lookup x\n[10,3]      | 2 * +      ; Lookup y\n[10,3,2]    | * +        ; Push 2\n[10,6]      | +          ; Apply *\n[16]        |            ; Apply +\n</code></pre></p>"},{"location":"language/specification/#14-implementation-notes","title":"14. Implementation Notes","text":"<ol> <li>Tail Call Optimization: Not currently implemented</li> <li>Lazy Evaluation: Not supported (strict evaluation)</li> <li>Type Checking: Dynamic only</li> <li>Garbage Collection: Relies on host language (Python)</li> <li>Concurrency: Not supported</li> </ol>"},{"location":"language/specification/#15-future-extensions","title":"15. Future Extensions","text":"<ol> <li>Pattern Matching: Destructuring in let and lambda</li> <li>Module System: Namespace management</li> <li>Type Annotations: Optional static typing</li> <li>Continuations: First-class continuations for control flow</li> <li>Parallel Execution: Parallel evaluation of independent expressions</li> </ol> <p>This specification defines JSL v1.0. The language is designed for network-native computation with complete serializability.</p>"},{"location":"language/transform-operations/","title":"Transform Operations","text":"<p>JSL provides powerful declarative operations for transforming and reshaping data structures.</p>"},{"location":"language/transform-operations/#the-transform-special-form","title":"The <code>transform</code> Special Form","text":"<p>The <code>transform</code> is a special form (not a function) that applies transformation operations to data. As a special form, it automatically binds item fields to the environment, allowing direct field references in transformation expressions.</p>"},{"location":"language/transform-operations/#basic-syntax","title":"Basic Syntax","text":"<pre><code>(transform data operation)\n</code></pre> <p>The operation can be one of several transformation functions that reshape the data.</p>"},{"location":"language/transform-operations/#transformation-operations","title":"Transformation Operations","text":"<p>The transform operations are functions in the prelude that return operation descriptors. These descriptors are then interpreted by the <code>transform</code> special form.</p>"},{"location":"language/transform-operations/#assign-add-or-update-fields","title":"<code>assign</code> - Add or Update Fields","text":"<p>Returns an operation descriptor that adds new fields or updates existing ones:</p> <pre><code>; Add a single field\n(transform user (assign \"@verified\" true))\n\n; Add computed field\n(transform product (assign \"@discounted\" (* price 0.9)))\n\n; Update existing field\n(transform user (assign \"@age\" (+ age 1)))\n</code></pre>"},{"location":"language/transform-operations/#pick-select-specific-fields","title":"<code>pick</code> - Select Specific Fields","text":"<p>Creates new objects with only specified fields:</p> <pre><code>; Pick specific fields\n(transform user (pick \"@name\" \"@email\"))\n\n; From collection\n(transform users (pick \"@id\" \"@name\" \"@role\"))\n</code></pre>"},{"location":"language/transform-operations/#omit-remove-fields","title":"<code>omit</code> - Remove Fields","text":"<p>Creates new objects without specified fields:</p> <pre><code>; Remove sensitive fields\n(transform user (omit \"@password\" \"@ssn\"))\n\n; Remove multiple fields\n(transform response (omit \"@internal_id\" \"@debug_info\"))\n</code></pre>"},{"location":"language/transform-operations/#rename-rename-fields","title":"<code>rename</code> - Rename Fields","text":"<p>Renames fields in objects:</p> <pre><code>; Rename single field\n(transform user (rename \"@username\" \"@login\"))\n\n; Multiple renames\n(transform data (rename {\"@old_name\": \"@new_name\", \"@id\": \"@identifier\"}))\n</code></pre>"},{"location":"language/transform-operations/#update-update-specific-fields","title":"<code>update</code> - Update Specific Fields","text":"<p>Updates fields with computed values:</p> <pre><code>; Update with function\n(transform product (update \"@price\" (lambda (p) (* p 1.1))))\n\n; Update multiple fields\n(transform user \n  (update {\"@age\": (lambda (a) (+ a 1)), \n           \"@score\": (lambda (s) (* s 2))}))\n</code></pre>"},{"location":"language/transform-operations/#field-binding","title":"Field Binding","text":"<p>Within transform operations, fields are automatically bound:</p> <pre><code>(def product {\"name\": \"Widget\", \"price\": 100, \"tax_rate\": 0.08})\n\n; Fields 'price' and 'tax_rate' are automatically available\n(transform product \n  (assign \"@total\" (* price (+ 1 tax_rate))))\n; Returns: {\"name\": \"Widget\", \"price\": 100, \"tax_rate\": 0.08, \"total\": 108}\n</code></pre>"},{"location":"language/transform-operations/#working-with-collections","title":"Working with Collections","text":"<p>Transform operations work on both single objects and collections:</p> <pre><code>(def products [@\n  {\"name\": \"A\", \"price\": 100}\n  {\"name\": \"B\", \"price\": 200}\n])\n\n; Applied to each item\n(transform products (assign \"@on_sale\" true))\n; Returns: [{\"name\": \"A\", \"price\": 100, \"on_sale\": true},\n;           {\"name\": \"B\", \"price\": 200, \"on_sale\": true}]\n</code></pre>"},{"location":"language/transform-operations/#composition-patterns","title":"Composition Patterns","text":""},{"location":"language/transform-operations/#sequential-transformations","title":"Sequential Transformations","text":"<pre><code>(transform\n  (transform user (pick \"@name\" \"@email\" \"@age\"))\n  (assign \"@adult\" (&gt;= age 18)))\n</code></pre>"},{"location":"language/transform-operations/#filter-and-transform","title":"Filter and Transform","text":"<pre><code>(transform\n  (where products (&gt; price 50))\n  (assign \"@premium\" true))\n</code></pre>"},{"location":"language/transform-operations/#transform-and-aggregate","title":"Transform and Aggregate","text":"<pre><code>(sum\n  (pluck\n    (transform orders (assign \"@total\" (* quantity price)))\n    \"@total\"))\n</code></pre>"},{"location":"language/transform-operations/#advanced-examples","title":"Advanced Examples","text":""},{"location":"language/transform-operations/#data-normalization","title":"Data Normalization","text":"<pre><code>; Normalize user data\n(transform users\n  (do\n    (pick \"@id\" \"@username\" \"@email\")\n    (rename \"@username\" \"@name\")\n    (assign \"@created_at\" (now))))\n</code></pre>"},{"location":"language/transform-operations/#computed-fields","title":"Computed Fields","text":"<pre><code>; Add multiple computed fields\n(def order {\"items\": 5, \"price_per_item\": 20, \"tax_rate\": 0.08})\n\n(transform order\n  (do\n    (assign \"@subtotal\" (* items price_per_item))\n    (assign \"@tax\" (* subtotal tax_rate))\n    (assign \"@total\" (+ subtotal tax))))\n</code></pre>"},{"location":"language/transform-operations/#nested-transformations","title":"Nested Transformations","text":"<pre><code>; Transform nested structures\n(transform user\n  (update \"@address\" \n    (lambda (addr) \n      (transform addr (pick \"@city\" \"@country\")))))\n</code></pre>"},{"location":"language/transform-operations/#string-literals-vs-field-references","title":"String Literals vs Field References","text":"<ul> <li>Field references (symbols): <code>price</code>, <code>name</code>, <code>active</code></li> <li>String literals (@ prefix): <code>\"@price\"</code>, <code>\"@name\"</code></li> </ul> <pre><code>; Assign literal string \"pending\" to status field\n(transform order (assign \"@status\" \"@pending\"))\n\n; Assign value of status variable to new_status field  \n(transform order (assign \"@new_status\" status))\n</code></pre>"},{"location":"language/transform-operations/#implementation-details","title":"Implementation Details","text":"<p>The <code>transform</code> special form is implemented in <code>_eval_transform</code> in <code>core.py</code>. The transformation operators (<code>pick</code>, <code>omit</code>, <code>assign</code>, etc.) are prelude functions that return operation descriptors like <code>[\"pick\", \"@field1\", \"@field2\"]</code>. The special form then: 1. Evaluates the data expression 2. For each operation, evaluates it with item fields in scope 3. Interprets the operation descriptor to perform the transformation 4. Returns the transformed data</p> <p>This design separates the operation definition (in prelude) from the execution logic (in the evaluator).</p>"},{"location":"language/transform-operations/#performance-considerations","title":"Performance Considerations","text":"<p>Transform operations: - Create new objects (immutable) - Extend environment once per transformation - Process collections item by item - Can be optimized by the compiler</p>"},{"location":"language/transform-operations/#comparison-with-manual-approach","title":"Comparison with Manual Approach","text":""},{"location":"language/transform-operations/#manual-construction","title":"Manual Construction","text":"<pre><code>(lambda (user)\n  {\"@name\": (get user \"@name\"),\n   \"@email\": (get user \"@email\"),\n   \"@verified\": true})\n</code></pre>"},{"location":"language/transform-operations/#transform-approach","title":"Transform Approach","text":"<pre><code>(transform user \n  (do\n    (pick \"@name\" \"@email\")\n    (assign \"@verified\" true)))\n</code></pre> <p>The transform approach is: - More declarative and readable - Automatically handles field access - Composable with other operations - Less error-prone</p>"},{"location":"language/transform-operations/#see-also","title":"See Also","text":"<ul> <li>Query Operations - Filtering with <code>where</code></li> <li>Path Navigation - Deep JSON path access</li> <li>Group By - Grouping and aggregation</li> </ul>"},{"location":"tutorials/data/","title":"Working with Data in JSL","text":""},{"location":"tutorials/data/#introduction","title":"Introduction","text":"<p>JSL uses JSON for all data structures, making it easy to work with familiar formats. This tutorial teaches you to manipulate data step by step.</p>"},{"location":"tutorials/data/#basic-data-types","title":"Basic Data Types","text":"<p>JSL supports all JSON data types:</p> <pre><code>[\"do\",\n  [\"def\", \"number\", 42],\n  [\"def\", \"string\", \"hello\"],\n  [\"def\", \"boolean\", true],\n  [\"def\", \"null_value\", null],\n  [\"def\", \"array\", [1, 2, 3]],\n  [\"def\", \"object\", {\"name\": \"Alice\", \"age\": 30}]]\n</code></pre>"},{"location":"tutorials/data/#working-with-objects","title":"Working with Objects","text":""},{"location":"tutorials/data/#accessing-object-properties","title":"Accessing Object Properties","text":"<pre><code>[\"def\", \"person\", {\"name\": \"Alice\", \"age\": 30, \"city\": \"New York\"}]\n\n[\"get\", \"person\", \"name\"]     // Result: \"Alice\"\n[\"get\", \"person\", \"age\"]      // Result: 30\n</code></pre>"},{"location":"tutorials/data/#modifying-objects","title":"Modifying Objects","text":"<pre><code>[\"def\", \"updated_person\", \n  [\"assoc\", \"person\", \"age\", 31]]\n// Result: {\"name\": \"Alice\", \"age\": 31, \"city\": \"New York\"}\n</code></pre>"},{"location":"tutorials/data/#adding-new-properties","title":"Adding New Properties","text":"<pre><code>[\"def\", \"person_with_email\",\n  [\"assoc\", \"person\", \"email\", \"alice@example.com\"]]\n</code></pre>"},{"location":"tutorials/data/#working-with-arrays","title":"Working with Arrays","text":""},{"location":"tutorials/data/#basic-array-operations","title":"Basic Array Operations","text":"<pre><code>[\"def\", \"numbers\", [1, 2, 3, 4, 5]]\n\n[\"length\", \"numbers\"]              // Result: 5\n[\"first\", \"numbers\"]               // Result: 1\n[\"last\", \"numbers\"]                // Result: 5\n[\"nth\", \"numbers\", 2]              // Result: 3 (0-indexed)\n</code></pre>"},{"location":"tutorials/data/#adding-elements","title":"Adding Elements","text":"<pre><code>[\"conj\", \"numbers\", 6]             // Result: [1, 2, 3, 4, 5, 6]\n[\"concat\", \"numbers\", [6, 7, 8]]   // Result: [1, 2, 3, 4, 5, 6, 7, 8]\n</code></pre>"},{"location":"tutorials/data/#step-by-step-building-a-contact-manager","title":"Step-by-Step: Building a Contact Manager","text":""},{"location":"tutorials/data/#step-1-create-contact-data","title":"Step 1: Create Contact Data","text":"<pre><code>[\"def\", \"contacts\", [\n  {\"name\": \"Alice\", \"email\": \"alice@example.com\", \"phone\": \"555-0101\"},\n  {\"name\": \"Bob\", \"email\": \"bob@example.com\", \"phone\": \"555-0102\"},\n  {\"name\": \"Charlie\", \"email\": \"charlie@example.com\", \"phone\": \"555-0103\"}\n]]\n</code></pre>"},{"location":"tutorials/data/#step-2-find-a-contact-by-name","title":"Step 2: Find a Contact by Name","text":"<pre><code>[\"def\", \"find_contact\",\n  [\"lambda\", [\"name\"],\n    [\"first\", \n      [\"filter\", \n        [\"lambda\", [\"contact\"], [\"=\", [\"get\", \"contact\", \"name\"], \"name\"]], \n        \"contacts\"]]]]\n\n[\"find_contact\", \"Alice\"]\n// Result: {\"name\": \"Alice\", \"email\": \"alice@example.com\", \"phone\": \"555-0101\"}\n</code></pre>"},{"location":"tutorials/data/#step-3-get-all-email-addresses","title":"Step 3: Get All Email Addresses","text":"<pre><code>[\"def\", \"get_all_emails\",\n  [\"lambda\", [], \n    [\"map\", [\"lambda\", [\"contact\"], [\"get\", \"contact\", \"email\"]], \"contacts\"]]]\n\n[\"get_all_emails\"]\n// Result: [\"alice@example.com\", \"bob@example.com\", \"charlie@example.com\"]\n</code></pre>"},{"location":"tutorials/data/#step-4-add-a-new-contact","title":"Step 4: Add a New Contact","text":"<pre><code>[\"def\", \"add_contact\",\n  [\"lambda\", [\"name\", \"email\", \"phone\"],\n    [\"conj\", \"contacts\", {\"name\": \"name\", \"email\": \"email\", \"phone\": \"phone\"}]]]\n\n[\"def\", \"updated_contacts\", \n  [\"add_contact\", \"Diana\", \"diana@example.com\", \"555-0104\"]]\n</code></pre>"},{"location":"tutorials/data/#data-transformation-patterns","title":"Data Transformation Patterns","text":""},{"location":"tutorials/data/#filtering-data","title":"Filtering Data","text":"<pre><code>// Find contacts with Gmail addresses\n[\"def\", \"gmail_contacts\",\n  [\"filter\", \n    [\"lambda\", [\"contact\"], \n      [\"includes?\", [\"get\", \"contact\", \"email\"], \"gmail.com\"]], \n    \"contacts\"]]\n</code></pre>"},{"location":"tutorials/data/#grouping-data","title":"Grouping Data","text":"<pre><code>// Group contacts by email domain\n[\"def\", \"group_by_domain\",\n  [\"group_by\", \n    [\"lambda\", [\"contact\"], \n      [\"last\", [\"split\", [\"get\", \"contact\", \"email\"], \"@\"]]], \n    \"contacts\"]]\n</code></pre>"},{"location":"tutorials/data/#sorting-data","title":"Sorting Data","text":"<pre><code>// Sort contacts by name\n[\"def\", \"sorted_contacts\",\n  [\"sort_by\", [\"lambda\", [\"contact\"], [\"get\", \"contact\", \"name\"]], \"contacts\"]]\n</code></pre>"},{"location":"tutorials/data/#working-with-nested-data","title":"Working with Nested Data","text":""},{"location":"tutorials/data/#step-1-complex-data-structure","title":"Step 1: Complex Data Structure","text":"<pre><code>[\"def\", \"company\", {\n  \"name\": \"Tech Corp\",\n  \"departments\": [\n    {\n      \"name\": \"Engineering\", \n      \"employees\": [\n        {\"name\": \"Alice\", \"salary\": 100000},\n        {\"name\": \"Bob\", \"salary\": 95000}\n      ]\n    },\n    {\n      \"name\": \"Sales\",\n      \"employees\": [\n        {\"name\": \"Charlie\", \"salary\": 80000},\n        {\"name\": \"Diana\", \"salary\": 85000}\n      ]\n    }\n  ]\n}]\n</code></pre>"},{"location":"tutorials/data/#step-2-extract-all-employee-names","title":"Step 2: Extract All Employee Names","text":"<pre><code>[\"def\", \"all_employee_names\",\n  [\"flatten\", \n    [\"map\", \n      [\"lambda\", [\"dept\"], \n        [\"map\", \n          [\"lambda\", [\"emp\"], [\"get\", \"emp\", \"name\"]], \n          [\"get\", \"dept\", \"employees\"]]], \n      [\"get\", \"company\", \"departments\"]]]]\n\n[\"all_employee_names\"]\n// Result: [\"Alice\", \"Bob\", \"Charlie\", \"Diana\"]\n</code></pre>"},{"location":"tutorials/data/#step-3-calculate-total-payroll","title":"Step 3: Calculate Total Payroll","text":"<pre><code>[\"def\", \"total_payroll\",\n  [\"sum\", \n    [\"flatten\", \n      [\"map\", \n        [\"lambda\", [\"dept\"], \n          [\"map\", \n            [\"lambda\", [\"emp\"], [\"get\", \"emp\", \"salary\"]], \n            [\"get\", \"dept\", \"employees\"]]], \n        [\"get\", \"company\", \"departments\"]]]]]\n\n[\"total_payroll\"]\n// Result: 360000\n</code></pre>"},{"location":"tutorials/data/#data-validation","title":"Data Validation","text":""},{"location":"tutorials/data/#step-1-validation-functions","title":"Step 1: Validation Functions","text":"<pre><code>[\"def\", \"valid_email?\",\n  [\"lambda\", [\"email\"], \n    [\"and\", \n      [\"includes?\", \"email\", \"@\"],\n      [\"&gt;\", [\"length\", \"email\"], 5]]]]\n\n[\"def\", \"valid_phone?\",\n  [\"lambda\", [\"phone\"],\n    [\"=\", [\"length\", \"phone\"], 12]]]  // Assuming XXX-XXXX format\n</code></pre>"},{"location":"tutorials/data/#step-2-validate-contact","title":"Step 2: Validate Contact","text":"<pre><code>[\"def\", \"valid_contact?\",\n  [\"lambda\", [\"contact\"],\n    [\"and\",\n      [\"valid_email?\", [\"get\", \"contact\", \"email\"]],\n      [\"valid_phone?\", [\"get\", \"contact\", \"phone\"]],\n      [\"&gt;\", [\"length\", [\"get\", \"contact\", \"name\"]], 0]]]]\n</code></pre>"},{"location":"tutorials/data/#step-3-filter-valid-contacts","title":"Step 3: Filter Valid Contacts","text":"<pre><code>[\"def\", \"valid_contacts\",\n  [\"filter\", \"valid_contact?\", \"contacts\"]]\n</code></pre>"},{"location":"tutorials/data/#dynamic-object-construction-with-data","title":"Dynamic Object Construction with Data","text":""},{"location":"tutorials/data/#step-1-email-object-structure","title":"Step 1: Email Object Structure","text":"<pre><code>[\"def\", \"create_email\", \n  [\"lambda\", [\"recipient_email\", \"recipient_name\"],\n    {\n      \"@to\": \"recipient_email\",\n      \"@subject\": [\"str-concat\", \"@Welcome \", \"recipient_name\", \"@!\"],\n      \"@body\": [\"str-concat\", \"@Hello \", \"recipient_name\", \"@, welcome to our service!\"]\n    }\n  ]\n]\n</code></pre>"},{"location":"tutorials/data/#step-2-generate-emails-for-all-contacts","title":"Step 2: Generate Emails for All Contacts","text":"<pre><code>[\"def\", \"generate_welcome_emails\",\n  [\"map\", \n    [\"lambda\", [\"contact\"],\n      [\"create_email\",\n        [\"get\", \"contact\", \"@email\"],\n        [\"get\", \"contact\", \"@name\"]\n      ]], \n    \"contacts\"]]\n</code></pre>"},{"location":"tutorials/data/#practice-exercises","title":"Practice Exercises","text":""},{"location":"tutorials/data/#exercise-1-inventory-management","title":"Exercise 1: Inventory Management","text":"<p>Create functions to manage a product inventory:</p> <pre><code>[\"def\", \"inventory\", [\n  {\"id\": 1, \"name\": \"Laptop\", \"price\": 999, \"stock\": 5},\n  {\"id\": 2, \"name\": \"Mouse\", \"price\": 25, \"stock\": 50},\n  {\"id\": 3, \"name\": \"Keyboard\", \"price\": 75, \"stock\": 20}\n]]\n\n// Find products under $100\n// Calculate total inventory value\n// Find products with low stock (&lt; 10)\n</code></pre>"},{"location":"tutorials/data/#exercise-2-student-grades","title":"Exercise 2: Student Grades","text":"<p>Work with student grade data:</p> <pre><code>[\"def\", \"students\", [\n  {\"name\": \"Alice\", \"grades\": [85, 92, 78, 96]},\n  {\"name\": \"Bob\", \"grades\": [76, 84, 91, 88]},\n  {\"name\": \"Charlie\", \"grades\": [92, 95, 89, 94]}\n]]\n\n// Calculate average grade for each student\n// Find the student with the highest average\n// List all grades above 90\n</code></pre>"},{"location":"tutorials/data/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about JSON Objects as first-class data structures</li> <li>Explore functions for data processing</li> <li>Try distributed computing with data</li> </ul> <p>Working with data in JSL is straightforward because everything is JSON. The functional approach with <code>map</code>, <code>filter</code>, and <code>reduce</code> makes data transformation both powerful and readable.</p>"},{"location":"tutorials/first-program/","title":"Your First JSL Program","text":"<p>Welcome to JSL! This tutorial will walk you through creating your first JSL program step by step. By the end, you'll understand JSL's core concepts and be ready to build more complex applications.</p>"},{"location":"tutorials/first-program/#what-makes-jsl-different","title":"What Makes JSL Different","text":"<p>JSL is unlike most programming languages you may have used before. The key insight is that code and data are the same thing - both are represented as JSON. This means:</p> <ul> <li>Your program is valid JSON that can be transmitted over networks</li> <li>Functions can be serialized and reconstructed anywhere  </li> <li>Dual evaluation modes - direct interpretation or JIT compilation to stack bytecode</li> <li>Pauseable/resumable execution - programs can be suspended and continued later</li> <li>Universal compatibility - any system that handles JSON can work with JSL</li> </ul>"},{"location":"tutorials/first-program/#hello-world","title":"Hello, World!","text":"<p>Let's start with the classic first program. JSL supports two syntax styles - JSON arrays and Lisp-style parentheses. Create a file called <code>hello.jsl</code>:</p>"},{"location":"tutorials/first-program/#json-array-syntax","title":"JSON Array Syntax","text":"<pre><code>[\"host\", \"@print\", \"@Hello, JSL!\"]\n</code></pre>"},{"location":"tutorials/first-program/#lisp-style-syntax-human-friendly","title":"Lisp-Style Syntax (Human-Friendly)","text":"<pre><code>(host @print \"Hello, JSL!\")\n</code></pre> <p>Both are exactly equivalent! The Lisp-style is often easier to read and write, while JSON is universal for network transmission.</p> <p>Now, run it from your terminal:</p> <pre><code>jsl hello.jsl\n</code></pre> <p>You should see the output:</p> <pre><code>Hello, JSL!\n</code></pre> <p>What happened?</p> <ol> <li><code>(host @print \"Hello, JSL!\")</code> is a host interaction </li> <li><code>host</code> is a special form for side effects</li> <li><code>@print</code> is the host command (@ prefix in JSON, quoted in Lisp-style)</li> <li><code>\"Hello, JSL!\"</code> is the argument to print</li> <li>JSL sends the print request to the host environment</li> </ol>"},{"location":"tutorials/first-program/#how-jsl-executes-your-code","title":"How JSL Executes Your Code","text":"<p>JSL offers two execution strategies:</p>"},{"location":"tutorials/first-program/#1-recursive-evaluation-default","title":"1. Recursive Evaluation (Default)","text":"<p>The S-expression is directly evaluated by walking the tree structure. This is the default mode and works well for most programs.</p>"},{"location":"tutorials/first-program/#2-stack-machine-compilation-available-on-request","title":"2. Stack Machine Compilation (Available on Request)","text":"<p>JSL can compile your program Just-In-Time to JPN (JSL Postfix Notation) bytecode when you need advanced features:</p> <pre><code>// Your code: [\"+\", 1, 2, 3]\n// Compiles to JPN: [1, 2, 3, 3, \"+\"]\n// Executes on stack machine with resumable state\n</code></pre> <p>The stack machine enables: - Pauseable execution - Stop after N steps and resume later - Resource limits - Control CPU/memory usage with gas metering - Distributed execution - Pause on one machine, resume on another - Debugging - Step through execution instruction by instruction</p> <p>Even the paused execution state is pure JSON - maintaining JSL's core principle that everything (code, data, and even execution state) can be serialized and transmitted!</p> <p>You don't need to worry about this initially - JSL handles it automatically. But it's there when you need advanced features!</p>"},{"location":"tutorials/first-program/#understanding-prefix-notation","title":"Understanding Prefix Notation","text":"<p>JSL uses prefix notation - the operator comes first. Here's the same code in both syntaxes:</p>"},{"location":"tutorials/first-program/#json-array-syntax_1","title":"JSON Array Syntax","text":"<pre><code>// Traditional: 2 + 3\n[\"+\", 2, 3]\n\n// Traditional: 2 + 3 + 4  \n[\"+\", 2, 3, 4]\n\n// Traditional: 2 * (3 + 4)\n[\"*\", 2, [\"+\", 3, 4]]\n</code></pre>"},{"location":"tutorials/first-program/#lisp-style-syntax","title":"Lisp-Style Syntax","text":"<pre><code>; Traditional: 2 + 3\n(+ 2 3)\n\n; Traditional: 2 + 3 + 4\n(+ 2 3 4)\n\n; Traditional: 2 * (3 + 4)\n(* 2 (+ 3 4))\n</code></pre> <p>The Lisp-style is often more readable, especially for complex expressions!</p>"},{"location":"tutorials/first-program/#variables-with-def","title":"Variables with <code>def</code>","text":"<p>Use <code>def</code> to create variables:</p> <pre><code>[\n  \"do\",\n  [\"def\", \"name\", \"Alice\"],\n  [\"def\", \"age\", 30],\n  [\"print\", \"Hello,\", \"name\", \"! You are\", \"age\", \"years old.\"]\n]\n</code></pre> <p>Breaking it down:</p> <ol> <li><code>\"do\"</code> executes multiple expressions in sequence</li> <li><code>[\"def\", \"name\", \"Alice\"]</code> creates a variable called <code>name</code></li> <li><code>[\"def\", \"age\", 30]</code> creates a variable called <code>age</code> </li> <li>The print statement uses the variables by referencing their names</li> </ol>"},{"location":"tutorials/first-program/#your-first-function","title":"Your First Function","text":"<p>Let's create a function to calculate the area of a circle:</p> <pre><code>[\n  \"do\",\n  [\"def\", \"pi\", 3.14159],\n  [\"def\", \"circle-area\", \n   [\"lambda\", [\"radius\"], \n    [\"*\", \"pi\", \"radius\", \"radius\"]]],\n  [\"def\", \"my-radius\", 5],\n  [\"def\", \"area\", [\"circle-area\", \"my-radius\"]],\n  [\"print\", \"Circle with radius\", \"my-radius\", \"has area\", \"area\"]\n]\n</code></pre> <p>Understanding <code>lambda</code>:</p> <ul> <li><code>[\"lambda\", [\"radius\"], ...]</code> creates a function</li> <li><code>[\"radius\"]</code> is the parameter list (the function takes one argument)</li> <li><code>[\"*\", \"pi\", \"radius\", \"radius\"]</code> is the function body</li> <li>The function calculates \u03c0 \u00d7 radius\u00b2</li> </ul>"},{"location":"tutorials/first-program/#working-with-lists","title":"Working with Lists","text":"<p>Lists are fundamental in JSL. Let's explore list operations:</p> <pre><code>[\n  \"do\",\n  [\"def\", \"numbers\", [\"list\", 1, 2, 3, 4, 5]],\n  [\"def\", \"first-number\", [\"first\", \"numbers\"]],\n  [\"def\", \"rest-numbers\", [\"rest\", \"numbers\"]],\n  [\"def\", \"list-length\", [\"length\", \"numbers\"]],\n\n  [\"print\", \"Original list:\", \"numbers\"],\n  [\"print\", \"First element:\", \"first-number\"], \n  [\"print\", \"Rest of list:\", \"rest-numbers\"],\n  [\"print\", \"List length:\", \"list-length\"]\n]\n</code></pre>"},{"location":"tutorials/first-program/#higher-order-functions","title":"Higher-Order Functions","text":"<p>Now for something powerful - functions that work with other functions:</p> <pre><code>[\n  \"do\",\n  [\"def\", \"numbers\", [\"list\", 1, 2, 3, 4, 5]],\n\n  // Double each number\n  [\"def\", \"double\", [\"lambda\", [\"x\"], [\"*\", \"x\", 2]]],\n  [\"def\", \"doubled\", [\"map\", \"double\", \"numbers\"]],\n\n  // Filter even numbers\n  [\"def\", \"is-even\", [\"lambda\", [\"n\"], [\"=\", [\"mod\", \"n\", 2], 0]]],\n  [\"def\", \"evens\", [\"filter\", \"is-even\", \"numbers\"]],\n\n  // Sum all numbers\n  [\"def\", \"total\", [\"reduce\", \"+\", \"numbers\", 0]],\n\n  [\"print\", \"Original:\", \"numbers\"],\n  [\"print\", \"Doubled:\", \"doubled\"],\n  [\"print\", \"Evens only:\", \"evens\"], \n  [\"print\", \"Sum:\", \"total\"]\n]\n</code></pre> <p>Key concepts:</p> <ul> <li><code>map</code> applies a function to each element of a list</li> <li><code>filter</code> keeps only elements that match a condition</li> <li><code>reduce</code> combines all elements into a single value</li> </ul>"},{"location":"tutorials/first-program/#conditional-logic","title":"Conditional Logic","text":"<p>Use <code>if</code> for decisions:</p> <pre><code>[\n  \"do\",\n  [\"def\", \"temperature\", 75],\n  [\"def\", \"weather\", \n   [\"if\", [\"&gt;\", \"temperature\", 80],\n    \"hot\",\n    [\"if\", [\"&gt;\", \"temperature\", 60], \n     \"warm\", \n     \"cool\"]]],\n  [\"print\", \"It's\", \"weather\", \"today at\", \"temperature\", \"degrees\"]\n]\n</code></pre>"},{"location":"tutorials/first-program/#data-structures","title":"Data Structures","text":"<p>Work with dictionaries (objects) to structure data:</p> <pre><code>[\n  \"do\",\n  [\"def\", \"person\", {\n    \"@name\": \"@Bob\",\n    \"@age\": 25,\n    \"@city\": \"@San Francisco\"\n  }],\n\n  [\"def\", \"name\", [\"get\", \"person\", \"@name\"]],\n  [\"def\", \"age\", [\"get\", \"person\", \"@age\"]],\n\n  // Create a new person with updated age\n  [\"def\", \"older-person\", [\"set\", \"person\", \"@age\", [\"+\", \"age\", 1]]],\n\n  [\"host\", \"@print\", \"@Original person:\", \"person\"],\n  [\"host\", \"@print\", \"@Person next year:\", \"older-person\"]\n]\n</code></pre>"},{"location":"tutorials/first-program/#modern-data-operations","title":"Modern Data Operations","text":"<p>JSL provides powerful special forms for working with collections:</p>"},{"location":"tutorials/first-program/#filtering-with-where","title":"Filtering with <code>where</code>","text":"<p>Instead of verbose lambda expressions, use the declarative <code>where</code> form. The fields from each item are automatically available as variables!</p>"},{"location":"tutorials/first-program/#json-syntax","title":"JSON Syntax","text":"<pre><code>[\"where\", \"users\", [\"and\", \"active\", [\"&gt;\", \"age\", 30]]]\n</code></pre>"},{"location":"tutorials/first-program/#lisp-style-syntax_1","title":"Lisp-Style Syntax","text":"<pre><code>(where users (and active (&gt; age 30)))\n</code></pre> <p>Complete example in Lisp-style: <pre><code>(do\n  (def users [@\n    {\"name\": \"Alice\", \"age\": 30, \"active\": true}\n    {\"name\": \"Bob\", \"age\": 25, \"active\": false}\n    {\"name\": \"Charlie\", \"age\": 35, \"active\": true}])\n\n  ; Filter active users - fields are automatically available!\n  (def active-users (where users active))\n\n  ; Complex conditions\n  (def active-adults (where users \n    (and active (&gt; age 30))))\n\n  (host @print \"Active adults:\" active-adults))\n</code></pre></p>"},{"location":"tutorials/first-program/#transforming-with-transform","title":"Transforming with <code>transform</code>","text":"<p>Reshape data declaratively:</p> <pre><code>[\n  \"do\",\n  [\"def\", \"products\", [\n    {\"@name\": \"@Widget\", \"@price\": 29.99, \"@stock\": 100}\n  ]],\n\n  // Add discount field\n  [\"def\", \"discounted\", [\"transform\", \"products\",\n    [\"assign\", \"@discount\", [\"*\", \"price\", 0.1]]]],\n\n  // Pick only certain fields\n  [\"def\", \"summary\", [\"transform\", \"products\",\n    [\"pick\", \"@name\", \"@price\"]]],\n\n  [\"host\", \"@print\", \"@Products with discount:\", \"discounted\"]\n]\n</code></pre>"},{"location":"tutorials/first-program/#putting-it-together-a-complete-example","title":"Putting It Together: A Complete Example","text":"<p>Let's build a program that processes a list of people:</p> <pre><code>[\n  \"do\",\n\n  // Sample data\n  [\"def\", \"people\", [\n    {\"name\": \"Alice\", \"age\": 30, \"city\": \"NYC\"},\n    {\"name\": \"Bob\", \"age\": 25, \"city\": \"SF\"}, \n    {\"name\": \"Charlie\", \"age\": 35, \"city\": \"NYC\"},\n    {\"name\": \"Diana\", \"age\": 28, \"city\": \"LA\"}\n  ]],\n\n  // Helper functions\n  [\"def\", \"get-name\", [\"lambda\", [\"person\"], [\"get\", \"person\", \"name\"]]],\n  [\"def\", \"get-age\", [\"lambda\", [\"person\"], [\"get\", \"person\", \"age\"]]],\n  [\"def\", \"is-adult\", [\"lambda\", [\"person\"], [\"&gt;=\", [\"get-age\", \"person\"], 18]]],\n  [\"def\", \"lives-in-nyc\", [\"lambda\", [\"person\"], [\"=\", [\"get\", \"person\", \"city\"], \"NYC\"]]],\n\n  // Process the data\n  [\"def\", \"adults\", [\"filter\", \"is-adult\", \"people\"]],\n  [\"def\", \"nyc-adults\", [\"filter\", \"lives-in-nyc\", \"adults\"]],\n  [\"def\", \"nyc-names\", [\"map\", \"get-name\", \"nyc-adults\"]],\n  [\"def\", \"average-age\", \n   [\"/\", [\"reduce\", \"+\", [\"map\", \"get-age\", \"adults\"], 0], [\"length\", \"adults\"]]],\n\n  // Output results\n  [\"print\", \"All people:\", [\"map\", \"get-name\", \"people\"]],\n  [\"print\", \"Adults in NYC:\", \"nyc-names\"],\n  [\"print\", \"Average age of adults:\", \"average-age\"]\n]\n</code></pre> <p>This program demonstrates:</p> <ul> <li>Working with structured data (lists and dictionaries)</li> <li>Creating helper functions for common operations</li> <li>Chaining operations together (filter, then map)</li> <li>Computing aggregates (average age)</li> </ul>"},{"location":"tutorials/first-program/#what-youve-learned","title":"What You've Learned","text":"<p>Congratulations! You now understand:</p> <ol> <li>Prefix notation - operators come first</li> <li>Variables - using <code>def</code> to bind values to names</li> <li>Functions - creating them with <code>lambda</code></li> <li>Lists and dictionaries - fundamental data structures</li> <li>Higher-order functions - <code>map</code>, <code>filter</code>, <code>reduce</code></li> <li>Conditional logic - making decisions with <code>if</code></li> <li>JSON structure - how code and data are the same</li> </ol>"},{"location":"tutorials/first-program/#next-steps","title":"Next Steps","text":"<p>Ready to learn more? Try these tutorials:</p> <ul> <li>Working with Functions - Advanced function concepts</li> <li>Data Manipulation - Complex data processing patterns</li> <li>Code Serialization - Sending code over networks</li> <li>Distributed Computing - Building distributed applications</li> </ul>"},{"location":"tutorials/first-program/#practice-exercises","title":"Practice Exercises","text":"<p>Try building these programs yourself:</p> <ol> <li> <p>FizzBuzz: Print numbers 1-100, but \"Fizz\" for multiples of 3, \"Buzz\" for multiples of 5, and \"FizzBuzz\" for multiples of both.</p> </li> <li> <p>Word Counter: Given a list of words, count how many times each word appears.</p> </li> <li> <p>Temperature Converter: Create functions to convert between Celsius and Fahrenheit.</p> </li> <li> <p>Shopping Cart: Calculate the total price of items in a shopping cart, including tax.</p> </li> </ol> <p>Ready to tackle these? You have all the tools you need!</p>"},{"location":"tutorials/functions/","title":"Learning Functions in JSL","text":""},{"location":"tutorials/functions/#introduction","title":"Introduction","text":"<p>Functions are the building blocks of JSL programs. In this tutorial, you'll learn to create, use, and combine functions through hands-on examples.</p>"},{"location":"tutorials/functions/#your-first-function","title":"Your First Function","text":"<p>Let's start with the simplest possible function:</p> <pre><code>[\"lambda\", [\"x\"], \"x\"]\n</code></pre> <p>This is the identity function - it returns whatever you give it. Try it:</p> <pre><code>[[\"lambda\", [\"x\"], \"x\"], \"hello\"]\n// Result: \"hello\"\n</code></pre>"},{"location":"tutorials/functions/#naming-functions","title":"Naming Functions","text":"<p>Usually, you'll want to give functions names:</p> <pre><code>[\"def\", \"identity\", [\"lambda\", [\"x\"], \"x\"]]\n</code></pre> <p>Now you can use it by name:</p> <pre><code>[\"identity\", \"hello\"]\n// Result: \"hello\"\n</code></pre>"},{"location":"tutorials/functions/#functions-with-multiple-parameters","title":"Functions with Multiple Parameters","text":"<pre><code>[\"def\", \"add\", [\"lambda\", [\"a\", \"b\"], [\"+\", \"a\", \"b\"]]]\n[\"add\", 3, 7]\n// Result: 10\n</code></pre>"},{"location":"tutorials/functions/#step-by-step-building-a-math-library","title":"Step-by-Step: Building a Math Library","text":""},{"location":"tutorials/functions/#step-1-basic-operations","title":"Step 1: Basic Operations","text":"<pre><code>[\"do\",\n  [\"def\", \"square\", [\"lambda\", [\"x\"], [\"*\", \"x\", \"x\"]]],\n  [\"def\", \"double\", [\"lambda\", [\"x\"], [\"*\", \"x\", 2]]],\n  [\"def\", \"half\", [\"lambda\", [\"x\"], [\"/\", \"x\", 2]]]]\n</code></pre>"},{"location":"tutorials/functions/#step-2-test-your-functions","title":"Step 2: Test Your Functions","text":"<pre><code>[\"square\", 5]    // Result: 25\n[\"double\", 5]    // Result: 10  \n[\"half\", 10]     // Result: 5\n</code></pre>"},{"location":"tutorials/functions/#step-3-combining-functions","title":"Step 3: Combining Functions","text":"<pre><code>[\"def\", \"square_and_double\", \n  [\"lambda\", [\"x\"], [\"double\", [\"square\", \"x\"]]]]\n\n[\"square_and_double\", 3]\n// 3 \u2192 square \u2192 9 \u2192 double \u2192 18\n</code></pre>"},{"location":"tutorials/functions/#higher-order-functions","title":"Higher-Order Functions","text":"<p>Functions that work with other functions:</p>"},{"location":"tutorials/functions/#step-1-a-function-that-applies-another-function-twice","title":"Step 1: A Function That Applies Another Function Twice","text":"<pre><code>[\"def\", \"twice\", \n  [\"lambda\", [\"f\", \"x\"], [\"f\", [\"f\", \"x\"]]]]\n</code></pre>"},{"location":"tutorials/functions/#step-2-use-it","title":"Step 2: Use It","text":"<pre><code>[\"twice\", \"double\", 5]\n// 5 \u2192 double \u2192 10 \u2192 double \u2192 20\n</code></pre>"},{"location":"tutorials/functions/#working-with-lists","title":"Working with Lists","text":""},{"location":"tutorials/functions/#step-1-processing-each-item","title":"Step 1: Processing Each Item","text":"<pre><code>[\"def\", \"numbers\", [1, 2, 3, 4, 5]]\n[\"map\", \"square\", \"numbers\"]\n// Result: [1, 4, 9, 16, 25]\n</code></pre>"},{"location":"tutorials/functions/#step-2-filtering-lists","title":"Step 2: Filtering Lists","text":"<pre><code>[\"def\", \"is_even\", [\"lambda\", [\"x\"], [\"=\", [\"mod\", \"x\", 2], 0]]]\n[\"filter\", \"is_even\", \"numbers\"]\n// Result: [2, 4]\n</code></pre>"},{"location":"tutorials/functions/#step-3-combining-operations","title":"Step 3: Combining Operations","text":"<pre><code>[\"def\", \"sum_of_squares_of_evens\",\n  [\"lambda\", [\"numbers\"],\n    [\"sum\", [\"map\", \"square\", [\"filter\", \"is_even\", \"numbers\"]]]]]\n\n[\"sum_of_squares_of_evens\", [1, 2, 3, 4, 5]]\n// [1,2,3,4,5] \u2192 filter evens \u2192 [2,4] \u2192 square \u2192 [4,16] \u2192 sum \u2192 20\n</code></pre>"},{"location":"tutorials/functions/#closures-functions-that-remember","title":"Closures: Functions That Remember","text":"<pre><code>[\"def\", \"make_adder\", \n  [\"lambda\", [\"n\"], \n    [\"lambda\", [\"x\"], [\"+\", \"x\", \"n\"]]]]\n\n[\"def\", \"add_10\", [\"make_adder\", 10]]\n[\"add_10\", 5]\n// Result: 15\n</code></pre> <p>The inner function \"remembers\" the value of <code>n</code> (10) even after <code>make_adder</code> finishes.</p>"},{"location":"tutorials/functions/#practice-exercises","title":"Practice Exercises","text":""},{"location":"tutorials/functions/#exercise-1-temperature-converter","title":"Exercise 1: Temperature Converter","text":"<p>Create functions to convert between Celsius and Fahrenheit:</p> <pre><code>// Your solution here\n[\"def\", \"celsius_to_fahrenheit\", [\"lambda\", [\"c\"], ...]]\n[\"def\", \"fahrenheit_to_celsius\", [\"lambda\", [\"f\"], ...]]\n</code></pre> Solution <pre><code>[\"do\",\n  [\"def\", \"celsius_to_fahrenheit\", \n    [\"lambda\", [\"c\"], [\"+\", [\"*\", \"c\", 9/5], 32]]],\n  [\"def\", \"fahrenheit_to_celsius\", \n    [\"lambda\", [\"f\"], [\"*\", [\"-\", \"f\", 32], 5/9]]]]\n</code></pre>"},{"location":"tutorials/functions/#exercise-2-list-statistics","title":"Exercise 2: List Statistics","text":"<p>Create a function that returns statistics about a list of numbers:</p> <pre><code>// Should return: {\"min\": 1, \"max\": 5, \"avg\": 3, \"count\": 5}\n[\"stats\", [1, 2, 3, 4, 5]]\n</code></pre> Solution <pre><code>[\"def\", \"stats\",\n  [\"lambda\", [\"numbers\"],\n    {\n      \"min\": [\"min\", \"numbers\"],\n      \"max\": [\"max\", \"numbers\"], \n      \"avg\": [\"/\", [\"sum\", \"numbers\"], [\"length\", \"numbers\"]],\n      \"count\": [\"length\", \"numbers\"]\n    }]]\n</code></pre>"},{"location":"tutorials/functions/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about working with data</li> <li>Explore JSON Objects as first-class citizens</li> <li>Try distributed computing</li> </ul> <p>Functions in JSL are powerful and flexible. With closures and higher-order functions, you can build complex programs from simple, composable pieces.</p>"}]}